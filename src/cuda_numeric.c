const char *pgstrom_cuda_numeric_code =
  "/*\n"
  " * cuda_numeric.h\n"
  " *\n"
  " * Collection of numeric functions for OpenCL devices\n"
  " * --\n"
  " * Copyright 2011-2016 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014-2016 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef CUDA_NUMERIC_H\n"
  "#define CUDA_NUMERIC_H\n"
  "\n"
  "/* PostgreSQL numeric data type */\n"
  "#if 0\n"
  "#define PG_DEC_DIGITS\t\t1\n"
  "#define PG_NBASE\t\t\t10\n"
  "typedef cl_char\t\tNumericDigit;\n"
  "#endif\n"
  "\n"
  "#if 0\n"
  "#define PG_DEC_DIGITS\t\t2\n"
  "#define PG_NBASE\t\t\t100\n"
  "typedef cl_char\t\tNumericDigit;\n"
  "#endif\n"
  "\n"
  "#if 1\n"
  "#define PG_DEC_DIGITS\t\t4\n"
  "#define PG_NBASE\t\t\t10000\n"
  "typedef cl_short\tNumericDigit;\n"
  "#endif\n"
  "\n"
  "#define PG_MAX_DIGITS\t\t18\t/* Max digits of 57 bit mantissa. */\n"
  "#define PG_MAX_DATA\t\t\t(((PG_MAX_DIGITS + (PG_DEC_DIGITS - 1)) +\t\\\n"
  "\t\t\t\t\t\t\t  (PG_DEC_DIGITS - 1)) /\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t PG_DEC_DIGITS)\n"
  "\n"
  "struct NumericShort\n"
  "{\n"
  "\tcl_ushort\t\tn_header;\t\t\t\t/* Sign + display scale + weight */\n"
  "\tNumericDigit\tn_data[PG_MAX_DATA];\t/* Digits */\n"
  "};\n"
  "\n"
  "struct NumericLong\n"
  "{\n"
  "\tcl_ushort\t\tn_sign_dscale;\t\t\t/* Sign + display scale */\n"
  "\tcl_short\t\tn_weight;\t\t\t\t/* Weight of 1st digit\t*/\n"
  "\tNumericDigit\tn_data[PG_MAX_DATA];\t/* Digits */\n"
  "};\n"
  "\n"
  "union NumericChoice\n"
  "{\n"
  "\tcl_ushort\t\t\tn_header;\t\t\t/* Header word */\n"
  "\tstruct NumericLong\tn_long;\t\t\t\t/* Long form (4-byte header) */\n"
  "\tstruct NumericShort\tn_short;\t\t\t/* Short form (2-byte header) */\n"
  "};\n"
  "\n"
  "// struct NumericData\n"
  "// {\n"
  "// \tint32\t\tvl_len_;\t\t/* varlena header (do not touch directly!) */\n"
  "// \tunion NumericChoice choice; /* choice of format */\n"
  "// };\n"
  "\n"
  "\n"
  "#define NUMERIC_SIGN_MASK\t0xC000\n"
  "#define NUMERIC_POS\t\t\t0x0000\n"
  "#define NUMERIC_NEG\t\t\t0x4000\n"
  "#define NUMERIC_SHORT\t\t0x8000\n"
  "#define NUMERIC_NAN\t\t\t0xC000\n"
  "\n"
  "#define NUMERIC_FLAGBITS(n)\t\t((n)->n_header & NUMERIC_SIGN_MASK)\n"
  "#define NUMERIC_IS_NAN(n)\t\t(NUMERIC_FLAGBITS(n) == NUMERIC_NAN)\n"
  "#define NUMERIC_IS_SHORT(n)\t\t(NUMERIC_FLAGBITS(n) == NUMERIC_SHORT)\n"
  "\n"
  "#define NUMERIC_SHORT_SIGN_MASK\t\t\t0x2000\n"
  "#define NUMERIC_SHORT_DSCALE_MASK\t\t0x1F80\n"
  "#define NUMERIC_SHORT_DSCALE_SHIFT\t\t7\n"
  "#define NUMERIC_SHORT_DSCALE_MAX\t\t(NUMERIC_SHORT_DSCALE_MASK >> \\\n"
  "\t\t\t\t\t\t\t\t\t\t NUMERIC_SHORT_DSCALE_SHIFT)\n"
  "#define NUMERIC_SHORT_WEIGHT_SIGN_MASK\t0x0040\n"
  "#define NUMERIC_SHORT_WEIGHT_MASK\t\t0x003F\n"
  "#define NUMERIC_SHORT_WEIGHT_MAX\t\tNUMERIC_SHORT_WEIGHT_MASK\n"
  "#define NUMERIC_SHORT_WEIGHT_MIN\t\t(-(NUMERIC_SHORT_WEIGHT_MASK+1))\n"
  "\n"
  "#define NUMERIC_DSCALE_MASK\t\t\t0x3FFF\n"
  "\n"
  "#define NUMERIC_DIGITS(n)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t(NUMERIC_IS_SHORT(n) ? (n)->n_short.n_data : (n)->n_long.n_data)\n"
  "#define NUMERIC_SIGN(n)\t\t\t\t\t\t\t\t\t  \\\n"
  "\t(NUMERIC_IS_SHORT(n)\t\t\t\t\t\t\t\t  \\\n"
  "\t ? (((n)->n_short.n_header & NUMERIC_SHORT_SIGN_MASK) \\\n"
  "\t\t? NUMERIC_NEG\t\t\t\t\t\t\t\t\t  \\\n"
  "\t\t: NUMERIC_POS)\t\t\t\t\t\t\t\t\t  \\\n"
  "\t : NUMERIC_FLAGBITS(n))\n"
  "#define NUMERIC_DSCALE(n)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t(NUMERIC_IS_SHORT(n) ?\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t (((n)->n_short.n_header & NUMERIC_SHORT_DSCALE_MASK) >>\t\t\t\\\n"
  "\t  NUMERIC_SHORT_DSCALE_SHIFT)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t : ((n)->n_long.n_sign_dscale & NUMERIC_DSCALE_MASK))\n"
  "#define NUMERIC_WEIGHT(n)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t(NUMERIC_IS_SHORT(n)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t ? (((n)->n_short.n_header & NUMERIC_SHORT_WEIGHT_SIGN_MASK\t\t\t\\\n"
  "\t\t ? ~NUMERIC_SHORT_WEIGHT_MASK\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t : 0) |\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t((n)->n_short.n_header & NUMERIC_SHORT_WEIGHT_MASK))\t\t\t\\\n"
  "\t : ((n)->n_long.n_weight))\n"
  "\n"
  "\n"
  "/* IEEE 754 FORMAT */\n"
  "#if 0\n"
  "#define PG_FLOAT_SIGN_POS\t31\n"
  "#define PG_FLOAT_SIGN_BITS\t1\n"
  "#define PG_FLOAT_EXPO_POS\t23\n"
  "#define PG_FLOAT_EXPO_BITS\t8\n"
  "#define PG_FLOAT_MANT_POS\t0\n"
  "#define PG_FLOAT_MANT_BITS\t23\n"
  "\n"
  "#define PG_DOUBLE_SIGN_POS\t63\n"
  "#define PG_DOUBLE_SIGN_BITS\t1\n"
  "#define PG_DOUBLE_EXPO_POS\t52\n"
  "#define PG_DOUBLE_EXPO_BITS\t11\n"
  "#define PG_DOUBLE_MANT_POS\t0\n"
  "#define PG_DOUBLE_MANT_BITS\t52\n"
  "#endif\n"
  "\n"
  "\n"
  "/*\n"
  " * PG-Strom internal representation of NUMERIC data type\n"
  " *\n"
  " * Even though the nature of NUMERIC data type is variable-length and error-\n"
  " * less mathmatical operation, we assume most of numeric usage can be hosted\n"
  " * within 64bit variable. A small number anomaly can be calculated by CPU,\n"
  " * so we focus on the major portion of use-cases.\n"
  " * Internal data format of numeric is 64-bit integer that is separated to\n"
  " * (1) 6bit exponents based on 10, (2) 1bit sign bit, and (3) 57bit mantissa.\n"
  " * Function that can handle NUMERIC data type will set StromError_CpuReCheck,\n"
  " * if it detects overflow during calculation.\n"
  " */\n"
  "typedef struct {\n"
  "\tcl_ulong\tvalue;\n"
  "\tbool\t\tisnull;\n"
  "} pg_numeric_t;\n"
  "\n"
  "#define PG_NUMERIC_EXPONENT_BITS\t6\n"
  "#define PG_NUMERIC_EXPONENT_POS\t\t58\n"
  "#define PG_NUMERIC_EXPONENT_MASK\t\\\n"
  "\t(((0x1UL << (PG_NUMERIC_EXPONENT_BITS)) - 1) << (PG_NUMERIC_EXPONENT_POS))\n"
  "#define PG_NUMERIC_EXPONENT_MAX\t\t\\\n"
  "\t((1 << ((PG_NUMERIC_EXPONENT_BITS) - 1)) - 1)\n"
  "#define PG_NUMERIC_EXPONENT_MIN\t\t\\\n"
  "\t(0 - (1 << ((PG_NUMERIC_EXPONENT_BITS) - 1)))\n"
  "\n"
  "#define PG_NUMERIC_SIGN_BITS\t\t1\n"
  "#define PG_NUMERIC_SIGN_POS\t\t\t57\n"
  "#define PG_NUMERIC_SIGN_MASK\t\t\\\n"
  "\t(((0x1UL << (PG_NUMERIC_SIGN_BITS)) - 1) << (PG_NUMERIC_SIGN_POS))\n"
  "\n"
  "#define PG_NUMERIC_MANTISSA_BITS\t57\n"
  "#define PG_NUMERIC_MANTISSA_POS\t\t0\n"
  "#define PG_NUMERIC_MANTISSA_MASK\t\\\n"
  "\t(((0x1UL << (PG_NUMERIC_MANTISSA_BITS)) - 1) << (PG_NUMERIC_MANTISSA_POS))\n"
  "#define PG_NUMERIC_MANTISSA_MAX\t\t((0x1UL << (PG_NUMERIC_MANTISSA_BITS)) - 1)\n"
  "\n"
  "#define PG_NUMERIC_EXPONENT(num)\t((cl_long)(num) >> 58)\n"
  "#define PG_NUMERIC_SIGN(num)\t\t(((num) & PG_NUMERIC_SIGN_MASK) != 0)\n"
  "#define PG_NUMERIC_MANTISSA(num)\t((num) & PG_NUMERIC_MANTISSA_MASK)\n"
  "#define PG_NUMERIC_SET(expo,sign,mant)\t\t\t\t\t\t\t\\\n"
  "\t((cl_ulong)((cl_long)(expo) << 58) |\t\t\t\t\t\t\\\n"
  "\t ((sign) != 0 ? PG_NUMERIC_SIGN_MASK : 0UL) |\t\t\t\t\\\n"
  "\t ((mant) & PG_NUMERIC_MANTISSA_MASK))\n"
  "\n"
  "#define PG_NUMERIC_ZERO\t\t\t\tPG_NUMERIC_SET(0,0,0)\n"
  "#define PG_NUMERIC_MAX\t\t\t\t\\\n"
  "\tPG_NUMERIC_SET(PG_NUMERIC_EXPONENT_MAX,0,PG_NUMERIC_MANTISSA_MAX)\n"
  "#define PG_NUMERIC_MIN\t\t\t\t\\\n"
  "\tPG_NUMERIC_SET(PG_NUMERIC_EXPONENT_MAX,1,PG_NUMERIC_MANTISSA_MAX)\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pg_numeric_from_varlena(kern_context *kcxt, struct varlena *vl_val)\n"
  "{\n"
  "\tpg_numeric_t\t\tresult;\n"
  "\tunion NumericChoice\tnumData;\n"
  "\tcl_char\t\t\t   *pSrc;\n"
  "\tcl_int\t\t\t\tlen;\n"
  "\n"
  "\tif (vl_val == NULL)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\n"
  "\tpSrc = VARDATA_ANY(vl_val);\n"
  "\tlen  = VARSIZE_ANY_EXHDR(vl_val);\n"
  "\n"
  "\tif (sizeof(numData) < len) {\n"
  "\t\t// Numeric data is too large.\n"
  "\t\t// PG-Strom numeric type support 18 characters.\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\n"
  "\t// Once data copy to private memory for alignment.\n"
  "    // memcpy(&numData, pSrc, len);\n"
  "\t{\n"
  "\t\t// OpenCL memcpy does not support private memory.\n"
  "\t\tcl_char *dst = (cl_char *) &numData;\n"
  "\t\tcl_char *src = (cl_char *) pSrc;\n"
  "\t\tint i;\n"
  "\t\tfor(i=0; i<len; i++) {\n"
  "\t\t\tdst[i] = src[i];\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t// Convert PG-Strom numeric type from PostgreSQL numeric type.\n"
  "\t{\n"
  "\t\tint\t\t     sign\t = NUMERIC_SIGN(&numData);\n"
  "\t\tint\t\t     expo;\n"
  "\t\tcl_ulong     mant;\n"
  "\t\tint \t     weight  = NUMERIC_WEIGHT(&numData);\n"
  "//\t\tint\t\t     dscale  = NUMERIC_DSCALE(&numData);\n"
  "\t\tNumericDigit *digits = NUMERIC_DIGITS(&numData);\n"
  "\t\tint\t\t\t offset  = (unsigned long)digits - (unsigned long)&numData;\n"
  "\t\tint \t     ndigits = (len - offset) / sizeof(NumericDigit);\n"
  "\n"
  "\t\tint\t\t\t i, base;\n"
  "\t\tcl_ulong\t mantLast;\n"
  "\n"
  "\n"
  "\t\t// Numeric value is 0, if ndigits is 0. \n"
  "\t\tif (ndigits == 0) {\n"
  "\t\t\tresult.isnull = false;\n"
  "\t\t\tresult.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\t\treturn result;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Generate exponent.\n"
  "\t\texpo = (weight - (ndigits - 1)) * PG_DEC_DIGITS;\n"
  "\n"
  "\t\t// Generate mantissa.\n"
  "\t\tmant = 0;\n"
  "\t\tfor (i=0; i<ndigits-1; i++) {\n"
  "\t\t\tmant = mant * PG_NBASE + digits[i];\n"
  "\t\t}\n"
  "\n"
  "\t\tbase     = PG_NBASE;\n"
  "\t\tmantLast = digits[i];\n"
  "\t\tfor (i=0; i<PG_DEC_DIGITS; i++) {\n"
  "\t\t\tif (mantLast % 10 == 0) {\n"
  "\t\t\t\texpo ++;\n"
  "\t\t\t\tbase     /= 10;\n"
  "\t\t\t\tmantLast /= 10;\n"
  "\t\t\t} else {\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\n"
  "\t\t// overflow check\n"
  "\t\tif ((mant * base) / base != mant) {\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tresult.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn result;\n"
  "\t\t}\n"
  "\n"
  "\t\t// zero check\n"
  "\t\tmant = mant * base + mantLast;\n"
  "\n"
  "\t\tif (mant == 0) {\n"
  "\t\t\tresult.isnull = false;\n"
  "\t\t\tresult.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\t\treturn result;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Normalize\n"
  "\t\twhile (mant % 10 == 0  &&  expo < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\t\tmant /= 10;\n"
  "\t\t\texpo ++;\n"
  "\t\t}\n"
  "\n"
  "\t\tif (PG_NUMERIC_EXPONENT_MAX < expo) {\n"
  "\t\t\t// Exponent is overflow.\n"
  "\t\t\tint\t\t\texpoDiff = expo - PG_NUMERIC_EXPONENT_MAX;\n"
  "\t\t\tint\t\t\ti;\n"
  "\t\t\tcl_ulong\tmag;\n"
  "\n"
  "\t\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t\t// magnify is overflow\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\tresult.value  = 0;\n"
  "\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\t\t\tmag *= 10;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\tif ((mant * mag) / mag != mant) {\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\tresult.value  = 0;\n"
  "\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\texpo -= expoDiff;\n"
  "\t\t\tmant *= mag;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Error check\n"
  "\t\tif (expo < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo ||\n"
  "\t\t\t(mant & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tresult.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn result;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Set value to PG_Strom numeric type\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = PG_NUMERIC_SET(expo, sign, mant);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "#ifdef __CUDACC__\n"
  "\n"
  "/*\n"
  " * pg_numeric_to_varlena\n"
  " *\n"
  " * It transform the supplied pg_numeric_t value into usual varlena form.\n"
  " * Caller is responsible not to call for NULL values; thus this function\n"
  " * expects the \"pg_numeric_t arg\" is not NULL.\n"
  " * One other supplied argument \"struct varlena *vl_val\" is a pointer to\n"
  " * the global memory region that at least has XXXX bytes which is possible\n"
  " * maximum size for pg_numeric_t representation.\n"
  " * Once this function transform the supplied argument and put it on the\n"
  " * global memory with varlena format, it returns total length of the\n"
  " * written varlena datum.\n"
  " * Once an error happen, it returns 0, then set some value on errcode.\n"
  " */\n"
  "#define NUMERIC_TO_VERLENA_USE_SHORT_FORMAT\n"
  "\n"
  "STATIC_FUNCTION(cl_uint)\n"
  "pg_numeric_to_varlena(kern_context *kcxt, char *vl_buffer,\n"
  "\t\t\t\t\t  Datum value, cl_bool isnull)\n"
  "{\n"
  "\tvarattrib_4b   *pHeader = (varattrib_4b *) vl_buffer;\n"
  "\tcl_uint\t\t\tvl_len;\n"
  "\n"
  "\t/* alignment error; varlena buffer must be 4byte alignment */\n"
  "\tassert(((cl_ulong)vl_buffer % sizeof(cl_int)) == 0);\n"
  "\n"
  "\t/* NULL writes nothing anyway */\n"
  "\tif (isnull)\n"
  "\t\treturn 0;\n"
  "\n"
  "\t/* generate numeric data */\n"
  "\t{\n"
  "\t\tunion NumericChoice\t*pNumData;\n"
  "\t\tint\t\t\tsign = PG_NUMERIC_SIGN(value);\n"
  "\t\tint \t\texpo = PG_NUMERIC_EXPONENT(value);\n"
  "\t\tcl_ulong\tmant = PG_NUMERIC_MANTISSA(value);\n"
  "\t\tNumericDigit   *pNData;\n"
  "\t\tint\t\t\tdigits;\n"
  "\t\tint\t\t\tdscale;\n"
  "\t\tint\t\t\tweight;\n"
  "\t\tint\t\t\tmag;\n"
  "\t\tint\t\t\tnData;\n"
  "\t\tint\t\t\tmodExpo;\n"
  "\t\tint\t\t\ttmpDigits;\n"
  "\n"
  "\t\t{\n"
  "\t\t\tcl_ulong tmp = mant;\n"
  "\t\t\tfor (digits=0; tmp != 0; digits++, tmp/=10)\n"
  "\t\t\t\t;\n"
  "\t\t}\n"
  "\n"
  "\t\tdscale = expo < 0 ? -expo : 0;\n"
  "\n"
  "\t\tmodExpo = expo % PG_DEC_DIGITS;\n"
  "\t\tif (modExpo < 0)\n"
  "\t\t\tmodExpo = PG_DEC_DIGITS + modExpo;\n"
  "\n"
  "\t\ttmpDigits = digits + expo - 1;\n"
  "\t\tif (tmpDigits < 0)\n"
  "\t\t\ttmpDigits = tmpDigits - (PG_DEC_DIGITS-1);\n"
  "\t\tweight = tmpDigits / PG_DEC_DIGITS;\n"
  "\n"
  "\t\tnData  = (digits + modExpo + (PG_DEC_DIGITS - 1)) / PG_DEC_DIGITS;\n"
  "\n"
  "\t\t{\n"
  "\t\t\tint i;\n"
  "\t\t\tmag = 1;\n"
  "\t\t\tfor(i=0; i<modExpo; i++) {\n"
  "\t\t\t\tmag *= 10;\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\n"
  "#ifdef NUMERIC_TO_VERLENA_USE_SHORT_FORMAT\n"
  "\t\t/* create the data of the short format. */\n"
  "\t\tvl_len = (VARHDRSZ +\n"
  "\t\t\t\t  offsetof(struct NumericShort, n_data) +\n"
  "\t\t\t\t  nData * sizeof(NumericDigit));\n"
  "\t\tif (!pHeader)\n"
  "\t\t\treturn vl_len;\n"
  "\n"
  "\t\tSET_VARSIZE(pHeader, vl_len);\n"
  "\t\tpNumData = (union NumericChoice *)((char *)pHeader + VARHDRSZ);\n"
  "\t\tpNumData->n_short.n_header =\n"
  "\t\t\tNUMERIC_SHORT |\n"
  "\t\t\t(sign ? NUMERIC_SHORT_SIGN_MASK : 0) |\n"
  "\t\t\t((dscale << NUMERIC_SHORT_DSCALE_SHIFT)\n"
  "\t\t\t & NUMERIC_SHORT_DSCALE_MASK) |\n"
  "\t\t\t(weight & (NUMERIC_SHORT_WEIGHT_SIGN_MASK |\n"
  "\t\t\t\t\t   NUMERIC_SHORT_WEIGHT_MASK));\n"
  "\t\tpNData = pNumData->n_short.n_data;\n"
  "#else\n"
  "\t\t/* create the data of the long format */\n"
  "\t\tvl_len = (VARHDRSZ +\n"
  "\t\t\t\t  offsetof(struct NumericLong, n_data) +\n"
  "\t\t\t\t  nData * sizeof(NumericDigit));\n"
  "\t\tif (!pHeader)\n"
  "\t\t\treturn vl_len;\n"
  "\n"
  "\t\tSET_VARSIZE(pHeader, vl_len);\n"
  "\t\tpNumData = (union NumericChoice *)((char *)pHeader + VARHDRSZ);\n"
  "\t\tpNumData->n_long.n_sign_dscale = ((sign ? NUMERIC_SIGN_MASK : 0) |\n"
  "\t\t\t\t\t\t\t\t\t\t  (dscale & NUMERIC_SHORT_SCALE_MASK));\n"
  "\t\tpNumData->n_long.n_weight = weight;\n"
  "\t\tpNData = pNumData->n_long.n_data;\n"
  "#endif\n"
  "\n"
  "\t\tif (nData > 0)\n"
  "\t\t{\n"
  "\t\t\tpNData[nData-1] = (mant % (PG_NBASE/mag)) * mag;\n"
  "\t\t\tmant /= (PG_NBASE/mag);\n"
  "\n"
  "\t\t\t{\n"
  "\t\t\t\tint i;\n"
  "\t\t\t\tfor (i = nData - 2; 0 <= i; i--)\n"
  "\t\t\t\t{\n"
  "\t\t\t\t\tpNData[i] = mant % PG_NBASE;\n"
  "\t\t\t\t\tmant /= PG_NBASE;\n"
  "\t\t\t\t}\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\t}\n"
  "\treturn vl_len;\n"
  "}\n"
  "\n"
  "\n"
  "/*\n"
  " * pg_numeric_vref\n"
  " *\n"
  " * It contains special case handling due to internal numeric format.\n"
  " * If kds intends to have varlena format (PostgreSQL compatible), it tries\n"
  " * to reference varlena variable. Otherwise, in case when attlen > 0, it\n"
  " * tries to fetch fixed-length variable.\n"
  " */\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pg_numeric_datum_ref(kern_context *kcxt,\n"
  "\t\t\t\t\t void *datum,\n"
  "\t\t\t\t\t cl_bool internal_format)\n"
  "{\n"
  "\tpg_numeric_t\tresult;\n"
  "\n"
  "\tif (!datum)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (!internal_format)\n"
  "\t\tresult = pg_numeric_from_varlena(kcxt, (varlena *) datum);\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = *((cl_ulong *) datum);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pg_numeric_vref(kern_data_store *kds,\n"
  "\t\t\t\tkern_context *kcxt,\n"
  "\t\t\t\tcl_uint colidx,\n"
  "\t\t\t\tcl_uint rowidx)\n"
  "{\n"
  "\tvoid\t   *datum = kern_get_datum(kds,colidx,rowidx);\n"
  "\tcl_bool\t\tinternal_format = (kds->colmeta[colidx].attlen > 0);\n"
  "\n"
  "\treturn pg_numeric_datum_ref(kcxt,datum,internal_format);\n"
  "}\n"
  "\n"
  "/* pg_numeric_vstore() is same as template */\n"
  "STROMCL_SIMPLE_VARSTORE_TEMPLATE(numeric, cl_ulong)\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pg_numeric_param(kern_context *kcxt,\n"
  "\t\t\t\t cl_uint param_id)\n"
  "{\n"
  "\tkern_parambuf  *kparams = kcxt->kparams;\n"
  "\tvarlena\t\t   *vl_val;\n"
  "\tpg_numeric_t\tresult;\n"
  "\n"
  "\tif (param_id < kparams->nparams &&\n"
  "\t\tkparams->poffset[param_id] > 0)\n"
  "\t{\n"
  "\t\tvl_val = (varlena *)((char *)kparams + kparams->poffset[param_id]);\n"
  "\t\t/* only uncompressed & inline datum */\n"
  "\t\tif (VARATT_IS_4B_U(vl_val) || VARATT_IS_1B(vl_val))\n"
  "\t\t\treturn pg_numeric_from_varlena(kcxt, vl_val);\n"
  "\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\tresult.isnull = true;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/* NULL check functions */\n"
  "STROMCL_SIMPLE_NULLTEST_TEMPLATE(numeric)\n"
  "/* CRC32 calculation function */\n"
  "STROMCL_SIMPLE_COMP_CRC32_TEMPLATE(numeric,cl_long)\n"
  "/* NUMERIC internal to Datum */\n"
  "STATIC_INLINE(Datum)\n"
  "pg_numeric_to_datum(cl_ulong value)\n"
  "{\n"
  "\treturn (Datum) value;\n"
  "}\n"
  "\n"
  "/* to avoid conflicts with auto-generated data type */\n"
  "#define PG_NUMERIC_TYPE_DEFINED\n"
  "\n"
  "/*\n"
  " * Numeric format translation functions\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "STATIC_FUNCTION(pg_int8_t)\n"
  "numeric_to_integer(kern_context *kcxt, pg_numeric_t arg, cl_int size)\n"
  "{\n"
  "\tpg_int8_t\tv;\n"
  "\tint\t\t    sign, expo;\n"
  "\tcl_ulong\tmant;\n"
  "\n"
  "\n"
  "\tif (arg.isnull == true) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\texpo = PG_NUMERIC_EXPONENT(arg.value);\n"
  "\tsign = PG_NUMERIC_SIGN(arg.value);\n"
  "\tmant = PG_NUMERIC_MANTISSA(arg.value);\n"
  "\t\n"
  "\tif (mant == 0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = 0;\n"
  "\t}\n"
  "\n"
  "\t{\n"
  "\t\tint  exp = abs(expo);\n"
  "\t\tlong mag = 1;\n"
  "\n"
  "\t\tfor(int i=0; i<exp; i++) {\n"
  "\t\t\tif((mag * 10) < mag) {\n"
  "\t\t\t\tv.isnull = true;\n"
  "\t\t\t\tv.value  = 0;\n"
  "\t\t\t\treturn v;\n"
  "\t\t\t}\n"
  "\t\t\tmag *= 10;\n"
  "\t\t}\n"
  "\n"
  "\t\tif (expo < 0) {\n"
  "\t\t\t// Round off if exponent is minus.\n"
  "\t\t\tmant = (mant + mag/2) / mag;\n"
  "\n"
  "\t\t} else {\n"
  "\t\t\t// Overflow check\n"
  "\t\t\tif ((mant * mag) / mag != mant) {\n"
  "\t\t\t\tv.isnull = true;\n"
  "\t\t\t\tv.value  = 0;\n"
  "\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\t\treturn v;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\tmant *= mag;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t// Overflow check\n"
  "\t{\n"
  "\t\tint      nbits       = size * BITS_PER_BYTE;\n"
  "\t\tcl_ulong max_val     = (1UL << (nbits - 1)) - 1;\n"
  "\t\tcl_ulong abs_min_val = (1UL << (nbits - 1));\n"
  "\t\tif((sign == 0 && max_val < mant) ||\n"
  "\t\t   (sign != 0 && abs_min_val < mant)) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = (sign == 0) ? mant : (-mant);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_float8_t)\n"
  "numeric_to_float(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_float8_t\tv;\n"
  "\tint\t\t\texpo, sign;\n"
  "\tcl_ulong\tmant;\n"
  "\tdouble\t\tfvalue;\n"
  "\n"
  "\n"
  "\tif (arg.isnull == true) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\texpo = PG_NUMERIC_EXPONENT(arg.value);\n"
  "\tsign = PG_NUMERIC_SIGN(arg.value);\n"
  "\tmant = PG_NUMERIC_MANTISSA(arg.value);\n"
  "\n"
  "\tif (mant == 0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\n"
  "\tfvalue = (double)mant * exp10((double)expo);\n"
  "\n"
  "\tif (isinf(fvalue) || isnan(fvalue)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = (sign == 0) ? fvalue : (-fvalue);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int2_t)\n"
  "pgfn_numeric_int2(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_int2_t v;\n"
  "\tpg_int8_t tmp = numeric_to_integer(kcxt, arg, sizeof(v.value));\n"
  "\n"
  "\tv.isnull = tmp.isnull;\n"
  "\tv.value  = tmp.value;\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_numeric_int4(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_int4_t v;\n"
  "\tpg_int8_t tmp = numeric_to_integer(kcxt, arg, sizeof(v.value));\n"
  "\n"
  "\tv.isnull = tmp.isnull;\n"
  "\tv.value  = tmp.value;\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int8_t)\n"
  "pgfn_numeric_int8(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_int8_t v;\n"
  "\treturn numeric_to_integer(kcxt, arg, sizeof(v.value));\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_float4_t)\n"
  "pgfn_numeric_float4(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\n"
  "\tpg_float8_t tmp = numeric_to_float(kcxt, arg);\n"
  "\tpg_float4_t\tv   = { (cl_float)tmp.value, tmp.isnull };\n"
  "\n"
  "\tif (v.isnull == false  &&  isinf(v.value)) {\n"
  "\t\tv.isnull\t= true;\n"
  "\t\tv.value\t\t= 0;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_float8_t)\n"
  "pgfn_numeric_float8(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\treturn numeric_to_float(kcxt, arg);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "integer_to_numeric(kern_context *kcxt, pg_int8_t arg, cl_int size)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\tint\t\t\t\tsign;\n"
  "\tint\t\t\t\texpo;\n"
  "\tcl_ulong\t\tmant;\n"
  "\n"
  "\n"
  "\tif (arg.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\t\t\n"
  "\tif (arg.value == 0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tif (0 <= arg.value) {\n"
  "\t\tsign = 0;\n"
  "\t\tmant = arg.value;\n"
  "\t} else {\n"
  "\t\tsign = 1;\n"
  "\t\tmant = -arg.value;\n"
  "\t}\n"
  "\texpo = 0;\n"
  "\n"
  "\t// Normalize\n"
  "\twhile (mant % 10 == 0  &&  expo < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant /= 10;\n"
  "\t\texpo ++;\n"
  "\t}\n"
  "\n"
  "\tif(PG_NUMERIC_MANTISSA_BITS < size * BITS_PER_BYTE - 1) {\n"
  "\t\t// Error check\n"
  "\t\tif (mant & ~PG_NUMERIC_MANTISSA_MASK) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo, sign, mant);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "float_to_numeric(kern_context *kcxt, pg_float8_t arg, int dig)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\tint\t\t\t\tsign, expo;\n"
  "\tcl_ulong\t\tmant;\n"
  "\n"
  "\n"
  "\tif (arg.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tif (isnan(arg.value) || isinf(arg.value)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tif (arg.value == 0.0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\n"
  "\t{\n"
  "\t\tdouble\tfval, fmant, thrMax, thrMin;\n"
  "\t\tint\t\tfexpo;\n"
  "\n"
  "\t\tif (0 <= arg.value) {\n"
  "\t\t\tsign = 0;\n"
  "\t\t\tfval = arg.value;\n"
  "\t\t} else {\n"
  "\t\t\tsign = 1;\n"
  "\t\t\tfval = -arg.value;\n"
  "\t\t}\n"
  "\n"
  "\t\tfexpo = ceil(log10(fval)) + 1;\n"
  "\t\tfmant = fval * (double)exp10((double)(dig - fexpo));\n"
  "\t\tif(isinf(fmant)) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\texpo  = fexpo - dig;\n"
  "\n"
  "\t\tthrMax = exp10((double)(dig));\n"
  "\t\twhile(thrMax < fmant) {\n"
  "\t\t\tfmant /= 10;\n"
  "\t\t\texpo ++;\n"
  "\t\t}\n"
  "\t\tthrMin = thrMax / 10;\n"
  "\t\twhile(fmant < thrMin) {\n"
  "\t\t\tfmant *= 10;\n"
  "\t\t\texpo --;\n"
  "\t\t}\n"
  "\n"
  "\t\tmant = fmant + 0.5;\n"
  "\t}\n"
  "\n"
  "\n"
  "\t// normalize\n"
  "\twhile (mant % 10 == 0  &&  expo < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant /= 10;\n"
  "\t\texpo ++;\n"
  "\t}\n"
  "\n"
  "\tif (PG_NUMERIC_EXPONENT_MAX < expo) {\n"
  "\t\t// Exponent is overflow.\n"
  "\t\tint \t\texpoDiff = expo - PG_NUMERIC_EXPONENT_MAX;\n"
  "\t\tint\t\t\ti;\n"
  "\t\tcl_ulong\tmag;\n"
  "\n"
  "\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t// magnify is overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\t\tmag *= 10;\n"
  "\t\t}\n"
  "\n"
  "\t\tif ((mant * mag) / mag != mant) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\texpo -= expoDiff;\n"
  "\t\tmant *= mag;\n"
  "\t}\n"
  "\n"
  "\t// Error check\n"
  "\tif (expo < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo ||\n"
  "\t\t(mant & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo, sign, mant);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_int2_numeric(kern_context *kcxt, pg_int2_t arg)\n"
  "{\n"
  "\tpg_int8_t tmp = { arg.value, arg.isnull };\n"
  "\treturn integer_to_numeric(kcxt, tmp, sizeof(arg.value));\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_int4_numeric(kern_context *kcxt, pg_int4_t arg)\n"
  "{\n"
  "\tpg_int8_t tmp = { arg.value, arg.isnull };\n"
  "\treturn integer_to_numeric(kcxt, tmp, sizeof(arg.value));\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_int8_numeric(kern_context *kcxt, pg_int8_t arg)\n"
  "{\n"
  "\treturn integer_to_numeric(kcxt, arg, sizeof(arg.value));\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_float4_numeric(kern_context *kcxt, pg_float4_t arg)\n"
  "{\n"
  "\tpg_float8_t tmp = { (cl_double)arg.value, arg.isnull };\n"
  "\treturn float_to_numeric(kcxt, tmp, FLT_DIG);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_float8_numeric(kern_context *kcxt, pg_float8_t arg)\n"
  "{\n"
  "\treturn float_to_numeric(kcxt, arg, DBL_DIG);\n"
  "}\n"
  "\n"
  "/*\n"
  " * Numeric operator functions\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_uplus(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\t/* return the value as-is */\n"
  "\treturn arg;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_uminus(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\t/* reverse the sign bit */\n"
  "\targ.value ^= PG_NUMERIC_SIGN_MASK;\n"
  "\treturn arg;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_abs(kern_context *kcxt, pg_numeric_t arg)\n"
  "{\n"
  "\t/* clear the sign bit */\n"
  "\targ.value &= ~PG_NUMERIC_SIGN_MASK;\n"
  "\treturn arg;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_add(kern_context *kcxt,\n"
  "\t\t\t\t pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\tint\t\t\texpo1, expo2, sign1, sign2;\n"
  "\tcl_ulong\tmant1, mant2;\n"
  "\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\texpo1 = PG_NUMERIC_EXPONENT(arg1.value);\n"
  "\tsign1 = PG_NUMERIC_SIGN(arg1.value);\n"
  "\tmant1 = PG_NUMERIC_MANTISSA(arg1.value);\n"
  "\n"
  "\texpo2 = PG_NUMERIC_EXPONENT(arg2.value);\n"
  "\tsign2 = PG_NUMERIC_SIGN(arg2.value);\n"
  "\tmant2 = PG_NUMERIC_MANTISSA(arg2.value);\n"
  "\n"
  "\t// Change the number of digits\n"
  "\tif (expo1 != expo2) {\n"
  "\t\tint\t\t\texpoDiff = abs(expo1 - expo2);\n"
  "\t\tcl_ulong\tvalue\t  = (expo1 < expo2) ? (mant2) : (mant1);\n"
  "\t\tcl_ulong\tmag;\n"
  "\t\tint\t\t\ti;\n"
  "\n"
  "\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t// magnify is overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR_EXTRA(&kcxt->e, StromError_CpuReCheck,\n"
  "\t\t\t\t\t\t\t\t  arg1.value, arg2.value, expoDiff);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tmag = 1;\n"
  "\t\tfor (i=0; i < expoDiff; i++) {\n"
  "\t\t\tmag *= 10;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Overflow check\n"
  "\t\tif ((value * mag) / mag != value) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR_EXTRA(&kcxt->e, StromError_CpuReCheck,\n"
  "\t\t\t\t\t\t\t\t  arg1.value, arg2.value, mag);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tif (expo1 < expo2) {\n"
  "\t\t\tmant2 = value * mag;\n"
  "\t\t\texpo2 = expo1;\n"
  "\t\t} else {\n"
  "\t\t\tmant1 = value * mag;\n"
  "\t\t\texpo1 = expo2;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t// Add mantissa \n"
  "\tif (sign1 != sign2) {\n"
  "\t\tif (mant1 < mant2) {\n"
  "\t\t\tsign1 = sign2;\n"
  "\t\t\tmant1 = mant2 - mant1;\n"
  "\t\t} else {\n"
  "\t\t\tmant1 -= mant2;\n"
  "\t\t}\n"
  "\t} else {\n"
  "\t\tif ((mant1 + mant2) < mant1) {\n"
  "\t\t\t// Overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR_EXTRA(&kcxt->e, StromError_CpuReCheck,\n"
  "\t\t\t\t\t\t\t\t  arg1.value, arg2.value, mant1);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\t\tmant1 += mant2;\n"
  "\t}\n"
  "\n"
  "\t// Set 0 if mantissa is 0\n"
  "\tif(mant1 == 0UL) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// Normalize\n"
  "\twhile(mant1 % 10 == 0  &&  expo1 < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant1 /= 10;\n"
  "\t\texpo1 ++;\n"
  "\t}\n"
  "\n"
  "\t// Error check\n"
  "\tif (expo1 < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo1 ||\n"
  "\t\t(mant1 & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\tSTROM_SET_ERROR_EXTRA(&kcxt->e, StromError_CpuReCheck,\n"
  "\t\t\t\t\t\t\t  arg1.value, arg2.value, expo1);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// Set\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo1, sign1, mant1);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_sub(kern_context *kcxt,\n"
  "\t\t\t\t pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_numeric_t arg = pgfn_numeric_uminus(kcxt, arg2);\n"
  "\t\n"
  "\treturn pgfn_numeric_add(kcxt, arg1, arg);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_mul(kern_context *kcxt,\n"
  "\t\t\t\t pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\tint\t\t\t\texpo1, expo2, sign1, sign2;\n"
  "\tcl_ulong\t\tmant1, mant2;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\texpo1 = PG_NUMERIC_EXPONENT(arg1.value);\n"
  "\tsign1 = PG_NUMERIC_SIGN(arg1.value);\n"
  "\tmant1 = PG_NUMERIC_MANTISSA(arg1.value);\n"
  "\n"
  "\texpo2 = PG_NUMERIC_EXPONENT(arg2.value);\n"
  "\tsign2 = PG_NUMERIC_SIGN(arg2.value);\n"
  "\tmant2 = PG_NUMERIC_MANTISSA(arg2.value);\n"
  "\n"
  "\t// Set 0, if mantissa is 0.\n"
  "\tif (mant1 == 0UL || mant2 == 0UL) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// Calculate exponential\n"
  "\texpo1 += expo2;\n"
  "\n"
  "\t// Calculate sign\n"
  "\tsign1 ^= sign2;\n"
  " \n"
  "\t// Calculate mantissa\n"
  "\tif ((mant1 * mant2) / mant2 != mant1) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\tmant1 *= mant2;\n"
  "\n"
  "\t// Normalize\n"
  "\twhile (mant1 % 10 == 0  &&  expo1 < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant1 /= 10;\n"
  "\t\texpo1 ++;\n"
  "\t}\n"
  "\n"
  "\tif (PG_NUMERIC_EXPONENT_MAX < expo1) {\n"
  "\t\t// Exponent is overflow.\n"
  "\t\tint\t\t\texpoDiff = expo1 - PG_NUMERIC_EXPONENT_MAX;\n"
  "\t\tcl_ulong\tmag;\n"
  "\t\tint\t\t\ti;\n"
  "\n"
  "\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t// magnify is overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\t\tmag *= 10;\n"
  "\t\t}\n"
  "\n"
  "\t\tif ((mant1 * mag) / mag != mant1) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\texpo1 -= expoDiff;\n"
  "\t\tmant1 *= mag;\n"
  "\t}\n"
  "\n"
  "\t// Error check\n"
  "\tif (expo1 < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo1 ||\n"
  "\t\t(mant1 & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// set\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo1, sign1, mant1);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Numeric comparison functions\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "STATIC_FUNCTION(int)\n"
  "numeric_cmp(kern_context *kcxt, pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tint\t\t\ti, ret, expoDiff;\n"
  "\tcl_ulong\tmantL, mantR;\n"
  "\tcl_ulong \tmag;\n"
  "\n"
  "\tint\t\t\texpo1 = PG_NUMERIC_EXPONENT(arg1.value);\n"
  "\tint\t\t\tsign1 = PG_NUMERIC_SIGN(arg1.value);\n"
  "\tcl_ulong\tmant1 = PG_NUMERIC_MANTISSA(arg1.value);\n"
  "\n"
  "\tint\t\t\texpo2 = PG_NUMERIC_EXPONENT(arg2.value);\n"
  "\tint\t\t\tsign2 = PG_NUMERIC_SIGN(arg2.value);\n"
  "\tcl_ulong\tmant2 = PG_NUMERIC_MANTISSA(arg2.value);\n"
  "\n"
  "\n"
  "\t// Ignore exponential and sign, if both mantissa is 0.\n"
  "\tif(mant1 == 0  &&  mant2 == 0) {\n"
  "\t\treturn 0;\n"
  "\t}\n"
  "\n"
  "\t// Compair flag, If sign flag is different.\n"
  "\tif(sign1 != sign2) {\n"
  "\t\treturn sign2 - sign1;\n"
  "\t}\n"
  "\n"
  "\t// Compair the exponential/matissa.\n"
  "\texpoDiff = min(PG_MAX_DIGITS, (int)(abs(expo1 - expo2)));\n"
  "\n"
  "\tif (expo1 < expo2) {\n"
  "\t\tmantL = mant1;\n"
  "\t\tmantR = mant2;\t// arg2's exponential is large.\n"
  "\t} else {\n"
  "\t\tmantL = mant2;\n"
  "\t\tmantR = mant1;\t// arg1's exponential is large.\n"
  "\t}\n"
  "\n"
  "\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\tmag *= 10;\n"
  "\t}\n"
  "\n"
  "\tif ((mantR * mag) / mag != mantR  ||  mantL < mantR * mag) {\n"
  "\t\t// mantR * mag is overflow, or larger than mantL\n"
  "\t\tret = 1;\n"
  "\t} else if(mantL == mantR * mag) {\n"
  "\t\tret = 0;\n"
  "\t} else {\n"
  "\t\tret = -1;\n"
  "\t}\n"
  "\n"
  "\tif(expo1 < expo2) {\n"
  "\t\tret *= -1;\n"
  "\t}\n"
  "\n"
  "\tif(sign1 != 0) {\n"
  "\t\tret *= -1;\n"
  "\t}\n"
  "\n"
  "\treturn ret;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_numeric_eq(kern_context *kcxt,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(kcxt, arg1, arg2) == 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_numeric_ne(kern_context *kcxt,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(kcxt, arg1, arg2) != 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_numeric_lt(kern_context *kcxt,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(kcxt, arg1, arg2) < 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_numeric_le(kern_context *kcxt,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(kcxt, arg1, arg2) <= 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_numeric_gt(kern_context *kcxt,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(kcxt, arg1, arg2) > 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_numeric_ge(kern_context *kcxt,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(kcxt, arg1, arg2) >= 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_numeric_cmp(kern_context *kcxt,\n"
  "\t\t\t\t pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = numeric_cmp(kcxt, arg1, arg2);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_max(kern_context *kcxt, pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t v = pgfn_numeric_ge(kcxt, arg1, arg2);\n"
  "\n"
  "\tif (v.isnull)\n"
  "\t{\n"
  "\t\tpg_numeric_t\ttemp;\n"
  "\n"
  "\t\ttemp.isnull = true;\n"
  "\t\ttemp.value = 0;\n"
  "\n"
  "\t\treturn temp;\n"
  "\t}\n"
  "\treturn (v.value ? arg1 : arg2);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_numeric_t)\n"
  "pgfn_numeric_min(kern_context *kcxt, pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t v = pgfn_numeric_ge(kcxt, arg1, arg2);\n"
  "\n"
  "\tif (v.isnull)\n"
  "\t{\n"
  "\t\tpg_numeric_t\ttemp;\n"
  "\n"
  "\t\ttemp.isnull = true;\n"
  "\t\ttemp.value = 0;\n"
  "\n"
  "\t\treturn temp;\n"
  "\t}\n"
  "\treturn (v.value ? arg2 : arg1);\n"
  "}\n"
  "\n"
  "\n"
  "/*\n"
  " * Atomic operation support\n"
  " */\n"
  "STATIC_INLINE(cl_ulong)\n"
  "pg_atomic_min_numeric(kern_context *kcxt,\n"
  "\t\t\t\t\t  cl_ulong *ptr, cl_ulong numeric_value)\n"
  "{\n"
  "\tpg_numeric_t\tx, y;\n"
  "\tpg_int4_t\t\tcomp;\n"
  "\tcl_ulong\t\toldval;\n"
  "\tcl_ulong\t\tcurval = *ptr;\n"
  "\n"
  "\tdo {\n"
  "\t\tx.isnull = false;\n"
  "\t\ty.isnull = false;\n"
  "\t\tx.value = oldval = curval;\n"
  "\t\ty.value = numeric_value;\n"
  "\t\tcomp = pgfn_numeric_cmp(kcxt, x, y);\n"
  "\t\tif (comp.value < 0)\n"
  "\t\t\tbreak;\n"
  "\t} while ((curval = atomicCAS(ptr, oldval, numeric_value)) != oldval);\n"
  "\n"
  "\treturn oldval;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_ulong)\n"
  "pg_atomic_max_numeric(kern_context *kcxt,\n"
  "\t\t\t\t\t  cl_ulong *ptr, cl_ulong numeric_value)\n"
  "{\n"
  "\tpg_numeric_t\tx, y;\n"
  "\tpg_int4_t\t\tcomp;\n"
  "\tcl_ulong\t\toldval;\n"
  "\tcl_ulong\t\tcurval = *ptr;\n"
  "\n"
  "\tdo {\n"
  "\t\tx.isnull = false;\n"
  "\t\ty.isnull = false;\n"
  "\t\tx.value = oldval = curval;\n"
  "\t\ty.value = numeric_value;\n"
  "\t\tcomp = pgfn_numeric_cmp(kcxt, x, y);\n"
  "\t\tif (comp.value > 0)\n"
  "\t\t\tbreak;\n"
  "\t} while ((curval = atomicCAS(ptr, oldval, numeric_value)) != oldval);\n"
  "\n"
  "\treturn oldval;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_ulong)\n"
  "pg_atomic_add_numeric(kern_context *kcxt,\n"
  "\t\t\t\t\t  cl_ulong *ptr, cl_ulong numeric_value)\n"
  "{\n"
  "\tpg_numeric_t x, y, z;\n"
  "\tcl_ulong\toldval;\n"
  "\tcl_ulong\tcurval = *ptr;\n"
  "\tcl_ulong\tnewval;\n"
  "\n"
  "\tdo {\n"
  "\t\tx.isnull = false;\n"
  "\t\ty.isnull = false;\n"
  "\t\tx.value = oldval = curval;\n"
  "\t\ty.value = numeric_value;\n"
  "\t\tz = pgfn_numeric_add(kcxt, x, y);\n"
  "\t\tnewval = z.value;\n"
  "\t} while ((curval = atomicCAS(ptr, oldval, newval)) != oldval);\n"
  "\n"
  "\treturn oldval;\n"
  "}\n"
  "\n"
  "#endif /* __CUDACC__ */\n"
  "#endif /* CUDA_NUMERIC_H */\n"
;
