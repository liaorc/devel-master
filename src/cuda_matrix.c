const char *pgstrom_cuda_matrix_code =
  "/*\n"
  " * cuda_matrix.h\n"
  " *\n"
  " * collection of matrix/vector/array support routines for CUDA devices\n"
  " * --\n"
  " * Copyright 2011-2016 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014-2016 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef CUDA_MATRIX_H\n"
  "#define CUDA_MATRIX_H\n"
  "#ifdef __CUDACC__\n"
  "\n"
  "/* ------------------------------------------------------------------\n"
  " *\n"
  " * Support macros for PostgreSQL's array structure\n"
  " *\n"
  " * ------------------------------------------------------------------ */\n"
  "\n"
  "typedef struct\n"
  "{\n"
  "\t/*\n"
  "\t * NOTE: We assume 4bytes varlena header for array type. It allows\n"
  "\t * aligned references to the array elements. Unlike CPU side, we\n"
  "\t * cannot have extra malloc to ensure 4bytes varlena header. It is\n"
  "\t * the reason why our ScalarArrayOp implementation does not support\n"
  "\t * array data type referenced by Var node; which is potentially has\n"
  "\t * short format.\n"
  "\t */\n"
  "\tcl_uint\t\tvl_len_;\t\t/* don't touch this field */\n"
  "\tcl_int\t\tndim;\t\t\t/* # of dimensions */\n"
  "\tcl_int\t\tdataoffset;\t\t/* offset to data, or 0 if no bitmap */\n"
  "\tcl_uint\t\telemtype;\t\t/* element type OID */\n"
  "} ArrayType;\n"
  "\n"
  "#define MAXDIM\t\t\t6\n"
  "\n"
  "#define ARR_SIZE(a)\t\tVARSIZE_ANY(a)\n"
  "#define ARR_NDIM(a)\t\t(((ArrayType *)(a))->ndim)\n"
  "#define ARR_HASNULL(a)\t(((ArrayType *)(a))->dataoffset != 0)\n"
  "#define ARR_ELEMTYPE(a)\t(((ArrayType *)(a))->elemtype)\n"
  "#define ARR_DIMS(a)\t\t\t\t\t\t\t\t\t\\\n"
  "\t((int *) (((char *) (a)) + sizeof(ArrayType)))\n"
  "#define ARR_LBOUND(a)\t\t\t\t\t\t\t\t\\\n"
  "\t((int *) (((char *) (a)) + sizeof(ArrayType) +\t\\\n"
  "\t\t\t  sizeof(int) * ARR_NDIM(a)))\n"
  "#define ARR_NULLBITMAP(a)\t\t\t\t\t\t\t\\\n"
  "\t(ARR_HASNULL(a)\t\t\t\t\t\t\t\t\t\\\n"
  "\t ? (((char *) (a)) + sizeof(ArrayType) +\t\t\\\n"
  "\t\t2 * sizeof(int) * ARR_NDIM(a))\t\t\t\t\\\n"
  "\t : (char *) NULL)\n"
  "/*\n"
  " * The total array header size (in bytes) for an array with the specified\n"
  " * number of dimensions and total number of items.\n"
  " */\n"
  "#define ARR_OVERHEAD_NONULLS(ndims)\t\t\t\t\t\\\n"
  "\tMAXALIGN(sizeof(ArrayType) + 2 * sizeof(int) * (ndims))\n"
  "#define ARR_OVERHEAD_WITHNULLS(ndims, nitems)\t\t\\\n"
  "\tMAXALIGN(sizeof(ArrayType) + 2 * sizeof(int) * (ndims) +\t\\\n"
  "\t\t\t ((nitems) + 7) / 8)\n"
  "/*\n"
  " * Returns a pointer to the actual array data.\n"
  " */\n"
  "#define ARR_DATA_OFFSET(a)\t\t\t\t\t\\\n"
  "\t(ARR_HASNULL(a)\t\t\t\t\t\t\t\\\n"
  "\t ? ((ArrayType *)(a))->dataoffset\t\t\\\n"
  "\t : ARR_OVERHEAD_NONULLS(ARR_NDIM(a)))\n"
  "\n"
  "#define ARR_DATA_PTR(a)\t\t(((char *) (a)) + ARR_DATA_OFFSET(a))\n"
  "\n"
  "#ifndef PG_ARRAY_TYPE_DEFINED\n"
  "#define PG_ARRAY_TYPE_DEFINED\n"
  "STROMCL_VARLENA_TYPE_TEMPLATE(array)\n"
  "#endif\n"
  "\n"
  "STATIC_INLINE(cl_int)\n"
  "ArrayGetNItems(kern_context *kcxt, cl_int ndim, const cl_int *dims)\n"
  "{\n"
  "\tcl_int\t\ti, ret;\n"
  "\tcl_long\t\tprod;\n"
  "\n"
  "\tif (ndim <= 0)\n"
  "\t\treturn 0;\n"
  "\n"
  "\tret = 1;\n"
  "\tfor (i=0; i < ndim; i++)\n"
  "\t{\n"
  "\n"
  "\t\tif (dims[i] < 0)\n"
  "\t\t{\n"
  "\t\t\t/* negative dimension implies an error... */\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn 0;\n"
  "\t\t}\n"
  "\t\tprod = (cl_long) ret * (cl_long) dims[i];\n"
  "\t\tret = (cl_int) prod;\n"
  "\t\tif ((cl_long) ret != prod)\n"
  "\t\t{\n"
  "\t\t\t/* array size exceeds the maximum allowed... */\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\treturn 0;\n"
  "\t\t}\n"
  "\t}\n"
  "\tassert(ret >= 0);\n"
  "\n"
  "\treturn ret;\n"
  "}\n"
  "\n"
  "/* ----------------------------------------------------------------\n"
  " *\n"
  " * MATRIX data type support\n"
  " *\n"
  " * ---------------------------------------------------------------- */\n"
  "\n"
  "#ifndef PG_MATRIX_TYPE_DEFINED\n"
  "#define PG_MATRIX_TYPE_DEFINED\n"
  "STROMCL_VARLENA_TYPE_TEMPLATE(matrix)\n"
  "#endif\n"
  "\n"
  "#endif\t/* __CUDACC__ */\n"
  "\n"
  "typedef struct\n"
  "{\n"
  "\tcl_uint\t\t__vl_len;\t/* varlena header (only 4B header) */\n"
  "\tcl_int\t\tndim;\t\t/* always 2 for matrix */\n"
  "\tcl_int\t\tdataoffset;\t/* always 0 for matrix */\n"
  "\tcl_uint\t\telemtype;\t/* always FLOAT4OID for matrix */\n"
  "\tunion {\n"
  "\t\tstruct {\n"
  "\t\t\tcl_int\twidth;\t\t/* height of the matrix (=dim1) */\n"
  "\t\t\tcl_int\theight;\t\t/* width of the matrix (=dim2) */\n"
  "\t\t\tcl_int\tlbound1;\t/* always 1 for matrix */\n"
  "\t\t\tcl_int\tlbound2;\t/* always 1 for matrix */\n"
  "\t\t\tchar\tvalues[1];\t/* to be variable length */\n"
  "\t\t} d2;\n"
  "\t\tstruct {\n"
  "\t\t\tcl_int\theight;\t\t/* height of the vector */\n"
  "\t\t\tcl_int\tlbound1;\t/* always 1 for vector */\n"
  "\t\t\tchar\tvalues[1];\t/* to be variable length */\n"
  "\t\t} d1;\n"
  "\t} u;\n"
  "} MatrixType;\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "VALIDATE_ARRAY_MATRIX(MatrixType *matrix)\n"
  "{\n"
  "\tif (!VARATT_IS_4B(matrix))\n"
  "\t\treturn false;\n"
  "\tif (matrix->dataoffset == 0 &&\n"
  "#ifdef __CUDACC__\n"
  "\t\t(matrix->elemtype == PG_INT2OID ||\n"
  "\t\t matrix->elemtype == PG_INT4OID ||\n"
  "\t\t matrix->elemtype == PG_INT8OID ||\n"
  "\t\t matrix->elemtype == PG_FLOAT4OID ||\n"
  "\t\t matrix->elemtype == PG_FLOAT8OID)\n"
  "#else\t/* __CUDACC__ */\n"
  "\t\t(matrix->elemtype == INT2OID ||\n"
  "\t\t matrix->elemtype == INT4OID ||\n"
  "\t\t matrix->elemtype == INT8OID ||\n"
  "\t\t matrix->elemtype == FLOAT4OID ||\n"
  "\t\t matrix->elemtype == FLOAT8OID)\n"
  "#endif\t/* __CUDACC__ */\n"
  "\t\t)\n"
  "\t{\n"
  "\t\tif (matrix->ndim == 2)\n"
  "\t\t{\n"
  "\t\t\tif (matrix->u.d2.width > 0 &&\n"
  "\t\t\t\tmatrix->u.d2.height > 0 &&\n"
  "\t\t\t\tmatrix->u.d2.lbound1 == 1 &&\n"
  "\t\t\t\tmatrix->u.d2.lbound2 == 1)\n"
  "\t\t\t\treturn true;\n"
  "\t\t}\n"
  "\t\telse if (matrix->ndim == 1)\n"
  "\t\t{\n"
  "\t\t\tif (matrix->u.d1.height > 0 &&\n"
  "\t\t\t\tmatrix->u.d1.lbound1 == 1)\n"
  "\t\t\t\treturn true;\n"
  "\t\t}\n"
  "\t\telse\n"
  "\t\t\treturn false;\n"
  "\t}\n"
  "\treturn false;\n"
  "}\n"
  "\n"
  "#define ARRAY_MATRIX_ELEMTYPE(X)\t\t\t\\\n"
  "\t(((MatrixType *)(X))->elemtype)\n"
  "#define ARRAY_MATRIX_HEIGHT(X)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t(((MatrixType *)(X))->ndim == 2 ? ((MatrixType *)(X))->u.d2.height : \\\n"
  "\t ((MatrixType *)(X))->ndim == 1 ? ((MatrixType *)(X))->u.d1.height : -1)\n"
  "#define ARRAY_MATRIX_WIDTH(X)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t(((MatrixType *)(X))->ndim == 2 ? ((MatrixType *)(X))->u.d2.width :\t\\\n"
  "\t ((MatrixType *)(X))->ndim == 1 ? 1 : -1)\n"
  "#define ARRAY_MATRIX_DATAPTR(X)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t(((MatrixType *)(X))->ndim == 2 ? ((MatrixType *)(X))->u.d2.values : \\\n"
  "\t ((MatrixType *)(X))->ndim == 1 ? ((MatrixType *)(X))->u.d1.values : NULL)\n"
  "#define ARRAY_MATRIX_RAWSIZE(typlen,height,width)\t\t\\\n"
  "\toffsetof(MatrixType, u.d2.values[(size_t)(typlen) *\t\\\n"
  "\t\t\t\t\t\t\t\t\t (size_t)(height) *\t\\\n"
  "\t\t\t\t\t\t\t\t\t (size_t)(width)])\n"
  "#define ARRAY_VECTOR_RAWSIZE(typlen,nitems)\t\t\t\t\\\n"
  "\toffsetof(MatrixType, u.d1.values[(size_t)(typlen) *\t\\\n"
  "\t\t\t\t\t\t\t\t\t (size_t)(nitems)])\n"
  "\n"
  "#define INIT_ARRAY_VECTOR(X,_elemtype,_typlen,_nitems)\t\t\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tsize_t\t__len = ARRAY_VECTOR_RAWSIZE(_typlen,_nitems);\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tSET_VARSIZE(X, __len);\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->ndim = 1;\t\t\t\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->dataoffset = 0;\t\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->elemtype = (_elemtype);\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->u.d1.height = (_nitems);\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->u.d1.lbound1 = 1;\t\t\t\t\t\\\n"
  "\t} while(0)\n"
  "\n"
  "#define INIT_ARRAY_MATRIX(X,_elemtype,_typlen,_height,_width)\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tsize_t\t__len = ARRAY_MATRIX_RAWSIZE((_typlen),\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t (_height),\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t (_width));\t\t\t\\\n"
  "\t\tSET_VARSIZE(X, __len);\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->ndim = 2;\t\t\t\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->dataoffset = 0;\t\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->elemtype = (_elemtype);\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->u.d2.height = (_height);\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->u.d2.width = (_width);\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->u.d2.lbound1 = 1;\t\t\t\t\t\\\n"
  "\t\t((MatrixType *)(X))->u.d2.lbound2 = 1;\t\t\t\t\t\\\n"
  "\t} while(0)\n"
  "\n"
  "#ifdef __CUDACC__\n"
  "\n"
  "/* ----------------------------------------------------------------\n"
  " *\n"
  " * Bitonic Sorting Support for PL/CUDA functions\n"
  " *\n"
  " * pgstromMatrixSort(FP32|FP64)(cl_uint    *row_index,\t\t:out\n"
  " *                              MatrixType *matrix,\t\t\t:in\n"
  " *                              cl_uint    *sort_keys,\t\t:in\n"
  " *                              cl_uint     num_keys,\t\t:in\n"
  " *                              cl_bool     is_descending)\t:in\n"
  " *\n"
  " * This service routine supports to sort the supplied matrix according\n"
  " * to the key values specified by the 'sort_keys' and 'num_keys'.\n"
  " * Its sorting results shall be saved at the 'row_index'. It assumes\n"
  " * that 'row_index' is initialized to point a particular row of the\n"
  " * matrix uniquely, and any of row_index[] is less than the height of\n"
  " * matrix. (usually, it shall be initialized by sequential number)\n"
  " * The 'sort_keys' is an array of column index of the supplied matrix.\n"
  " * Its range is between 0 and (width of the matrix - 1).\n"
  " *\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "#define PGSTROM_MATRIX_SORT_KEYCOMP_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\\\n"
  "\tSTATIC_INLINE(cl_int)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tmatrix_sort_keycomp_##SUFFIX(BASETYPE *data_ptr,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t cl_uint\theight,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t cl_uint\twidth,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t cl_uint   *sortkeys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t cl_uint\tnum_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t cl_uint\tx_index,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t cl_uint\ty_index)\t\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\ti, j;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tBASETYPE\tx_value;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tBASETYPE\ty_value;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tfor (i=0; i < num_keys; i++)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tj = sortkeys[i];\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tassert(j < width);\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tx_value = data_ptr[j * height + x_index];\t\t\t\t\t\\\n"
  "\t\t\ty_value = data_ptr[j * height + y_index];\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (x_value < y_value)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn -1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\telse if (x_value > y_value)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn 0;\t/* both rows are equivalent */\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define PGSTROM_MATRIX_SORT_LOCAL_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\t\\\n"
  "\tKERNEL_FUNCTION_MAXTHREADS(void)\t\t\t\t\t\t\t\t\t\\\n"
  "\tmatrix_sort_local_##SUFFIX(cl_uint\t   *row_index,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   BASETYPE\t   *data_ptr,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\theight,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\twidth,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t   valid_nrows,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   cl_uint\t   *sortkeys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\tnum_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\t__direction)\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_int\t\tdirection = __direction;\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t   *localIdx = SHARED_WORKMEM(cl_uint);\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tlocalLimit;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tpartSize = 2 * get_local_size();\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tpartBase = get_global_index() * partSize;\t\t\t\\\n"
  "\t\tcl_uint\t\tblockSize;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tunitSize;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\ti;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* Load index to localIdx[] */\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tassert(valid_nrows <= height);\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tlocalLimit = (partBase + partSize <= valid_nrows\t\t\t\t\\\n"
  "\t\t\t\t\t  ? partSize\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t  : valid_nrows - partBase);\t\t\t\t\t\t\\\n"
  "\t\tfor (i = get_local_id();\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i < localLimit;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i += get_local_size())\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tlocalIdx[i] = row_index[partBase + i];\t\t\t\t\t\t\\\n"
  "\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tfor (blockSize = 2;\tblockSize <= partSize; blockSize *= 2)\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tfor (unitSize = blockSize; unitSize >= 2; unitSize /= 2)\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tcl_uint\t\tunitMask\t\t= (unitSize - 1);\t\t\t\\\n"
  "\t\t\t\tcl_uint\t\thalfUnitSize\t= (unitSize >> 1);\t\t\t\\\n"
  "\t\t\t\tcl_uint\t\thalfUnitMask\t= (halfUnitSize - 1);\t\t\\\n"
  "\t\t\t\tcl_uint\t\tidx0, idx1;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tidx0 = (((get_local_id() & ~halfUnitMask) << 1) +\t\t\\\n"
  "\t\t\t\t\t\t(get_local_id() & halfUnitMask));\t\t\t\t\\\n"
  "\t\t\t\tidx1 = (unitSize == blockSize\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t? ((idx0 & ~unitMask) | (~idx0 & unitMask))\t\t\\\n"
  "\t\t\t\t\t\t: (halfUnitSize + idx0));\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (idx1 < localLimit)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tcl_uint\t\tpos0 = localIdx[idx0];\t\t\t\t\t\\\n"
  "\t\t\t\t\tcl_uint\t\tpos1 = localIdx[idx1];\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tassert(pos0 < height && pos1 < height);\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tif (matrix_sort_keycomp_##SUFFIX(data_ptr,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t height,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t width,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t sortkeys,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t num_keys,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t pos0,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t pos1) == direction) \\\n"
  "\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t/* swap */\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tlocalIdx[idx0] = pos1;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tlocalIdx[idx1] = pos0;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* write back the sorting result of this local block */\t\t\t\\\n"
  "\t\tfor (i = get_local_id();\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i < localLimit;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i += get_local_size())\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tassert(partBase + i < valid_nrows);\t\t\t\t\t\t\t\\\n"
  "\t\t\trow_index[partBase + i] = localIdx[i];\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define PGSTROM_MATRIX_SORT_STEP_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\t\\\n"
  "\tKERNEL_FUNCTION_MAXTHREADS(void)\t\t\t\t\t\t\t\t\t\\\n"
  "\tmatrix_sort_step_##SUFFIX(cl_uint\t   *row_index,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  BASETYPE\t   *data_ptr,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  kern_arg_t\theight,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  kern_arg_t\twidth,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  kern_arg_t    valid_nrows,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  cl_uint\t   *sortkeys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  kern_arg_t\tnum_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  kern_arg_t\t__direction,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  kern_arg_t\tunitSize,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  kern_arg_t\treversing)\t\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_int\t\tdirection = __direction;\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tunitMask = unitSize - 1;\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\thalfUnitSize = unitSize >> 1;\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\thalfUnitMask = halfUnitSize - 1;\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tidx0, idx1;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tpos0, pos1;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tidx0 = (((get_global_id() & ~halfUnitMask) << 1)\t\t\t\t\\\n"
  "\t\t\t\t+ (get_global_id() & halfUnitMask));\t\t\t\t\t\\\n"
  "\t\tidx1 = (reversing\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t? ((idx0 & ~unitMask) | (~idx0 & unitMask))\t\t\t\t\\\n"
  "\t\t\t\t: (idx0 + halfUnitSize));\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (idx1 < valid_nrows)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tpos0 = row_index[idx0];\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tpos1 = row_index[idx1];\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (matrix_sort_keycomp_##SUFFIX(data_ptr,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t height,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t width,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t sortkeys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t num_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t pos0,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t pos1) == direction)\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/* swap */\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\trow_index[idx0] = pos1;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\trow_index[idx1] = pos0;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define PGSTROM_MATRIX_SORT_MERGE_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\t\\\n"
  "\tKERNEL_FUNCTION_MAXTHREADS(void)\t\t\t\t\t\t\t\t\t\\\n"
  "\tmatrix_sort_merge_##SUFFIX(cl_uint\t   *row_index,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   BASETYPE\t   *data_ptr,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\theight,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\twidth,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t   valid_nrows,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   cl_uint\t   *sortkeys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\tnum_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t   kern_arg_t\t__direction)\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_int\t\tdirection = __direction;\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t   *localIdx = SHARED_WORKMEM(cl_uint);\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tlocalLimit;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tpartSize = 2 * get_local_size();\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tpartBase = get_global_index() * partSize;\t\t\t\\\n"
  "\t\tcl_uint\t\tblockSize = partSize;\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tunitSize;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\ti;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* Load index to localIdx[] */\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tlocalLimit = (partBase + partSize <= valid_nrows\t\t\t\t\\\n"
  "\t\t\t\t\t  ? partSize\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t  : valid_nrows - partBase);\t\t\t\t\t\t\\\n"
  "\t\tfor (i = get_local_id();\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i < localLimit;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i += get_local_size())\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tlocalIdx[i] = row_index[partBase + i];\t\t\t\t\t\t\\\n"
  "\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* merge two sorted blocks */\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tfor (unitSize = blockSize; unitSize >= 2; unitSize >>= 1)\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tcl_uint\t\thalfUnitSize = (unitSize >> 1);\t\t\t\t\t\\\n"
  "\t\t\tcl_uint\t\thalfUnitMask = (halfUnitSize - 1);\t\t\t\t\\\n"
  "\t\t\tcl_uint\t\tidx0, idx1;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tidx0 = (((get_local_id() & ~halfUnitMask) << 1)\t\t\t\t\\\n"
  "\t\t\t\t\t+ (get_local_id() & halfUnitMask));\t\t\t\t\t\\\n"
  "\t\t\tidx1 = halfUnitSize + idx0;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (idx1 < localLimit)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tcl_uint\t\tpos0 = localIdx[idx0];\t\t\t\t\t\t\\\n"
  "\t\t\t\tcl_uint\t\tpos1 = localIdx[idx1];\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (matrix_sort_keycomp_##SUFFIX(data_ptr,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t height,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t width,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t sortkeys,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t num_keys,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t pos0,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t pos1) == direction)\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t/* swap */\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tlocalIdx[idx0] = pos1;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tlocalIdx[idx1] = pos0;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* update the row_index[] */\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tfor (i = get_local_id();\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i < localLimit;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t i += get_local_size())\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\trow_index[partBase + i] = localIdx[i];\t\t\t\t\t\t\\\n"
  "\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define PGSTROM_MATRIX_SORT_TEMPLATE(SUFFIX,BASETYPE,PG_TYPEOID)\t\t\\\n"
  "\tPGSTROM_MATRIX_SORT_KEYCOMP_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\t\\\n"
  "\tPGSTROM_MATRIX_SORT_LOCAL_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\t\t\\\n"
  "\tPGSTROM_MATRIX_SORT_STEP_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\t\t\\\n"
  "\tPGSTROM_MATRIX_SORT_MERGE_TEMPLATE(SUFFIX,BASETYPE)\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_FUNCTION(cudaError_t)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tpgstromMatrixPartialSort##SUFFIX(cl_uint     *row_index,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t MatrixType  *matrix,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t cl_uint      valid_nrows,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t cl_uint     *sort_keys,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t cl_uint      num_keys,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t cl_bool      is_descending)\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\theight = ARRAY_MATRIX_HEIGHT(matrix);\t\t\t\t\\\n"
  "\t\tcl_uint\t\twidth = ARRAY_MATRIX_WIDTH(matrix);\t\t\t\t\t\\\n"
  "\t\tdim3\t\tgrid_sz;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tdim3\t\tblock_sz;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tmin_block_sz = UINT_MAX;\t\t\t\t\t\t\t\\\n"
  "\t\tkern_arg_t\tkern_argbuf[8];\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tkern_arg_t *__kern_args;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tvoid\t   *kern_funcs[3];\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t   *__sort_keys;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\ti, j, nhalf;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcudaError_t\tstatus = cudaSuccess;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* sanity checks */\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (ARRAY_MATRIX_ELEMTYPE(matrix) != (PG_TYPEOID))\t\t\t\t\\\n"
  "\t\t\treturn cudaErrorInvalidValue;\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (num_keys == 0)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\treturn cudaErrorInvalidValue;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* setup common kernel arguments */\t\t\t\t\t\t\t\t\\\n"
  "\t\t__sort_keys = (cl_uint *)malloc(sizeof(cl_uint) * num_keys);\t\\\n"
  "\t\tif (!__sort_keys)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\treturn cudaErrorMemoryAllocation;\t\t\t\t\t\t\t\\\n"
  "\t\tmemcpy(__sort_keys, sort_keys, sizeof(cl_uint) * num_keys);\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tkern_argbuf[0] = (kern_arg_t)(row_index);\t\t\t\t\t\t\\\n"
  "\t\tkern_argbuf[1] = (kern_arg_t)ARRAY_MATRIX_DATAPTR(matrix);\t\t\\\n"
  "\t\tkern_argbuf[2] = (kern_arg_t)(height);\t\t\t\t\t\t\t\\\n"
  "\t\tkern_argbuf[3] = (kern_arg_t)(width);\t\t\t\t\t\t\t\\\n"
  "\t\tkern_argbuf[4] = (kern_arg_t)(valid_nrows);\t\t\t\t\t\t\\\n"
  "\t\tkern_argbuf[5] = (kern_arg_t)(__sort_keys);\t\t\t\t\t\t\\\n"
  "\t\tkern_argbuf[6] = (kern_arg_t)(num_keys);\t\t\t\t\t\t\\\n"
  "\t\tkern_argbuf[7] = (kern_arg_t)(is_descending ? -1 : 1);\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t * Ensure max available block size for each kernel functions.\t\\\n"
  "\t\t * These are declared with KERNEL_FUNCTION_MAXTHREADS, we\t\t\\\n"
  "\t\t * expect largest workgroup size is equivalent to H/W limit.\t\\\n"
  "\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tkern_funcs[0] = (void *)matrix_sort_local_##SUFFIX;\t\t\t\t\\\n"
  "\t\tkern_funcs[1] = (void *)matrix_sort_step_##SUFFIX;\t\t\t\t\\\n"
  "\t\tkern_funcs[2] = (void *)matrix_sort_merge_##SUFFIX;\t\t\t\t\\\n"
  "\t\tfor (i=0; i < 3; i++)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tstatus = largest_workgroup_size(&grid_sz,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t&block_sz,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\tkern_funcs[i],\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t(valid_nrows + 1) / 2,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t0, 2 * sizeof(cl_uint));\t\\\n"
  "\t\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tmin_block_sz = Min(min_block_sz, block_sz.x);\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* block size to be 2^N */\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tblock_sz.x = (1 << (get_next_log2(min_block_sz + 1) - 1));\t\t\\\n"
  "\t\tblock_sz.y = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tblock_sz.z = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* nhalf is the least power of two value that is larger than\t\\\n"
  "\t\t * or equal to half of the nitems. */\t\t\t\t\t\t\t\\\n"
  "\t\tnhalf = 1UL << (get_next_log2(height + 1) - 1);\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t * KERNEL_FUNCTION_MAXTHREADS(void)\t\t\t\t\t\t\t\t\\\n"
  "\t\t * pgstrom_bitonic_local_#SUFFIX(...)\t\t\t\t\t\t\t\\\n"
  "\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t__kern_args = (kern_arg_t *)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tcudaGetParameterBuffer(sizeof(kern_arg_t),\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t   sizeof(kern_arg_t) * 8);\t\t\t\t\\\n"
  "\t\tif (!__kern_args)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tstatus = cudaErrorLaunchOutOfResources;\t\t\t\t\t\t\\\n"
  "\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tmemcpy(__kern_args, kern_argbuf, sizeof(kern_argbuf));\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tgrid_sz.x = ((valid_nrows + 1) / 2 +\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t block_sz.x - 1) / block_sz.x;\t\t\t\t\t\t\\\n"
  "\t\tgrid_sz.y = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tgrid_sz.z = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tstatus = cudaLaunchDevice((void *)matrix_sort_local_##SUFFIX,\t\\\n"
  "\t\t\t\t\t\t\t\t  __kern_args, grid_sz, block_sz,\t\t\\\n"
  "\t\t\t\t\t\t\t\t  2 * sizeof(cl_uint) * block_sz.x,\t\t\\\n"
  "\t\t\t\t\t\t\t\t  NULL);\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tstatus = cudaDeviceSynchronize();\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* inter blocks bitonic sorting */\t\t\t\t\t\t\t\t\\\n"
  "\t\tfor (i = block_sz.x; i < nhalf; i *= 2)\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tfor (j = 2 * i; j > block_sz.x; j /= 2)\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tcl_uint\t\tunitSize = 2 * j;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tcl_uint\t\tworkSize;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * KERNEL_FUNCTION_MAXTHREADS(void)\t\t\t\t\t\t\\\n"
  "\t\t\t\t * pgstrom_bitonic_step_#SUFFIX(...)\t\t\t\t\t\\\n"
  "\t\t\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t__kern_args = (kern_arg_t *)\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tcudaGetParameterBuffer(sizeof(kern_arg_t),\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t   sizeof(kern_arg_t) * 10);\t\\\n"
  "\t\t\t\tif (!__kern_args)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tstatus = cudaErrorLaunchOutOfResources;\t\t\t\t\\\n"
  "\t\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tmemcpy(__kern_args, kern_argbuf, sizeof(kern_argbuf));\t\\\n"
  "\t\t\t\t__kern_args[8] = (kern_arg_t)(unitSize);\t\t\t\t\\\n"
  "\t\t\t\t__kern_args[9] = (kern_arg_t)(j == 2 * i ? true : false); \\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tworkSize = (((valid_nrows + unitSize - 1)\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t / unitSize) * unitSize / 2);\t\t\t\t\\\n"
  "\t\t\t\tgrid_sz.x = (workSize + block_sz.x - 1) / block_sz.x;\t\\\n"
  "\t\t\t\tgrid_sz.y = 1;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tgrid_sz.z = 1;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tstatus = cudaLaunchDevice(\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t(void *)matrix_sort_step_##SUFFIX,\t\t\t\t\t\\\n"
  "\t\t\t\t\t__kern_args, grid_sz, block_sz,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t0,\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tNULL);\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tstatus = cudaDeviceSynchronize();\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t * Launch: pgstrom_bitonic_merge_SUFFIX\t\t\t\t\t\t\\\n"
  "\t\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__kern_args = (kern_arg_t *)\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tcudaGetParameterBuffer(sizeof(kern_arg_t),\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t   sizeof(kern_arg_t) * 8);\t\t\t\\\n"
  "\t\t\tif (!__kern_args)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tstatus = cudaErrorLaunchOutOfResources;\t\t\t\t\t\\\n"
  "\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tmemcpy(__kern_args, kern_argbuf, sizeof(kern_argbuf));\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tgrid_sz.x = ((valid_nrows + 1) / 2 +\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t block_sz.x - 1) / block_sz.x;\t\t\t\t\t\\\n"
  "\t\t\tgrid_sz.y = 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tgrid_sz.z = 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tstatus = cudaLaunchDevice((void *)matrix_sort_merge_##SUFFIX, \\\n"
  "\t\t\t\t\t\t\t\t\t  __kern_args, grid_sz, block_sz,\t\\\n"
  "\t\t\t\t\t\t\t\t\t  2 * sizeof(cl_uint) * block_sz.x,\t\\\n"
  "\t\t\t\t\t\t\t\t\t  NULL);\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tstatus = cudaDeviceSynchronize();\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tout:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tfree(__sort_keys);\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn status;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_INLINE(cudaError_t)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tpgstromMatrixSort##SUFFIX(cl_uint\t   *row_index,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  MatrixType   *matrix,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  cl_uint\t   *sort_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  cl_uint\t\tnum_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t  cl_bool\t\tis_descending)\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn pgstromMatrixPartialSort##SUFFIX(row_index,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\tmatrix,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\tARRAY_MATRIX_HEIGHT(matrix), \\\n"
  "\t\t\t\t\t\t\t\t\t\t\tsort_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\tnum_keys,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\tis_descending);\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "PGSTROM_MATRIX_SORT_TEMPLATE(FP32,cl_float,PG_FLOAT4OID)\n"
  "PGSTROM_MATRIX_SORT_TEMPLATE(FP64,cl_double, PG_FLOAT8OID)\n"
  "\n"
  "/* ----------------------------------------------------------------\n"
  " *\n"
  " * Group-by Support for PL/CUDA functions\n"
  " *\n"
  " * pgstromMatrixGroupAdd(FP32|FP64)(MatrixType *dst_matrix,\n"
  " *                                  MatrixType *src_matrix,\n"
  " *                                  cl_uint    *group_keys);\n"
  " * pgstromMatrixGroupMax(FP32|FP64)(...)\n"
  " * pgstromMatrixGroupMin(FP32|FP64)(...)\n"
  " *\n"
  " * These service routines support to make a summary according to the\n"
  " * grouping keys. Unlike SQL cases, grouping keys have to be integer\n"
  " * value between 0 and ARRAY_MATRIX_HEIGHT(dst_matrix) - 1.\n"
  " * The 'dst_matrix' has to be K rows x M columns matrix, the 'src_matrix'\n"
  " * has to be N rows x M columns matrix, and 'group_keys' have to be\n"
  " * an unsigned integer array with N-length that indicates the group of\n"
  " * individual rows of 'src_matrix'.\n"
  " * Each column of the 'dst_matrix' shall be added or updated on the row\n"
  " * indicated by the group_keys[].\n"
  " * We have two reduction mode: local and global. In case when large N\n"
  " * is mapped to small K, local reduction works well, then global reduction\n"
  " * will make the final results with less atomic confliction.\n"
  " * If 'K' is larger than 512, we try to update the 'dst_matrix' using atomic\n"
  " * operation directly, with no local reduction. It is heuristically better\n"
  " * choice than two step approach.\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "typedef struct\n"
  "{\n"
  "\tcl_uint\t\t\terrcode;\n"
  "} matrixGroupState;\n"
  "\n"
  "#define PGSTROM_MATRIX_GROUPBY_TEMPLATE(OP_NAME,SUFFIX,BASETYPE,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\tATOMIC_OPS,INIT_VAL)\t\t\t\\\n"
  "\tKERNEL_FUNCTION_MAXTHREADS(void)\t\t\t\t\t\t\t\t\t\\\n"
  "\tmatrixGroup##OP_NAME##Twophase##SUFFIX(matrixGroupState *state,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t   MatrixType  *dst_matrix,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t   MatrixType  *src_matrix,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t   cl_uint\t  *group_keys)\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\twidth = ARRAY_MATRIX_WIDTH(src_matrix);\t\t\t\t\\\n"
  "\t\tBASETYPE   *src_addr;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tBASETYPE   *dst_addr;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tBASETYPE   *l_values;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t   *l_counts;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tdst_index;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\ti, j, k, n;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_bool\t\tis_owner = false;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tk = ARRAY_MATRIX_HEIGHT(dst_matrix);\t\t\t\t\t\t\t\\\n"
  "\t\tn = ARRAY_MATRIX_HEIGHT(src_matrix);\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* determine who is the owner of key */\t\t\t\t\t\t\t\\\n"
  "\t\tl_counts = SHARED_WORKMEM(cl_uint);\t\t\t\t\t\t\t\t\\\n"
  "\t\tfor (i = get_local_id(); i < k; i++)\t\t\t\t\t\t\t\\\n"
  "\t\t\tl_counts[i] = 0;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (get_global_id() < n)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tdst_index = group_keys[get_global_id()];\t\t\t\t\t\\\n"
  "\t\t\tif (dst_index < k)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (atomicAdd(&l_counts[dst_index], 1) == 0)\t\t\t\\\n"
  "\t\t\t\t\tis_owner = true;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/* invalid grouping key */\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tatomicCAS(&state->errcode,\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  StromError_Success,\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  StromError_InvalidValue);\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tdst_index = (cl_uint)(-1U);\t/* for compiler quiet */\t\t\\\n"
  "\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tsrc_addr = (BASETYPE *)ARRAY_MATRIX_DATAPTR(src_matrix);\t\t\\\n"
  "\t\tdst_addr = (BASETYPE *)ARRAY_MATRIX_DATAPTR(dst_matrix);\t\t\\\n"
  "\t\tfor (i=0; i < width; i++)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t/* clear the local summary buffer */\t\t\t\t\t\t\\\n"
  "\t\t\tl_values = SHARED_WORKMEM(BASETYPE);\t\t\t\t\t\t\\\n"
  "\t\t\tfor (j = get_local_id(); j < k; j += get_local_size())\t\t\\\n"
  "\t\t\t\tl_values[j] = (INIT_VAL);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t/* make a local summary of this column */\t\t\t\t\t\\\n"
  "\t\t\tif (get_global_id() < n && dst_index < k)\t\t\t\t\t\\\n"
  "\t\t\t\tATOMIC_OPS(&l_values[dst_index],\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t   src_addr[get_global_id()]);\t\t\t\t\t\\\n"
  "\t\t\t__syncthreads();\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t/* put this local summary to the dst_matrix */\t\t\t\t\\\n"
  "\t\t\tif (is_owner)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tassert(dst_index < k);\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tATOMIC_OPS(&dst_addr[dst_index],\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t   l_values[dst_index]);\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tsrc_addr += n;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tdst_addr += k;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tKERNEL_FUNCTION(void)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tmatrixGroup##OP_NAME##Direct##SUFFIX(matrixGroupState *state,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t MatrixType *dst_matrix,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t MatrixType *src_matrix,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t cl_uint    *group_keys)\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\twidth = ARRAY_MATRIX_WIDTH(src_matrix);\t\t\t\t\\\n"
  "\t\tBASETYPE   *src_addr;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tBASETYPE   *dst_addr;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tdst_index;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\ti, k, n;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tk = ARRAY_MATRIX_HEIGHT(dst_matrix);\t\t\t\t\t\t\t\\\n"
  "\t\tn = ARRAY_MATRIX_HEIGHT(src_matrix);\t\t\t\t\t\t\t\\\n"
  "\t\tif (get_global_id() < n)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tdst_index = group_keys[get_global_id()];\t\t\t\t\t\\\n"
  "\t\t\tif (dst_index >= k)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tatomicCAS(&state->errcode,\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  StromError_Success,\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  StromError_InvalidValue);\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tdst_index = (cl_uint)(0xffffffff);\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tsrc_addr = (BASETYPE *)ARRAY_MATRIX_DATAPTR(src_matrix);\t\t\\\n"
  "\t\tdst_addr = (BASETYPE *)ARRAY_MATRIX_DATAPTR(dst_matrix);\t\t\\\n"
  "\t\tfor (i=0; i < width; i++)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (dst_index < k && get_global_id() < n)\t\t\t\t\t\\\n"
  "\t\t\t\tATOMIC_OPS(&dst_addr[dst_index],\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t   src_addr[get_global_id()]);\t\t\t\t\t\\\n"
  "\t\t\tsrc_addr += n;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tdst_addr += k;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_FUNCTION(cudaError_t)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tpgstromMatrixGroup##OP_NAME##SUFFIX(MatrixType *dst_matrix,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\tMatrixType *src_matrix,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\tcl_uint\t   *group_keys)\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tmatrixGroupState *state;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\tk, n;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tvoid\t   *kern_func;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcudaError_t\tstatus;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* sanity checks */\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tassert(ARRAY_MATRIX_ELEMTYPE(src_matrix) == PG_FLOAT4OID);\t\t\\\n"
  "\t\tassert(ARRAY_MATRIX_ELEMTYPE(dst_matrix) == PG_FLOAT4OID);\t\t\\\n"
  "\t\tassert(ARRAY_MATRIX_WIDTH(src_matrix) ==\t\t\t\t\t\t\\\n"
  "\t\t\t   ARRAY_MATRIX_WIDTH(dst_matrix));\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tstate = (matrixGroupState *)malloc(sizeof(matrixGroupState));\t\\\n"
  "\t\tif (!state)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\treturn cudaErrorMemoryAllocation;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tstate->errcode = StromError_Success;\t\t\t\t\t\t\t\\\n"
  "\t\tn = ARRAY_MATRIX_HEIGHT(src_matrix);\t\t\t\t\t\t\t\\\n"
  "\t\tk = ARRAY_MATRIX_HEIGHT(dst_matrix);\t\t\t\t\t\t\t\\\n"
  "\t\tif (k > 512)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tkern_func = (void *)matrixGroup##OP_NAME##Direct##SUFFIX;\t\\\n"
  "\t\t\tstatus = pgstromLaunchDynamicKernel4(kern_func,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(state),\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(dst_matrix), \\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(src_matrix), \\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(group_keys), \\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t n,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t 0,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t 0);\t\t\t\t\t\\\n"
  "\t\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tkern_func = (void *)matrixGroup##OP_NAME##Twophase##SUFFIX;\t\\\n"
  "\t\t\tstatus = pgstromLaunchDynamicKernel4(kern_func,\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(state),\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(dst_matrix), \\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(src_matrix), \\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t (kern_arg_t)(group_keys), \\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t n,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t 0,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t 0);\t\t\t\t\t\\\n"
  "\t\t\tif (status != cudaSuccess)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tgoto out;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (state->errcode)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tstatus = cudaErrorInvalidValue;\t\t\t\t\t\t\t\t\\\n"
  "\tout:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tfree(state);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn status;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "PGSTROM_MATRIX_GROUPBY_TEMPLATE(Add,FP32,cl_float,atomicAdd,0.0)\n"
  "//PGSTROM_MATRIX_GROUPBY_TEMPLATE(Max,FP32,cl_float,atomicMax,-FLT_MAX)\n"
  "//PGSTROM_MATRIX_GROUPBY_TEMPLATE(Min,FP32,cl_float,atomicMin, FLT_MAX)\n"
  "\n"
  "\n"
  "#endif\t/* __CUDACC__ */\n"
  "#endif\t/* CUDA_MATRIX_H */\n"
;
