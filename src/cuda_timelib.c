const char *pgstrom_cuda_timelib_code =
  "/*\n"
  " * cuda_timelib.h\n"
  " *\n"
  " * Collection of date/time functions for OpenCL devices\n"
  " * --\n"
  " * Copyright 2011-2016 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014-2016 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef CUDA_TIMELIB_H\n"
  "#define CUDA_TIMELIB_H\n"
  "\n"
  "#ifdef __CUDACC__\n"
  "\n"
  "/* definitions copied from date.h */\n"
  "typedef cl_int\t\tDateADT;\n"
  "typedef cl_long\t\tTimeADT;\n"
  "typedef struct\n"
  "{\n"
  "\tTimeADT\t\t\ttime;\t/* all time units other than months and years */\n"
  "\tcl_int\t\t\tzone;\t/* numeric time zone, in seconds */\n"
  "} TimeTzADT;\n"
  "typedef cl_long\t\tTimeOffset;\n"
  "\n"
  "#define MAX_TIME_PRECISION\t6\n"
  "\n"
  "#define DATEVAL_NOBEGIN\t\t((cl_int)(-0x7fffffff - 1))\n"
  "#define DATEVAL_NOEND\t\t((cl_int)  0x7fffffff)\n"
  "\n"
  "#define DATE_NOBEGIN(j)\t\t((j) = DATEVAL_NOBEGIN)\n"
  "#define DATE_IS_NOBEGIN(j)\t((j) == DATEVAL_NOBEGIN)\n"
  "#define DATE_NOEND(j)\t\t((j) = DATEVAL_NOEND)\n"
  "#define DATE_IS_NOEND(j)\t((j) == DATEVAL_NOEND)\n"
  "#define DATE_NOT_FINITE(j)\t(DATE_IS_NOBEGIN(j) || DATE_IS_NOEND(j))\n"
  "/* definitions copied from timestamp.h */\n"
  "typedef cl_long\tTimestamp;\n"
  "typedef cl_long\tTimestampTz;\n"
  "typedef cl_long\tTimeOffset;\n"
  "typedef cl_int\tfsec_t;\t\t/* fractional seconds (in microseconds) */\n"
  "typedef struct\n"
  "{\n"
  "\tTimeOffset\ttime;\t/* all time units other than days, months and years */\n"
  "\tcl_int\t\tday;\t/* days, after time for alignment */\n"
  "\tcl_int\t\tmonth;\t/* months and years, after time for alignment */\n"
  "} Interval;\n"
  "\n"
  "#define DAYS_PER_YEAR\t365.25\t/* assumes leap year every four years */\n"
  "#define MONTHS_PER_YEAR\t12\n"
  "#define DAYS_PER_MONTH\t30\t\t/* assumes exactly 30 days per month */\n"
  "#define HOURS_PER_DAY\t24\t\t/* assume no daylight savings time changes */\n"
  "\n"
  "#define SECS_PER_YEAR\t(36525 * 864)   /* avoid floating-point computation */\n"
  "#define SECS_PER_DAY\t86400\n"
  "#define SECS_PER_HOUR\t3600\n"
  "#define SECS_PER_MINUTE\t60\n"
  "#define MINS_PER_HOUR\t60\n"
  "\n"
  "#define USECS_PER_DAY\t\tINT64CONST(86400000000)\n"
  "#define USECS_PER_HOUR\t\tINT64CONST(3600000000)\n"
  "#define USECS_PER_MINUTE\tINT64CONST(60000000)\n"
  "#define USECS_PER_SEC\t\tINT64CONST(1000000)\n"
  "\n"
  "#define DT_NOBEGIN\t\t(-INT64CONST(0x7fffffffffffffff) - 1)\n"
  "#define DT_NOEND\t\t(INT64CONST(0x7fffffffffffffff))\n"
  "\n"
  "/* import from timezone/tzfile.h */\n"
  "#define SECSPERMIN\t\t60\n"
  "#define MINSPERHOUR\t\t60\n"
  "#define HOURSPERDAY\t\t24\n"
  "#define DAYSPERWEEK\t\t7\n"
  "#define DAYSPERNYEAR\t365\n"
  "#define DAYSPERLYEAR\t366\n"
  "#define SECSPERHOUR\t\t(SECSPERMIN * MINSPERHOUR)\n"
  "#define SECSPERDAY\t\t((long) SECSPERHOUR * HOURSPERDAY)\n"
  "#define MONSPERYEAR\t\t12\n"
  "\n"
  "#define TM_SUNDAY\t\t0\n"
  "#define TM_MONDAY\t\t1\n"
  "#define TM_TUESDAY\t\t2\n"
  "#define TM_WEDNESDAY\t3\n"
  "#define TM_THURSDAY\t\t4\n"
  "#define TM_FRIDAY\t\t5\n"
  "#define TM_SATURDAY\t\t6\n"
  "\n"
  "#define TM_JANUARY\t\t0\n"
  "#define TM_FEBRUARY\t\t1\n"
  "#define TM_MARCH\t\t2\n"
  "#define TM_APRIL\t\t3\n"
  "#define TM_MAY\t\t\t4\n"
  "#define TM_JUNE\t\t\t5\n"
  "#define TM_JULY\t\t\t6\n"
  "#define TM_AUGUST\t\t7\n"
  "#define TM_SEPTEMBER\t8\n"
  "#define TM_OCTOBER\t\t9\n"
  "#define TM_NOVEMBER\t\t10\n"
  "#define TM_DECEMBER\t\t11\n"
  "\n"
  "#define TM_YEAR_BASE    1900\n"
  "\n"
  "#define EPOCH_YEAR\t\t1970\n"
  "#define EPOCH_WDAY\t\tTM_THURSDAY\n"
  "\n"
  "#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))\n"
  "\n"
  "/* import from timezone/private.h */\n"
  "#define YEARSPERREPEAT\t400\t\t/* years before a Gregorian repeat */\n"
  "#define AVGSECSPERYEAR\t31556952L\n"
  "\n"
  "/* import from include/datatype/timestamp.h */\n"
  "#define JULIAN_MINYEAR (-4713)\n"
  "#define JULIAN_MINMONTH (11)\n"
  "#define JULIAN_MINDAY (24)\n"
  "#define JULIAN_MAXYEAR (5874898)\n"
  "\n"
  "#define IS_VALID_JULIAN(y,m,d) \\\n"
  "\t(((y) > JULIAN_MINYEAR \\\n"
  "\t  || ((y) == JULIAN_MINYEAR && \\\n"
  "\t\t  ((m) > JULIAN_MINMONTH \\\n"
  "\t\t   || ((m) == JULIAN_MINMONTH && (d) >= JULIAN_MINDAY)))) \\\n"
  "\t && (y) < JULIAN_MAXYEAR)\n"
  "\n"
  "\n"
  "#define TIMESTAMP_NOBEGIN(j) \\\n"
  "\tdo {(j) = DT_NOBEGIN;} while (0)\n"
  "#define TIMESTAMP_IS_NOBEGIN(j) ((j) == DT_NOBEGIN)\n"
  "\n"
  "#define TIMESTAMP_NOEND(j) \\\n"
  "\tdo {(j) = DT_NOEND;} while (0)\n"
  "\n"
  "#define TIMESTAMP_IS_NOEND(j) \\\n"
  "\t((j) == DT_NOEND)\n"
  "\n"
  "#define TIMESTAMP_NOT_FINITE(j) \\\n"
  "\t(TIMESTAMP_IS_NOBEGIN(j) || TIMESTAMP_IS_NOEND(j))\n"
  "\n"
  "/* Julian-date equivalents of Day 0 in Unix and Postgres reckoning */\n"
  "#define UNIX_EPOCH_JDATE\t\t2440588\t/* == date2j(1970, 1, 1) */\n"
  "#define POSTGRES_EPOCH_JDATE\t2451545\t/* == date2j(2000, 1, 1) */\n"
  "\n"
  "#ifndef SAMESIGN\n"
  "#define SAMESIGN(a,b)\t(((a) < 0) == ((b) < 0))\n"
  "#endif\n"
  "\n"
  "/* definition copied from datetime.h */\n"
  "#define TMODULO(t,q,u) \\\n"
  "\tdo {\t\t\t   \\\n"
  "\t\t(q) = ((t) / (u));\t\t\t  \\\n"
  "\t\tif ((q) != 0) (t) -= ((q) * (u));\t\t\\\n"
  "\t} while(0)\n"
  "\n"
  "/* definition copied from datetime.c */\n"
  "static const int day_tab[2][13] =\n"
  "{\n"
  "    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n"
  "    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n"
  "};\n"
  "\n"
  "/* definition copied from pgtime.h */\n"
  "static const int mon_lengths[2][MONSPERYEAR] = {\n"
  "\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n"
  "\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\n"
  "};\n"
  "\n"
  "static const int year_lengths[2] = {\n"
  "\tDAYSPERNYEAR, DAYSPERLYEAR\n"
  "};\n"
  "\n"
  "struct pg_tm\n"
  "{\n"
  "\tcl_int\t\ttm_sec;\n"
  "\tcl_int\t\ttm_min;\n"
  "\tcl_int\t\ttm_hour;\n"
  "\tcl_int\t\ttm_mday;\n"
  "\tcl_int\t\ttm_mon;\t\t/* origin 0, not 1 */\n"
  "\tcl_int\t\ttm_year;\t/* relative to 1900 */\n"
  "\tcl_int\t\ttm_wday;\n"
  "\tcl_int\t\ttm_yday;\n"
  "\tcl_int\t\ttm_isdst;\n"
  "\tcl_long\t\ttm_gmtoff;\n"
  "\t// const char *tm_zone;\tnot supported yet\n"
  "};\n"
  "\n"
  "#ifndef PG_DATE_TYPE_DEFINED\n"
  "#define PG_DATE_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(date,DateADT)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_date_to_datum(DateADT value)\n"
  "{\n"
  "\treturn pg_int4_to_datum(value);\n"
  "}\n"
  "#endif\n"
  "\n"
  "#ifndef PG_TIME_TYPE_DEFINED\n"
  "#define PG_TIME_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(time,TimeADT)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_time_to_datum(TimeADT value)\n"
  "{\n"
  "\treturn pg_int8_to_datum(value);\n"
  "}\n"
  "#endif\n"
  "\n"
  "#ifndef PG_TIMETZ_TYPE_DEFINED\n"
  "#define PG_TIMETZ_TYPE_DEFINED\n"
  "STROMCL_INDIRECT_TYPE_TEMPLATE(timetz,TimeTzADT)\n"
  "#endif\n"
  "\n"
  "#ifndef PG_TIMESTAMP_TYPE_DEFINED\n"
  "#define PG_TIMESTAMP_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(timestamp,Timestamp)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_timestamp_to_datum(Timestamp value)\n"
  "{\n"
  "\treturn pg_int8_to_datum(value);\n"
  "}\n"
  "#endif\n"
  "\n"
  "#ifndef PG_TIMESTAMPTZ_TYPE_DEFINED\n"
  "#define PG_TIMESTAMPTZ_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(timestamptz,TimestampTz)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_timestamptz_to_datum(TimestampTz value)\n"
  "{\n"
  "\treturn pg_int8_to_datum(value);\n"
  "}\n"
  "#endif\n"
  "\n"
  "#ifndef PG_INTERVAL_TYPE_DEFINED\n"
  "#define PG_INTERVAL_TYPE_DEFINED\n"
  "STROMCL_INDIRECT_TYPE_TEMPLATE(interval,Interval)\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * Support routines\n"
  " */\n"
  "STATIC_INLINE(cl_int)\n"
  "date2j(cl_int y, cl_int m, cl_int d)\n"
  "{\n"
  "\tint\t\tjulian;\n"
  "\tint\t\tcentury;\n"
  "\n"
  "\tif (m > 2)\n"
  "\t{\n"
  "\t\tm += 1;\n"
  "\t\ty += 4800;\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tm += 13;\n"
  "\t\ty += 4799;\n"
  "\t}\n"
  "\n"
  "\tcentury = y / 100;\n"
  "\tjulian = y * 365 - 32167;\n"
  "\tjulian += y / 4 - century + century / 4;\n"
  "\tjulian += 7834 * m / 256 + d;\n"
  "\n"
  "\treturn julian;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(void)\n"
  "j2date(cl_int jd, int *year, int *month, int *day)\n"
  "{\n"
  "\tcl_uint\t\tjulian;\n"
  "\tcl_uint\t\tquad;\n"
  "\tcl_uint\t\textra;\n"
  "\tcl_int\t\ty;\n"
  "\n"
  "\tjulian = jd;\n"
  "\tjulian += 32044;\n"
  "\tquad = julian / 146097;\n"
  "\textra = (julian - quad * 146097) * 4 + 3;\n"
  "\tjulian += 60 + quad * 3 + extra / 146097;\n"
  "\tquad = julian / 1461;\n"
  "\tjulian -= quad * 1461;\n"
  "\ty = julian * 4 / 1461;\n"
  "\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n"
  "\t\t+ 123;\n"
  "\ty += quad * 4;\n"
  "\t*year = y - 4800;\n"
  "\tquad = julian * 2141 / 65536;\n"
  "\t*day = julian - 7834 * quad / 256;\n"
  "\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(void)\n"
  "dt2time(Timestamp jd, cl_int *hour, cl_int *min, cl_int *sec, cl_int *fsec)\n"
  "{\n"
  "\tTimeOffset  time;\n"
  "\n"
  "\ttime = jd;\n"
  "\n"
  "\t*hour = time / USECS_PER_HOUR;\n"
  "\ttime -= (*hour) * USECS_PER_HOUR;\n"
  "\t*min = time / USECS_PER_MINUTE;\n"
  "\ttime -= (*min) * USECS_PER_MINUTE;\n"
  "\t*sec = time / USECS_PER_SEC;\n"
  "\t*fsec = time - (*sec * USECS_PER_SEC);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(Timestamp)\n"
  "dt2local(Timestamp dt, int tz)\n"
  "{\n"
  "    return dt -= (tz * USECS_PER_SEC);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(TimeOffset)\n"
  "time2t(const int hour, const int min, const int sec, const fsec_t fsec)\n"
  "{\n"
  "    return (((((hour * MINS_PER_HOUR) + min) * SECS_PER_MINUTE) + sec) *\n"
  "\t\t\tUSECS_PER_SEC) + fsec;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(int)\n"
  "time2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n"
  "{\n"
  "    tm->tm_hour = time / USECS_PER_HOUR;\n"
  "    time -= tm->tm_hour * USECS_PER_HOUR;\n"
  "    tm->tm_min = time / USECS_PER_MINUTE;\n"
  "    time -= tm->tm_min * USECS_PER_MINUTE;\n"
  "    tm->tm_sec = time / USECS_PER_SEC;\n"
  "    time -= tm->tm_sec * USECS_PER_SEC;\n"
  "    *fsec = time;\n"
  "\n"
  "\treturn 0;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(int)\n"
  "tm2timetz(struct pg_tm * tm, fsec_t fsec, int tz, TimeTzADT *result)\n"
  "{\n"
  "    result->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) \n"
  "\t\t\t\t\t  * SECS_PER_MINUTE) + tm->tm_sec) * USECS_PER_SEC) + fsec;\n"
  "    result->zone = tz;\n"
  "\n"
  "\treturn 0;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(int)\n"
  "increment_overflow(int *number, int delta)\n"
  "{\n"
  "    int         number0;\n"
  "\n"
  "    number0 = *number;\n"
  "    *number += delta;\n"
  "    return (*number < number0) != (delta < 0);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(int)\n"
  "leaps_thru_end_of_no_recursive(const int y)\n"
  "{\n"
  "\tassert(y >= 0);\n"
  "\treturn y / 4 - y / 100 + y / 400;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(int)\n"
  "leaps_thru_end_of(const int y)\n"
  "{\n"
  "    return (y >= 0) ? (y / 4 - y / 100 + y / 400) :\n"
  "        -(leaps_thru_end_of_no_recursive(-(y + 1)) + 1);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(struct pg_tm *)\n"
  "timesub(const cl_long *timep,\t/* pg_time_t in original */\n"
  "\t\tlong offset, const tz_state * sp, struct pg_tm * tmp)\n"
  "{\n"
  "\tconst tz_lsinfo *lp;\n"
  "\tcl_long\t\ttdays;\t\t\t/* pg_time_t in original */\n"
  "\tint\t\t\tidays;\t\t\t/* unsigned would be so 2003 */\n"
  "\tlong\t\trem;\n"
  "\tint\t\t\ty;\n"
  "\tconst int  *ip;\n"
  "\tlong\t\tcorr;\n"
  "\tint\t\t\thit;\n"
  "\tint\t\t\ti;\n"
  "\n"
  "\tcorr = 0;\n"
  "\thit = 0;\n"
  "\ti = sp->leapcnt;\n"
  "\twhile (--i >= 0)\n"
  "\t{\n"
  "\t\tlp = &sp->lsis[i];\n"
  "\t\tif (*timep >= lp->ls_trans)\n"
  "\t\t{\n"
  "\t\t\tif (*timep == lp->ls_trans)\n"
  "\t\t\t{\n"
  "\t\t\t\thit = ((i == 0 && lp->ls_corr > 0) ||\n"
  "\t\t\t\t\t   lp->ls_corr > sp->lsis[i - 1].ls_corr);\n"
  "\t\t\t\tif (hit)\n"
  "\t\t\t\t\twhile (i > 0 &&\n"
  "\t\t\t\t\t\t   sp->lsis[i].ls_trans ==\n"
  "\t\t\t\t\t\t   sp->lsis[i - 1].ls_trans + 1 &&\n"
  "\t\t\t\t\t\t   sp->lsis[i].ls_corr ==\n"
  "\t\t\t\t\t\t   sp->lsis[i - 1].ls_corr + 1)\n"
  "\t\t\t\t\t{\n"
  "\t\t\t\t\t\t++hit;\n"
  "\t\t\t\t\t\t--i;\n"
  "\t\t\t\t\t}\n"
  "\t\t\t}\n"
  "\t\t\tcorr = lp->ls_corr;\n"
  "\t\t\tbreak;\n"
  "\t\t}\n"
  "\t}\n"
  "\ty = EPOCH_YEAR;\n"
  "\ttdays = *timep / SECSPERDAY;\n"
  "\trem = *timep - tdays * SECSPERDAY;\n"
  "\twhile (tdays < 0 || tdays >= year_lengths[isleap(y)])\n"
  "\t{\n"
  "\t\tint\t\t\tnewy;\n"
  "\t\tcl_long\t\ttdelta;\t\t/* pg_time_t in original */\n"
  "\t\tint\t\t\tidelta;\n"
  "\t\tint\t\t\tleapdays;\n"
  "\n"
  "\t\ttdelta = tdays / DAYSPERLYEAR;\n"
  "\t\tidelta = tdelta;\n"
  "\t\tif (tdelta - idelta >= 1 || idelta - tdelta >= 1)\n"
  "\t\t\treturn NULL;\n"
  "\t\tif (idelta == 0)\n"
  "\t\t\tidelta = (tdays < 0) ? -1 : 1;\n"
  "\t\tnewy = y;\n"
  "\t\tif (increment_overflow(&newy, idelta))\n"
  "\t\t\treturn NULL;\n"
  "\t\tleapdays = leaps_thru_end_of(newy - 1) -\n"
  "\t\t\tleaps_thru_end_of(y - 1);\n"
  "\t\ttdays -= ((cl_long) newy - y) * DAYSPERNYEAR;\n"
  "\t\ttdays -= leapdays;\n"
  "\t\ty = newy;\n"
  "\t}\n"
  "\t{\n"
  "\t\tlong\t\tseconds;\n"
  "\n"
  "\t\tseconds = tdays * SECSPERDAY + 0.5;\n"
  "\t\ttdays = seconds / SECSPERDAY;\n"
  "\t\trem += seconds - tdays * SECSPERDAY;\n"
  "\t}\n"
  "\n"
  "\t/*\n"
  "\t * Given the range, we can now fearlessly cast...\n"
  "\t */\n"
  "\tidays = tdays;\n"
  "\trem += offset - corr;\n"
  "\twhile (rem < 0)\n"
  "\t{\n"
  "\t\trem += SECSPERDAY;\n"
  "\t\t--idays;\n"
  "\t}\n"
  "\twhile (rem >= SECSPERDAY)\n"
  "\t{\n"
  "\t\trem -= SECSPERDAY;\n"
  "\t\t++idays;\n"
  "\t}\n"
  "\twhile (idays < 0)\n"
  "\t{\n"
  "\t\tif (increment_overflow(&y, -1))\n"
  "\t\t\treturn NULL;\n"
  "\t\tidays += year_lengths[isleap(y)];\n"
  "\t}\n"
  "\twhile (idays >= year_lengths[isleap(y)])\n"
  "\t{\n"
  "\t\tidays -= year_lengths[isleap(y)];\n"
  "\t\tif (increment_overflow(&y, 1))\n"
  "\t\t\treturn NULL;\n"
  "\t}\n"
  "\ttmp->tm_year = y;\n"
  "\tif (increment_overflow(&tmp->tm_year, -TM_YEAR_BASE))\n"
  "\t\treturn NULL;\n"
  "\ttmp->tm_yday = idays;\n"
  "\n"
  "\t/*\n"
  "\t * The \"extra\" mods below avoid overflow problems.\n"
  "\t */\n"
  "\ttmp->tm_wday = EPOCH_WDAY +\n"
  "\t\t((y - EPOCH_YEAR) % DAYSPERWEEK) *\n"
  "\t\t(DAYSPERNYEAR % DAYSPERWEEK) +\n"
  "\t\tleaps_thru_end_of(y - 1) -\n"
  "\t\tleaps_thru_end_of(EPOCH_YEAR - 1) +\n"
  "\t\tidays;\n"
  "\ttmp->tm_wday %= DAYSPERWEEK;\n"
  "\tif (tmp->tm_wday < 0)\n"
  "\t\ttmp->tm_wday += DAYSPERWEEK;\n"
  "\ttmp->tm_hour = (int) (rem / SECSPERHOUR);\n"
  "\trem %= SECSPERHOUR;\n"
  "\ttmp->tm_min = (int) (rem / SECSPERMIN);\n"
  "\n"
  "\t/*\n"
  "\t * A positive leap second requires a special representation. This uses\n"
  "\t * \"... ??:59:60\" et seq.\n"
  "\t */\n"
  "\ttmp->tm_sec = (int) (rem % SECSPERMIN) + hit;\n"
  "\tip = mon_lengths[isleap(y)];\n"
  "\tfor (tmp->tm_mon = 0; idays >= ip[tmp->tm_mon]; ++(tmp->tm_mon))\n"
  "\t\tidays -= ip[tmp->tm_mon];\n"
  "\ttmp->tm_mday = (int) (idays + 1);\n"
  "\ttmp->tm_isdst = 0;\n"
  "\ttmp->tm_gmtoff = offset;\n"
  "\treturn tmp;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(struct pg_tm *)\n"
  "localsub_no_recursive(const cl_long *timep,\t/* pg_time_t in original */\n"
  "\t\t\t\t\t  long offset,\n"
  "\t\t\t\t\t  struct pg_tm * tmp,\n"
  "\t\t\t\t\t  const tz_state *sp)\t/* const pg_tz *tz in original */\n"
  "{\n"
  "\tconst tz_ttinfo *ttisp;\n"
  "\tint\t\t\ti;\n"
  "\tstruct pg_tm *result;\n"
  "\tconst cl_long t = *timep;\t/* pg_time_t in original */\n"
  "\n"
  "#if 0\n"
  "\tif ((sp->goback && t < sp->ats[0]) ||\n"
  "\t\t(sp->goahead && t > sp->ats[sp->timecnt - 1]))\n"
  "\t{\n"
  "\t\tcl_long\tnewt = t;\t/* pg_time_t in original */\n"
  "\t\tcl_long\tseconds;\t/* pg_time_t in original */\n"
  "\t\tcl_long\ttcycles;\t/* pg_time_t in original */\n"
  "\t\tcl_long\ticycles;\t/* pg_time_t in original */\n"
  "\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tseconds = sp->ats[0] - t;\n"
  "\t\telse\n"
  "\t\t\tseconds = t - sp->ats[sp->timecnt - 1];\n"
  "\t\t--seconds;\n"
  "\t\ttcycles = seconds / YEARSPERREPEAT / AVGSECSPERYEAR;\n"
  "\t\t++tcycles;\n"
  "\t\ticycles = tcycles;\n"
  "\t\tif (tcycles - icycles >= 1 || icycles - tcycles >= 1)\n"
  "\t\t\treturn NULL;\n"
  "\t\tseconds = icycles;\n"
  "\t\tseconds *= YEARSPERREPEAT;\n"
  "\t\tseconds *= AVGSECSPERYEAR;\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tnewt += seconds;\n"
  "\t\telse\n"
  "\t\t\tnewt -= seconds;\n"
  "\t\tif (newt < sp->ats[0] ||\n"
  "\t\t\tnewt > sp->ats[sp->timecnt - 1])\n"
  "\t\t\treturn NULL;\t\t/* \"cannot happen\" */\n"
  "\t\tresult = localsub(&newt, offset, tmp, tz);\n"
  "\t\tif (result == tmp)\n"
  "\t\t{\n"
  "\t\t\tcl_long newy;\t\t/* pg_time_t in original */\n"
  "\n"
  "\t\t\tnewy = tmp->tm_year;\n"
  "\t\t\tif (t < sp->ats[0])\n"
  "\t\t\t\tnewy -= icycles * YEARSPERREPEAT;\n"
  "\t\t\telse\n"
  "\t\t\t\tnewy += icycles * YEARSPERREPEAT;\n"
  "\t\t\ttmp->tm_year = newy;\n"
  "\t\t\tif (tmp->tm_year != newy)\n"
  "\t\t\t\treturn NULL;\n"
  "\t\t}\n"
  "\t\treturn result;\n"
  "\t}\n"
  "#else\n"
  "\t/* Don't recursive call in this function. */\n"
  "\tassert(!((sp->goback && t < sp->ats[0]) ||\n"
  "\t\t\t (sp->goahead && t > sp->ats[sp->timecnt - 1])));\n"
  "#endif\n"
  "\n"
  "\tif (sp->timecnt == 0 || t < sp->ats[0])\n"
  "\t{\n"
  "\t\ti = 0;\n"
  "\t\twhile (sp->ttis[i].tt_isdst)\n"
  "\t\t\tif (++i >= sp->typecnt)\n"
  "\t\t\t{\n"
  "\t\t\t\ti = 0;\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tint\t\t\tlo = 1;\n"
  "\t\tint\t\t\thi = sp->timecnt;\n"
  "\n"
  "\t\twhile (lo < hi)\n"
  "\t\t{\n"
  "\t\t\tint\t\t\tmid = (lo + hi) >> 1;\n"
  "\n"
  "\t\t\tif (t < sp->ats[mid])\n"
  "\t\t\t\thi = mid;\n"
  "\t\t\telse\n"
  "\t\t\t\tlo = mid + 1;\n"
  "\t\t}\n"
  "\t\ti = (int) sp->types[lo - 1];\n"
  "\t}\n"
  "\tttisp = &sp->ttis[i];\n"
  "\n"
  "\tresult = timesub(&t, ttisp->tt_gmtoff, sp, tmp);\n"
  "\ttmp->tm_isdst = ttisp->tt_isdst;\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(struct pg_tm *)\n"
  "localsub(const cl_long *timep, \t/* pg_time_t in original */\n"
  "\t\t long offset,\n"
  "\t\t struct pg_tm * tmp,\n"
  "\t\t const tz_state *sp\t    /* const pg_tz *tz in original*/ )\n"
  "{\n"
  "\tconst tz_ttinfo *ttisp;\n"
  "\tint\t\t\ti;\n"
  "\tstruct pg_tm *result;\n"
  "\tconst cl_long t = *timep;\t/* pg_time_t in original */\n"
  "\n"
  "\tif ((sp->goback && t < sp->ats[0]) ||\n"
  "\t\t(sp->goahead && t > sp->ats[sp->timecnt - 1]))\n"
  "\t{\n"
  "\t\tcl_long\tnewt = t;\t\t/* pg_time_t in original */\n"
  "\t\tcl_long\tseconds;\t\t/* pg_time_t in original */\n"
  "\t\tcl_long\ttcycles;\t\t/* pg_time_t in original */\n"
  "\t\tcl_long\ticycles;\n"
  "\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tseconds = sp->ats[0] - t;\n"
  "\t\telse\n"
  "\t\t\tseconds = t - sp->ats[sp->timecnt - 1];\n"
  "\t\t--seconds;\n"
  "\t\ttcycles = seconds / YEARSPERREPEAT / AVGSECSPERYEAR;\n"
  "\t\t++tcycles;\n"
  "\t\ticycles = tcycles;\n"
  "\t\tif (tcycles - icycles >= 1 || icycles - tcycles >= 1)\n"
  "\t\t\treturn NULL;\n"
  "\t\tseconds = icycles;\n"
  "\t\tseconds *= YEARSPERREPEAT;\n"
  "\t\tseconds *= AVGSECSPERYEAR;\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tnewt += seconds;\n"
  "\t\telse\n"
  "\t\t\tnewt -= seconds;\n"
  "\t\tif (newt < sp->ats[0] ||\n"
  "\t\t\tnewt > sp->ats[sp->timecnt - 1])\n"
  "\t\t\treturn NULL;\t\t/* \"cannot happen\" */\n"
  "\t\tresult = localsub_no_recursive(&newt, offset, tmp, sp);\n"
  "\t\tif (result == tmp)\n"
  "\t\t{\n"
  "\t\t\tcl_long\tnewy;\t\t/* pg_time_t in original */\n"
  "\n"
  "\t\t\tnewy = tmp->tm_year;\n"
  "\t\t\tif (t < sp->ats[0])\n"
  "\t\t\t\tnewy -= icycles * YEARSPERREPEAT;\n"
  "\t\t\telse\n"
  "\t\t\t\tnewy += icycles * YEARSPERREPEAT;\n"
  "\t\t\ttmp->tm_year = newy;\n"
  "\t\t\tif (tmp->tm_year != newy)\n"
  "\t\t\t\treturn NULL;\n"
  "\t\t}\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\tif (sp->timecnt == 0 || t < sp->ats[0])\n"
  "\t{\n"
  "\t\ti = 0;\n"
  "\t\twhile (sp->ttis[i].tt_isdst)\n"
  "\t\t\tif (++i >= sp->typecnt)\n"
  "\t\t\t{\n"
  "\t\t\t\ti = 0;\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tint\t\t\tlo = 1;\n"
  "\t\tint\t\t\thi = sp->timecnt;\n"
  "\n"
  "\t\twhile (lo < hi)\n"
  "\t\t{\n"
  "\t\t\tint\t\t\tmid = (lo + hi) >> 1;\n"
  "\n"
  "\t\t\tif (t < sp->ats[mid])\n"
  "\t\t\t\thi = mid;\n"
  "\t\t\telse\n"
  "\t\t\t\tlo = mid + 1;\n"
  "\t\t}\n"
  "\t\ti = (int) sp->types[lo - 1];\n"
  "\t}\n"
  "\tttisp = &sp->ttis[i];\n"
  "\n"
  "\tresult = timesub(&t, ttisp->tt_gmtoff, sp, tmp);\n"
  "\ttmp->tm_isdst = ttisp->tt_isdst;\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(struct pg_tm *)\n"
  "pg_localtime(const cl_long *timep,\t/* pg_time_t in original */\n"
  "\t\t\t struct pg_tm *tm,\n"
  "\t\t\t const tz_state *sp)\t/* const pg_tz *tz in original */\n"
  "{\n"
  "\t/*\n"
  "\t * pg_localtime() returns tm if success. NULL, elsewhere.\n"
  "\t */\n"
  "\treturn localsub(timep, 0L, tm, sp);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(int)\n"
  "pg_next_dst_boundary_no_recursive(\n"
  "\tconst cl_long *timep,\t\t/* pg_time_t in original */\n"
  "\tlong int *before_gmtoff,\n"
  "\tint *before_isdst,\n"
  "\tcl_long *boundary,\t\t\t/* pg_time_t in original */\n"
  "\tlong int *after_gmtoff,\n"
  "\tint *after_isdst,\n"
  "\tconst tz_state *sp)\t\t\t/* const pg_tz *tz in original */\n"
  "{\n"
  "\tconst tz_ttinfo *ttisp;\n"
  "\tint\t\t\ti;\n"
  "\tint\t\t\tj;\n"
  "\tconst cl_long t = *timep;\t/* pg_time_t in original */\n"
  "\n"
  "\tif (sp->timecnt == 0)\n"
  "\t{\n"
  "\t\t/* non-DST zone, use lowest-numbered standard type */\n"
  "\t\ti = 0;\n"
  "\t\twhile (sp->ttis[i].tt_isdst)\n"
  "\t\t\tif (++i >= sp->typecnt)\n"
  "\t\t\t{\n"
  "\t\t\t\ti = 0;\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*before_isdst = ttisp->tt_isdst;\n"
  "\t\treturn 0;\n"
  "\t}\n"
  "#if 0\n"
  "\tif ((sp->goback && t < sp->ats[0]) ||\n"
  "\t\t(sp->goahead && t > sp->ats[sp->timecnt - 1]))\n"
  "\t{\n"
  "\t\t/* For values outside the transition table, extrapolate */\n"
  "\t\tcl_long\tnewt = t;\t/* pg_time_t in original */\n"
  "\t\tcl_long\tseconds;\t/* pg_time_t in original */\n"
  "\t\tcl_long\ttcycles;\t/* pg_time_t in original */\n"
  "\t\tcl_long\ticycles;\n"
  "\t\tint\t\tresult;\n"
  "\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tseconds = sp->ats[0] - t;\n"
  "\t\telse\n"
  "\t\t\tseconds = t - sp->ats[sp->timecnt - 1];\n"
  "\t\t--seconds;\n"
  "\t\ttcycles = seconds / YEARSPERREPEAT / AVGSECSPERYEAR;\n"
  "\t\t++tcycles;\n"
  "\t\ticycles = tcycles;\n"
  "\t\tif (tcycles - icycles >= 1 || icycles - tcycles >= 1)\n"
  "\t\t\treturn -1;\n"
  "\t\tseconds = icycles;\n"
  "\t\tseconds *= YEARSPERREPEAT;\n"
  "\t\tseconds *= AVGSECSPERYEAR;\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tnewt += seconds;\n"
  "\t\telse\n"
  "\t\t\tnewt -= seconds;\n"
  "\t\tif (newt < sp->ats[0] ||\n"
  "\t\t\tnewt > sp->ats[sp->timecnt - 1])\n"
  "\t\t\treturn -1;\t\t\t/* \"cannot happen\" */\n"
  "\n"
  "\t\tresult = pg_next_dst_boundary(&newt, before_gmtoff,\n"
  "\t\t\t\t\t\t\t\t\t  before_isdst,\n"
  "\t\t\t\t\t\t\t\t\t  boundary,\n"
  "\t\t\t\t\t\t\t\t\t  after_gmtoff,\n"
  "\t\t\t\t\t\t\t\t\t  after_isdst,\n"
  "\t\t\t\t\t\t\t\t\t  tz);\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\t*boundary -= seconds;\n"
  "\t\telse\n"
  "\t\t\t*boundary += seconds;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "#else\n"
  "\t/* Don't recursive call in this function. */\n"
  "\tassert(!((sp->goback && t < sp->ats[0]) ||\n"
  "\t\t\t (sp->goahead && t > sp->ats[sp->timecnt - 1])));\n"
  "#endif\n"
  "\n"
  "\tif (t >= sp->ats[sp->timecnt - 1])\n"
  "\t{\n"
  "\t\t/* No known transition > t, so use last known segment's type */\n"
  "\t\ti = sp->types[sp->timecnt - 1];\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*before_isdst = ttisp->tt_isdst;\n"
  "\t\treturn 0;\n"
  "\t}\n"
  "\tif (t < sp->ats[0])\n"
  "\t{\n"
  "\t\t/* For \"before\", use lowest-numbered standard type */\n"
  "\t\ti = 0;\n"
  "\t\twhile (sp->ttis[i].tt_isdst)\n"
  "\t\t\tif (++i >= sp->typecnt)\n"
  "\t\t\t{\n"
  "\t\t\t\ti = 0;\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*before_isdst = ttisp->tt_isdst;\n"
  "\t\t*boundary = sp->ats[0];\n"
  "\t\t/* And for \"after\", use the first segment's type */\n"
  "\t\ti = sp->types[0];\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*after_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*after_isdst = ttisp->tt_isdst;\n"
  "\t\treturn 1;\n"
  "\t}\n"
  "\t/* Else search to find the boundary following t */\n"
  "\t{\n"
  "\t\tint\t\t\tlo = 1;\n"
  "\t\tint\t\t\thi = sp->timecnt - 1;\n"
  "\n"
  "\t\twhile (lo < hi)\n"
  "\t\t{\n"
  "\t\t\tint\t\t\tmid = (lo + hi) >> 1;\n"
  "\n"
  "\t\t\tif (t < sp->ats[mid])\n"
  "\t\t\t\thi = mid;\n"
  "\t\t\telse\n"
  "\t\t\t\tlo = mid + 1;\n"
  "\t\t}\n"
  "\t\ti = lo;\n"
  "\t}\n"
  "\tj = sp->types[i - 1];\n"
  "\tttisp = &sp->ttis[j];\n"
  "\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t*before_isdst = ttisp->tt_isdst;\n"
  "\t*boundary = sp->ats[i];\n"
  "\tj = sp->types[i];\n"
  "\tttisp = &sp->ttis[j];\n"
  "\t*after_gmtoff = ttisp->tt_gmtoff;\n"
  "\t*after_isdst = ttisp->tt_isdst;\n"
  "\treturn 1;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(int)\n"
  "pg_next_dst_boundary(const cl_long *timep,\t/* pg_time_t in original */\n"
  "\t\t\t\t\t long int *before_gmtoff,\n"
  "\t\t\t\t\t int *before_isdst,\n"
  "\t\t\t\t\t cl_long *boundary,\t\t/* pg_time_t in original */\n"
  "\t\t\t\t\t long int *after_gmtoff,\n"
  "\t\t\t\t\t int *after_isdst,\n"
  "\t\t\t\t\t const tz_state *sp)\t/* const pg_tz *tz in original */\n"
  "{\n"
  "\tconst tz_ttinfo *ttisp;\n"
  "\tint\t\t\ti;\n"
  "\tint\t\t\tj;\n"
  "\tconst cl_long t = *timep;\t/* pg_time_t in original */\n"
  "\n"
  "\tif (sp->timecnt == 0)\n"
  "\t{\n"
  "\t\t/* non-DST zone, use lowest-numbered standard type */\n"
  "\t\ti = 0;\n"
  "\t\twhile (sp->ttis[i].tt_isdst)\n"
  "\t\t\tif (++i >= sp->typecnt)\n"
  "\t\t\t{\n"
  "\t\t\t\ti = 0;\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*before_isdst = ttisp->tt_isdst;\n"
  "\t\treturn 0;\n"
  "\t}\n"
  "\tif ((sp->goback && t < sp->ats[0]) ||\n"
  "\t\t(sp->goahead && t > sp->ats[sp->timecnt - 1]))\n"
  "\t{\n"
  "\t\t/* For values outside the transition table, extrapolate */\n"
  "\t\tcl_long\tnewt = t;\t/* pg_time_t in original */\n"
  "\t\tcl_long\tseconds;\t/* pg_time_t in original */\n"
  "\t\tcl_long\ttcycles;\t/* pg_time_t in original */\n"
  "\t\tcl_long\ticycles;\n"
  "\t\tint\t\tresult;\n"
  "\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tseconds = sp->ats[0] - t;\n"
  "\t\telse\n"
  "\t\t\tseconds = t - sp->ats[sp->timecnt - 1];\n"
  "\t\t--seconds;\n"
  "\t\ttcycles = seconds / YEARSPERREPEAT / AVGSECSPERYEAR;\n"
  "\t\t++tcycles;\n"
  "\t\ticycles = tcycles;\n"
  "\t\tif (tcycles - icycles >= 1 || icycles - tcycles >= 1)\n"
  "\t\t\treturn -1;\n"
  "\t\tseconds = icycles;\n"
  "\t\tseconds *= YEARSPERREPEAT;\n"
  "\t\tseconds *= AVGSECSPERYEAR;\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\tnewt += seconds;\n"
  "\t\telse\n"
  "\t\t\tnewt -= seconds;\n"
  "\t\tif (newt < sp->ats[0] ||\n"
  "\t\t\tnewt > sp->ats[sp->timecnt - 1])\n"
  "\t\t\treturn -1;\t\t\t/* \"cannot happen\" */\n"
  "\n"
  "\t\tresult = pg_next_dst_boundary_no_recursive(&newt, before_gmtoff,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   before_isdst,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   boundary,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   after_gmtoff,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   after_isdst,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   sp);\n"
  "\t\tif (t < sp->ats[0])\n"
  "\t\t\t*boundary -= seconds;\n"
  "\t\telse\n"
  "\t\t\t*boundary += seconds;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\n"
  "\tif (t >= sp->ats[sp->timecnt - 1])\n"
  "\t{\n"
  "\t\t/* No known transition > t, so use last known segment's type */\n"
  "\t\ti = sp->types[sp->timecnt - 1];\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*before_isdst = ttisp->tt_isdst;\n"
  "\t\treturn 0;\n"
  "\t}\n"
  "\tif (t < sp->ats[0])\n"
  "\t{\n"
  "\t\t/* For \"before\", use lowest-numbered standard type */\n"
  "\t\ti = 0;\n"
  "\t\twhile (sp->ttis[i].tt_isdst)\n"
  "\t\t\tif (++i >= sp->typecnt)\n"
  "\t\t\t{\n"
  "\t\t\t\ti = 0;\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*before_isdst = ttisp->tt_isdst;\n"
  "\t\t*boundary = sp->ats[0];\n"
  "\t\t/* And for \"after\", use the first segment's type */\n"
  "\t\ti = sp->types[0];\n"
  "\t\tttisp = &sp->ttis[i];\n"
  "\t\t*after_gmtoff = ttisp->tt_gmtoff;\n"
  "\t\t*after_isdst = ttisp->tt_isdst;\n"
  "\t\treturn 1;\n"
  "\t}\n"
  "\t/* Else search to find the boundary following t */\n"
  "\t{\n"
  "\t\tint\t\t\tlo = 1;\n"
  "\t\tint\t\t\thi = sp->timecnt - 1;\n"
  "\n"
  "\t\twhile (lo < hi)\n"
  "\t\t{\n"
  "\t\t\tint\t\t\tmid = (lo + hi) >> 1;\n"
  "\n"
  "\t\t\tif (t < sp->ats[mid])\n"
  "\t\t\t\thi = mid;\n"
  "\t\t\telse\n"
  "\t\t\t\tlo = mid + 1;\n"
  "\t\t}\n"
  "\t\ti = lo;\n"
  "\t}\n"
  "\tj = sp->types[i - 1];\n"
  "\tttisp = &sp->ttis[j];\n"
  "\t*before_gmtoff = ttisp->tt_gmtoff;\n"
  "\t*before_isdst = ttisp->tt_isdst;\n"
  "\t*boundary = sp->ats[i];\n"
  "\tj = sp->types[i];\n"
  "\tttisp = &sp->ttis[j];\n"
  "\t*after_gmtoff = ttisp->tt_gmtoff;\n"
  "\t*after_isdst = ttisp->tt_isdst;\n"
  "\treturn 1;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_int)\n"
  "DetermineTimeZoneOffset(struct pg_tm *tm,\n"
  "\t\t\t\t\t\tconst tz_state *sp)\t/* pg_tz *tzp in original */\n"
  "{\n"
  "\tcl_long t;\t\t\t\t\t/* pg_time_t in original */\n"
  "\n"
  "\tcl_long\t*tp = &t;\t\t\t/* pg_time_t in original */\n"
  "\n"
  "\tint\t\tdate, sec;\n"
  "\tcl_long\tday, mytime, boundary; /* pg_time_t in original */\n"
  "\tcl_long\tprevtime, beforetime, aftertime; /* pg_time_t in original */\n"
  "\tlong\tbefore_gmtoff,after_gmtoff;\n"
  "\tint\t\tbefore_isdst, after_isdst;\n"
  "\tint\t\tres;\n"
  "\n"
  "\t/*\n"
  "\t * First, generate the pg_time_t value corresponding to the given\n"
  "\t * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the\n"
  "\t * timezone is GMT.  (For a valid Julian date, integer overflow should be\n"
  "\t * impossible with 64-bit pg_time_t, but let's check for safety.)\n"
  "\t */\n"
  "\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n"
  "\t\tgoto overflow;\n"
  "\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n"
  "\n"
  "\tday = ((cl_long) date) * SECS_PER_DAY;\n"
  "\tif (day / SECS_PER_DAY != date)\n"
  "\t\tgoto overflow;\n"
  "\tsec = (tm->tm_sec +\n"
  "\t\t   (tm->tm_min + tm->tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE);\n"
  "\tmytime = day + sec;\n"
  "\t/* since sec >= 0, overflow could only be from +day to -mytime */\n"
  "\tif (mytime < 0 && day > 0)\n"
  "\t\tgoto overflow;\n"
  "\n"
  "\t/*\n"
  "\t * Find the DST time boundary just before or following the target time. We\n"
  "\t * assume that all zones have GMT offsets less than 24 hours, and that DST\n"
  "\t * boundaries can't be closer together than 48 hours, so backing up 24\n"
  "\t * hours and finding the \"next\" boundary will work.\n"
  "\t */\n"
  "\tprevtime = mytime - SECS_PER_DAY;\n"
  "\tif (mytime < 0 && prevtime > 0)\n"
  "\t\tgoto overflow;\n"
  "\n"
  "\tres = pg_next_dst_boundary(&prevtime,\n"
  "\t\t\t\t\t\t\t   &before_gmtoff, &before_isdst,\n"
  "\t\t\t\t\t\t\t   &boundary,\n"
  "\t\t\t\t\t\t\t   &after_gmtoff, &after_isdst,\n"
  "\t\t\t\t\t\t\t   sp);\n"
  "\tif (res < 0)\n"
  "\t\tgoto overflow;\t\t\t/* failure? */\n"
  "\n"
  "\tif (res == 0)\n"
  "\t{\n"
  "\t\t/* Non-DST zone, life is simple */\n"
  "\t\ttm->tm_isdst = before_isdst;\n"
  "\t\t*tp = mytime - before_gmtoff;\n"
  "\t\treturn -(int) before_gmtoff;\n"
  "\t}\n"
  "\n"
  "\t/*\n"
  "\t * Form the candidate pg_time_t values with local-time adjustment\n"
  "\t */\n"
  "\tbeforetime = mytime - before_gmtoff;\n"
  "\tif ((before_gmtoff > 0 &&\n"
  "\t\t mytime < 0 && beforetime > 0) ||\n"
  "\t\t(before_gmtoff <= 0 &&\n"
  "\t\t mytime > 0 && beforetime < 0))\n"
  "\t\tgoto overflow;\n"
  "\taftertime = mytime - after_gmtoff;\n"
  "\tif ((after_gmtoff > 0 &&\n"
  "\t\t mytime < 0 && aftertime > 0) ||\n"
  "\t\t(after_gmtoff <= 0 &&\n"
  "\t\t mytime > 0 && aftertime < 0))\n"
  "\t\tgoto overflow;\n"
  "\n"
  "\t/*\n"
  "\t * If both before or both after the boundary time, we know what to do. The\n"
  "\t * boundary time itself is considered to be after the transition, which\n"
  "\t * means we can accept aftertime == boundary in the second case.\n"
  "\t */\n"
  "\tif (beforetime < boundary && aftertime < boundary)\n"
  "\t{\n"
  "\t\ttm->tm_isdst = before_isdst;\n"
  "\t\t*tp = beforetime;\n"
  "\t\treturn -(int) before_gmtoff;\n"
  "\t}\n"
  "\tif (beforetime > boundary && aftertime >= boundary)\n"
  "\t{\n"
  "\t\ttm->tm_isdst = after_isdst;\n"
  "\t\t*tp = aftertime;\n"
  "\t\treturn -(int) after_gmtoff;\n"
  "\t}\n"
  "\n"
  "\t/*\n"
  "\t * It's an invalid or ambiguous time due to timezone transition.  In a\n"
  "\t * spring-forward transition, prefer the \"before\" interpretation; in a\n"
  "\t * fall-back transition, prefer \"after\".  (We used to define and implement\n"
  "\t * this test as \"prefer the standard-time interpretation\", but that rule\n"
  "\t * does not help to resolve the behavior when both times are reported as\n"
  "\t * standard time; which does happen, eg Europe/Moscow in Oct 2014.)\n"
  "\t */\n"
  "\tif (beforetime > aftertime)\n"
  "\t{\n"
  "\t\ttm->tm_isdst = before_isdst;\n"
  "\t\t*tp = beforetime;\n"
  "\t\treturn -(int) before_gmtoff;\n"
  "\t}\n"
  "\ttm->tm_isdst = after_isdst;\n"
  "\t*tp = aftertime;\n"
  "\treturn -(int) after_gmtoff;\n"
  "\n"
  "overflow:\n"
  "\t/* Given date is out of range, so assume UTC */\n"
  "\ttm->tm_isdst = 0;\n"
  "\t*tp = 0;\n"
  "\treturn 0;\n"
  "}\n"
  "\n"
  "/* simplified version; no timezone support now */\n"
  "STATIC_INLINE(cl_bool)\n"
  "timestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec,\n"
  "\t\t\t const tz_state *sp)\t/* pg_tz *attimezone in original */\n"
  "{\n"
  "\tcl_long\t\tdate;\t/* Timestamp in original */\n"
  "\tcl_long\t\ttime;\t/* Timestamp in original */\n"
  "\tcl_long\t\tutime;\t/* pg_time_t in original */\n"
  "\n"
  "\t/* Use session timezone if caller asks for default */\n"
  "    if (sp == NULL)\n"
  "        sp = &session_timezone_state;\n"
  "\n"
  "\ttime = dt;\n"
  "\tTMODULO(time, date, USECS_PER_DAY);\n"
  "\n"
  "\tif (time < INT64CONST(0))\n"
  "\t{\n"
  "\t\ttime += USECS_PER_DAY;\n"
  "\t\tdate -= 1;\n"
  "\t}\n"
  "\t/* add offset to go from J2000 back to standard Julian date */\n"
  "\tdate += POSTGRES_EPOCH_JDATE;\n"
  "\n"
  "\t/* Julian day routine does not work for negative Julian days */\n"
  "\tif (date < 0 || date > (Timestamp) INT_MAX)\n"
  "\t\treturn false;\n"
  "\n"
  "\tj2date((cl_int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n"
  "\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n"
  "\n"
  "\t/* Done if no TZ conversion wanted */\n"
  "\tif (tzp == NULL) {\n"
  "\t\ttm->tm_isdst = -1;\n"
  "\t\ttm->tm_gmtoff = 0;\n"
  "\n"
  "\t\treturn true;\n"
  "\t}\n"
  "\n"
  "\t/*\n"
  "     * If the time falls within the range of pg_time_t, use pg_localtime() to\n"
  "     * rotate to the local time zone.\n"
  "     *\n"
  "     * First, convert to an integral timestamp, avoiding possibly\n"
  "     * platform-specific roundoff-in-wrong-direction errors, and adjust to\n"
  "     * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n"
  "     * coding avoids hardwiring any assumptions about the width of pg_time_t,\n"
  "     * so it should behave sanely on machines without int64.\n"
  "     */\n"
  "    dt = (dt - *fsec) / USECS_PER_SEC +\n"
  "        (POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n"
  "\n"
  "    utime = (cl_long) dt;\n"
  "    if ((Timestamp) utime == dt)\n"
  "    {\n"
  "        struct pg_tm tx;\n"
  "\n"
  "\t\tpg_localtime(&utime, &tx, sp);\n"
  "\n"
  "        tm->tm_year = tx.tm_year + 1900;\n"
  "        tm->tm_mon = tx.tm_mon + 1;\n"
  "        tm->tm_mday = tx.tm_mday;\n"
  "        tm->tm_hour = tx.tm_hour;\n"
  "        tm->tm_min = tx.tm_min;\n"
  "        tm->tm_sec = tx.tm_sec;\n"
  "        tm->tm_isdst = tx.tm_isdst;\n"
  "        tm->tm_gmtoff = tx.tm_gmtoff;\n"
  "        *tzp = -tm->tm_gmtoff;\n"
  "    }\n"
  "    else\n"
  "    {\n"
  "        /*\n"
  "         * When out of range of pg_time_t, treat as GMT\n"
  "         */\n"
  "        *tzp = 0;\n"
  "        /* Mark this as *no* time zone available */\n"
  "        tm->tm_isdst = -1;\n"
  "        tm->tm_gmtoff = 0;\n"
  "    }\n"
  "\n"
  "\treturn true;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "tm2timestamp(struct pg_tm * tm, fsec_t fsec, int *tzp, Timestamp *result)\n"
  "{\n"
  "    TimeOffset  date;\n"
  "    TimeOffset  time;\n"
  "\n"
  "    /* Julian day routines are not correct for negative Julian days */\n"
  "    if (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n"
  "    {\n"
  "        *result = 0;\n"
  "\t\t/* keep compiler quiet */\n"
  "        return false;\n"
  "    }\n"
  "\n"
  "    date = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n"
  "    time = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n"
  "\n"
  "    *result = date * USECS_PER_DAY + time;\n"
  "    /* check for major overflow */\n"
  "    if ((*result - time) / USECS_PER_DAY != date)\n"
  "    {\n"
  "        *result = 0;\t\t/* keep compiler quiet */\n"
  "        return false;\n"
  "    }\n"
  "    /* check for just-barely overflow (okay except time-of-day wraps) */\n"
  "    /* caution: we want to allow 1999-12-31 24:00:00 */\n"
  "    if ((*result < 0 && date > 0) ||\n"
  "        (*result > 0 && date < -1))\n"
  "    {\n"
  "        *result = 0;\n"
  "\t\t/* keep compiler quiet */\n"
  "        return false;\n"
  "    }\n"
  "\t\n"
  "    if (tzp != NULL)\n"
  "        *result = dt2local(*result, -(*tzp));\n"
  "\n"
  "    return true;\n"
  "}\n"
  "\n"
  "/*\n"
  " * date2timestamptz\n"
  " *\n"
  " * It translates pg_date_t to pg_timestamptz_t based on the session\n"
  " * timezone information (session_timezone_state)\n"
  " */\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "date2timestamptz(kern_context *kcxt, pg_date_t arg)\n"
  "{\n"
  "\tpg_timestamptz_t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tint\t\t\t\ttz;\n"
  "\n"
  "\tif (arg.isnull)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t}\n"
  "\telse if (DATE_IS_NOBEGIN(arg.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tTIMESTAMP_NOBEGIN(result.value);\n"
  "\t}\n"
  "\telse if (DATE_IS_NOEND(arg.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tTIMESTAMP_NOEND(result.value);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "        j2date(arg.value + POSTGRES_EPOCH_JDATE,\n"
  "\t\t\t   &tm.tm_year, &tm.tm_mon, &tm.tm_mday);\n"
  "        tm.tm_hour = 0;\n"
  "        tm.tm_min = 0;\n"
  "        tm.tm_sec = 0;\n"
  "        tz = DetermineTimeZoneOffset(&tm, &session_timezone_state);\n"
  "\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = arg.value * USECS_PER_DAY + tz * USECS_PER_SEC;\n"
  "        /* Date's range is wider than timestamp's, so check for overflow */\n"
  "        if ((result.value - tz * USECS_PER_SEC) / USECS_PER_DAY != arg.value)\n"
  "\t\t{\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t}\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * timestamp2timestamptz\n"
  " *\n"
  " * It translates pg_timestamp_t to pg_timestamptz_t based on the session\n"
  " * timezone information (session_timezone_state)\n"
  " */\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "timestamp2timestamptz(kern_context *kcxt, pg_timestamp_t arg)\n"
  "{\n"
  "\tpg_timestamptz_t\tresult;\n"
  "\tstruct pg_tm\t\ttm;\n"
  "\tfsec_t\t\t\t\tfsec;\n"
  "\tint\t\t\t\t\ttz;\n"
  "\n"
  "\tif (arg.isnull)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t}\n"
  "    else if (TIMESTAMP_NOT_FINITE(arg.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "        result.value  = arg.value;\n"
  "\t}\n"
  "\telse if (!timestamp2tm(arg.value, NULL, &tm, &fsec, NULL))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "        tz = DetermineTimeZoneOffset(&tm, &session_timezone_state);\n"
  "\t\tif (!tm2timestamp(&tm, fsec, &tz, &result.value))\n"
  "\t\t{\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t}\n"
  "\t\telse\n"
  "\t\t{\n"
  "\t\t\tresult.isnull = false;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * GetCurrentDateTime()\n"
  " *\n"
  " * Get the transaction start time (\"now()\") broken down as a struct pg_tm.\n"
  " */\n"
  "STATIC_INLINE(void)\n"
  "GetCurrentDateTime(kern_context *kcxt, struct pg_tm * tm)\n"
  "{\n"
  "\tint\t\ttz;\n"
  "\tfsec_t\tfsec;\n"
  "\n"
  "\t// TimestampTz dt = GetCurrentTransactionStartTimestamp();\n"
  "\tTimestampTz dt = kcxt->kparams->xactStartTimestamp;\n"
  "\n"
  "\ttimestamp2tm(dt, &tz, tm, &fsec, NULL);\n"
  "    /* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n"
  "}\n"
  "\n"
  "#ifdef NOT_USED\n"
  "/* AdjustTimeForTypmod()\n"
  " * Force the precision of the time value to a specified value.\n"
  " * Uses *exactly* the same code as in AdjustTimestampForTypemod()\n"
  " * but we make a separate copy because those types do not\n"
  " * have a fundamental tie together but rather a coincidence of\n"
  " * implementation. - thomas\n"
  " */\n"
  "static const cl_long TimeScales[MAX_TIME_PRECISION + 1] =\n"
  "{\n"
  "\tINT64CONST(1000000),\n"
  "\tINT64CONST(100000),\n"
  "\tINT64CONST(10000),\n"
  "\tINT64CONST(1000),\n"
  "\tINT64CONST(100),\n"
  "\tINT64CONST(10),\n"
  "\tINT64CONST(1)\n"
  "};\n"
  "\n"
  "static const cl_long TimeOffsets[MAX_TIME_PRECISION + 1] =\n"
  "{\n"
  "\tINT64CONST(500000),\n"
  "\tINT64CONST(50000),\n"
  "\tINT64CONST(5000),\n"
  "\tINT64CONST(500),\n"
  "\tINT64CONST(50),\n"
  "\tINT64CONST(5),\n"
  "\tINT64CONST(0)\n"
  "};\n"
  "\n"
  "STATIC_INLINE(void)\n"
  "AdjustTimeForTypmod(TimeADT *time, cl_int typmod)\n"
  "{\n"
  "\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n"
  "\t{\n"
  "\t\t/*\n"
  "\t\t * Note: this round-to-nearest code is not completely consistent about\n"
  "\t\t * rounding values that are exactly halfway between integral values.\n"
  "\t\t * On most platforms, rint() will implement round-to-nearest-even, but\n"
  "\t\t * the integer code always rounds up (away from zero).  Is it worth\n"
  "\t\t * trying to be consistent?\n"
  "\t\t */\n"
  "\t\tif (*time >= 0LL)\n"
  "\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n"
  "\t\t\t\tTimeScales[typmod];\n"
  "\t\telse\n"
  "\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n"
  "\t\t\t\t\t  TimeScales[typmod]);\n"
  "\t}\n"
  "}\n"
  "#endif\n"
  "\n"
  "STATIC_INLINE(Interval)\n"
  "interval_justify_hours(Interval span)\n"
  "{\n"
  "\tInterval\tresult;\n"
  "\tTimeOffset\twholeday;\n"
  "\n"
  "\tresult.month = span.month;\n"
  "\tresult.day\t = span.day;\n"
  "\tresult.time\t = span.time;\n"
  "\n"
  "\tTMODULO(result.time, wholeday, USECS_PER_DAY);\n"
  "\tresult.day += wholeday;\t/* could overflow... */\n"
  "\n"
  "\tif (result.day > 0 && result.time < 0)\n"
  "\t{\n"
  "\t\tresult.time += USECS_PER_DAY;\n"
  "\t\tresult.day--;\n"
  "\t}\n"
  "\telse if (result.day < 0 && result.time > 0)\n"
  "\t{\n"
  "\t\tresult.time -= USECS_PER_DAY;\n"
  "\t\tresult.day++;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/* ---------------------------------------------------------------\n"
  " *\n"
  " * Type cast functions\n"
  " *\n"
  " * --------------------------------------------------------------- */\n"
  "STATIC_FUNCTION(pg_date_t)\n"
  "pgfn_timestamp_date(kern_context *kcxt, pg_timestamp_t arg1)\n"
  "{\n"
  "\tpg_date_t\t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tfsec_t\t\t\tfsec;\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (TIMESTAMP_IS_NOBEGIN(arg1.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tDATE_NOBEGIN(result.value);\n"
  "\t}\n"
  "\telse if (TIMESTAMP_IS_NOEND(arg1.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tDATE_NOEND(result.value);\n"
  "\t}\n"
  "\telse if (!timestamp2tm(arg1.value, NULL, &tm, &fsec, NULL))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = (date2j(tm.tm_year, tm.tm_mon, tm.tm_mday)\n"
  "\t\t\t\t\t\t - POSTGRES_EPOCH_JDATE);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Data cast functions related to timezonetz\n"
  " */\n"
  "STATIC_FUNCTION(pg_date_t)\n"
  "pgfn_timestamptz_date(kern_context *kcxt, pg_timestamptz_t arg1)\n"
  "{\n"
  "\tpg_date_t\t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tfsec_t\t\t\tfsec;\n"
  "\tint\t\t\t\ttz;\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (TIMESTAMP_IS_NOBEGIN(arg1.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tDATE_NOBEGIN(result.value);\n"
  "\t}\n"
  "\telse if (TIMESTAMP_IS_NOEND(arg1.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tDATE_NOEND(result.value);\n"
  "\t}\n"
  "\telse if (!timestamp2tm(arg1.value, &tz, &tm, &fsec, NULL))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = (date2j(tm.tm_year, tm.tm_mon, tm.tm_mday)\n"
  "\t\t\t\t\t\t - POSTGRES_EPOCH_JDATE);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_time_t)\n"
  "pgfn_timetz_time(kern_context *kcxt, pg_timetz_t arg1)\n"
  "{\n"
  "\tpg_time_t result;\n"
  "\n"
  "\tif (arg1.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = arg1.value.time;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_time_t)\n"
  "pgfn_timestamp_time(kern_context *kcxt, pg_timestamp_t arg1)\n"
  "{\n"
  "\tpg_time_t\t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tfsec_t\t\t\tfsec;\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (TIMESTAMP_NOT_FINITE(arg1.value))\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (!timestamp2tm(arg1.value, NULL, &tm, &fsec, NULL))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t((((tm.tm_hour * MINS_PER_HOUR\n"
  "\t\t\t\t+ tm.tm_min) * SECS_PER_MINUTE)\n"
  "\t\t\t    + tm.tm_sec) * USECS_PER_SEC)\n"
  "\t\t\t    + fsec;\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_time_t)\n"
  "pgfn_timestamptz_time(kern_context *kcxt, pg_timestamptz_t arg1)\n"
  "{\n"
  "\tpg_time_t\t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tfsec_t\t\t\tfsec;\n"
  "\tint\t\t\t\ttz;\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (TIMESTAMP_NOT_FINITE(arg1.value))\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (!timestamp2tm(arg1.value, &tz, &tm, &fsec, NULL))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t((((tm.tm_hour * MINS_PER_HOUR\n"
  "\t\t\t\t+ tm.tm_min) * SECS_PER_MINUTE)\n"
  "\t\t\t    + tm.tm_sec) * USECS_PER_SEC)\n"
  "\t\t\t    + fsec;\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timetz_t)\n"
  "pgfn_time_timetz(kern_context *kcxt, pg_time_t arg1)\n"
  "{\n"
  "\tpg_timetz_t\t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tfsec_t\t\t\tfsec;\n"
  "\tint\t\t\t\ttz;\n"
  "\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tGetCurrentDateTime(kcxt, &tm);\n"
  "\t\ttime2tm(arg1.value, &tm, &fsec);\n"
  "\t\ttz = DetermineTimeZoneOffset(&tm, &session_timezone_state);\n"
  "\n"
  "\t\tresult.isnull     = false;\n"
  "\t\tresult.value.time = arg1.value;\n"
  "\t\tresult.value.zone = tz;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timetz_t)\n"
  "pgfn_timestamptz_timetz(kern_context *kcxt, pg_timestamptz_t arg1)\n"
  "{\n"
  "\tpg_timetz_t\t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tint\t\t\t\ttz;\n"
  "\tfsec_t\t\t\tfsec;\n"
  "\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (TIMESTAMP_NOT_FINITE(arg1.value))\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (timestamp2tm(arg1.value, &tz, &tm, &fsec, NULL) != 0)\n"
  "\t{\n"
  "\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\ttm2timetz(&tm, fsec, tz, &(result.value));\n"
  "\t\tresult.isnull = false;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "#ifdef NOT_USED\n"
  "STATIC_FUNCTION(pg_timetz_t)\n"
  "pgfn_timetz_scale(kern_context *kcxt, pg_timetz_t arg1, pg_int4_t arg2)\n"
  "{\n"
  "\tpg_timetz_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull     = false;\n"
  "\t\tresult.value.time = arg1.value.time;\n"
  "\t\tresult.value.zone = arg1.value.zone;\n"
  "\n"
  "\t\tAdjustTimeForTypmod(&(result.value.time), arg2.value);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "#endif\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamp_t)\n"
  "pgfn_date_timestamp(kern_context *kcxt, pg_date_t arg1)\n"
  "{\n"
  "\tpg_timestamp_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t}\n"
  "\telse if (DATE_IS_NOBEGIN(arg1.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tTIMESTAMP_NOBEGIN(result.value);\n"
  "\t}\n"
  "\telse if (DATE_IS_NOEND(arg1.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tTIMESTAMP_NOEND(result.value);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\t/* date is days since 2000, timestamp is microseconds since same... */\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = arg1.value * USECS_PER_DAY;\n"
  "\t\t/* Date's range is wider than timestamp's, so check for overflow */\n"
  "\t\tif (result.value / USECS_PER_DAY != arg1.value)\n"
  "\t\t{\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t}\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamp_t)\n"
  "pgfn_timestamptz_timestamp(kern_context *kcxt, pg_timestamptz_t arg1)\n"
  "{\n"
  "\tpg_timestamp_t\tresult;\n"
  "\tstruct pg_tm\ttm;\n"
  "\tfsec_t\t\t\tfsec;\n"
  "\tint\t\t\t\ttz;\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t}\n"
  "\telse if (TIMESTAMP_NOT_FINITE(arg1.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "        result.value  = arg1.value;\n"
  "\t}\n"
  "\telse if (!timestamp2tm(arg1.value, &tz, &tm, &fsec, NULL))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse if (!tm2timestamp(&tm, fsec, NULL, &result.value))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "pgfn_date_timestamptz(kern_context *kcxt, pg_date_t arg1)\n"
  "{\n"
  "\treturn date2timestamptz(kcxt, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "pgfn_timestamp_timestamptz(kern_context *kcxt, pg_timestamp_t arg1)\n"
  "{\n"
  "\treturn timestamp2timestamptz(kcxt, arg1);\n"
  "}\n"
  "\n"
  "/*\n"
  " * Time/Date operators\n"
  " */\n"
  "STATIC_FUNCTION(pg_date_t)\n"
  "pgfn_date_pli(kern_context *kcxt, pg_date_t arg1, pg_int4_t arg2)\n"
  "{\n"
  "\tpg_date_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tif (DATE_NOT_FINITE(arg1.value))\n"
  "\t\t\tresult.value = arg1.value;\t/* can't change infinity */\n"
  "\t\telse\n"
  "\t\t\tresult.value = arg1.value + arg2.value;\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_date_t)\n"
  "pgfn_date_mii(kern_context *kcxt, pg_date_t arg1, pg_int4_t arg2)\n"
  "{\n"
  "\tpg_date_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tif (DATE_NOT_FINITE(arg1.value))\n"
  "\t\t\tresult.value = arg1.value;\t/* can't change infinity */\n"
  "\t\telse\n"
  "\t\t\tresult.value = arg1.value - arg2.value;\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_date_mi(kern_context *kcxt, pg_date_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (DATE_NOT_FINITE(arg1.value) || DATE_NOT_FINITE(arg2.value))\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_int)(arg1.value - arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamp_t)\n"
  "pgfn_datetime_pl(kern_context *kcxt, pg_date_t arg1, pg_time_t arg2)\n"
  "{\n"
  "\tpg_timestamp_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult = pgfn_date_timestamp(kcxt, arg1);\n"
  "\t\tif (!TIMESTAMP_NOT_FINITE(result.value))\n"
  "\t\t\tresult.value += arg2.value;\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_date_t)\n"
  "pgfn_integer_pl_date(kern_context *kcxt, pg_int4_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_date_pli(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamp_t)\n"
  "pgfn_timedate_pl(kern_context *kcxt, pg_time_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_datetime_pl(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_interval_t)\n"
  "pgfn_time_mi_time(kern_context *kcxt, pg_time_t arg1, pg_time_t arg2)\n"
  "{\n"
  "\tpg_interval_t result;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse \n"
  "\t{\n"
  "\t\tresult.isnull      = false;\n"
  "\t\tresult.value.month = 0;\n"
  "\t\tresult.value.day   = 0;\n"
  "\t\tresult.value.time  = arg1.value - arg2.value;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_interval_t)\n"
  "pgfn_timestamp_mi(kern_context *kcxt, pg_timestamp_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_interval_t result;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (TIMESTAMP_NOT_FINITE(arg1.value) || \n"
  "\t\t\t TIMESTAMP_NOT_FINITE(arg2.value))\n"
  "\t{\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t}\n"
  "\telse \n"
  "\t{\n"
  "\t\tresult.isnull      = false;\n"
  "\t\tresult.value.month = 0;\n"
  "\t\tresult.value.day   = 0;\n"
  "\t\tresult.value.time  = arg1.value - arg2.value;\n"
  "\n"
  "\t\t/*----------\n"
  "\t\t *\tThis is wrong, but removing it breaks a lot of regression tests.\n"
  "\t\t *\tFor example:\n"
  "\t\t *\n"
  "\t\t *\ttest=> SET timezone = 'EST5EDT';\n"
  "\t\t *\ttest=> SELECT\n"
  "\t\t *\ttest-> ('2005-10-30 13:22:00-05'::timestamptz -\n"
  "\t\t *\ttest(>\t'2005-10-29 13:22:00-04'::timestamptz);\n"
  "\t\t *\t?column?\n"
  "\t\t *\t----------------\n"
  "\t\t *\t 1 day 01:00:00\n"
  "\t\t *\t (1 row)\n"
  "\t\t *\n"
  "\t\t *\tso adding that to the first timestamp gets:\n"
  "\t\t *\n"
  "\t\t *\ttest=> SELECT\n"
  "\t\t *\ttest-> ('2005-10-29 13:22:00-04'::timestamptz +\n"
  "\t\t *\ttest(> ('2005-10-30 13:22:00-05'::timestamptz -\n"
  "\t\t *\ttest(>  '2005-10-29 13:22:00-04'::timestamptz)) at time zone 'EST';\n"
  "\t\t *\t\ttimezone\n"
  "\t\t *\t--------------------\n"
  "\t\t *\t2005-10-30 14:22:00\n"
  "\t\t *\t(1 row)\n"
  "\t\t *----------\n"
  "\t\t */\n"
  "\t\tresult.value = interval_justify_hours(result.value);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timetz_t)\n"
  "pgfn_timetz_pl_interval(kern_context *kcxt,\n"
  "\t\t\t\t\t\tpg_timetz_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "    pg_timetz_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value.time = arg1.value.time + arg2.value.time;\n"
  "\t\tresult.value.time -= result.value.time / USECS_PER_DAY * USECS_PER_DAY;\n"
  "\t\tif (result.value.time < INT64CONST(0))\n"
  "\t\t\tresult.value.time += USECS_PER_DAY;\n"
  "\n"
  "\t\tresult.value.zone = arg1.value.zone;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timetz_t)\n"
  "pgfn_timetz_mi_interval(kern_context *kcxt, pg_timetz_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\targ2.value.time = - arg2.value.time;\n"
  "\n"
  "\treturn pgfn_timetz_pl_interval(kcxt, arg1, arg2);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "pgfn_timestamptz_pl_interval(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t pg_timestamptz_t arg1,\n"
  "\t\t\t\t\t\t\t pg_interval_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\n"
  "\tif (TIMESTAMP_NOT_FINITE(arg1.value))\n"
  "\t\tresult = arg1;\n"
  "\telse\n"
  "\t{\n"
  "\t\tif (arg2.value.month != 0)\n"
  "\t\t{\n"
  "\t\t\tstruct pg_tm tm;\n"
  "\t\t\tfsec_t fsec;\n"
  "\n"
  "\t\t\tif (timestamp2tm(arg1.value, NULL, &tm, &fsec, NULL) != 0)\n"
  "\t\t\t{\n"
  "\t\t\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\ttm.tm_mon += arg2.value.month;\n"
  "\t\t\tif (tm.tm_mon > MONTHS_PER_YEAR)\n"
  "\t\t\t{\n"
  "\t\t\t\ttm.tm_year +=  (tm.tm_mon - 1) / MONTHS_PER_YEAR;\n"
  "\t\t\t\ttm.tm_mon   = ((tm.tm_mon - 1) % MONTHS_PER_YEAR) + 1;\n"
  "\t\t\t}\n"
  "\t\t\telse if (tm.tm_mon < 1)\n"
  "\t\t\t{\n"
  "\t\t\t\ttm.tm_year += tm.tm_mon / MONTHS_PER_YEAR - 1;\n"
  "\t\t\t\ttm.tm_mon   = tm.tm_mon % MONTHS_PER_YEAR + MONTHS_PER_YEAR;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\t/* adjust for end of month boundary problems... */\n"
  "\t\t\tif (tm.tm_mday > day_tab[isleap(tm.tm_year)][tm.tm_mon - 1])\n"
  "\t\t\t\ttm.tm_mday = (day_tab[isleap(tm.tm_year)][tm.tm_mon - 1]);\n"
  "\n"
  "\t\t\tif (tm2timestamp(&tm, fsec, NULL, &arg1.value) != 0)\n"
  "\t\t\t{\n"
  "\t\t\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\n"
  "\t\tif (arg2.value.day != 0)\n"
  "\t\t{\n"
  "\t\t\tstruct pg_tm tm;\n"
  "\t\t\tfsec_t fsec;\n"
  "\t\t\tint julian;\n"
  "\n"
  "\t\t\tif (timestamp2tm(arg1.value, NULL, &tm, &fsec, NULL) != 0)\n"
  "\t\t\t{\n"
  "\t\t\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\t/* Add days by converting to and from julian */\n"
  "\t\t\tjulian = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) + arg2.value.day;\n"
  "\t\t\tj2date(julian, &tm.tm_year, &tm.tm_mon, &tm.tm_mday);\n"
  "\n"
  "\t\t\tif (tm2timestamp(&tm, fsec, NULL, &arg1.value) != 0)\n"
  "\t\t\t{\n"
  "\t\t\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE;\n"
  "\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\t\t\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = arg1.value + arg2.value.time;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "pgfn_timestamptz_mi_interval(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t pg_timestamptz_t arg1,\n"
  "\t\t\t\t\t\t\t pg_interval_t arg2)\n"
  "{\n"
  "\targ2.value.month = - arg2.value.month;\n"
  "\targ2.value.day   = - arg2.value.day;\n"
  "\targ2.value.time  = - arg2.value.time;\n"
  "\n"
  "\treturn pgfn_timestamptz_pl_interval(kcxt, arg1, arg2);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_interval_t)\n"
  "pgfn_interval_um(kern_context *kcxt, pg_interval_t arg1)\n"
  "{\n"
  "\tpg_interval_t result;\n"
  "\n"
  "\tif (arg1.isnull)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\n"
  "\tresult.value.time = - arg1.value.time;\n"
  "\t/* overflow check copied from int4um */\n"
  "\tif (arg1.value.time != 0 && SAMESIGN(result.value.time, arg1.value.time))\n"
  "\t{\n"
  "\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\tresult.value.day = - arg1.value.day;\n"
  "\tif (arg1.value.day != 0 && SAMESIGN(result.value.day, arg1.value.day))\n"
  "\t{\n"
  "\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\tresult.value.month = - arg1.value.month;\n"
  "\tif (arg1.value.month != 0 &&\n"
  "\t\tSAMESIGN(result.value.month, arg1.value.month))\n"
  "\t{\n"
  "\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\tresult.isnull = false;\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_interval_t)\n"
  "pgfn_interval_pl(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_interval_t result;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\t\n"
  "\tresult.value.month = arg1.value.month + arg2.value.month;\n"
  "\t/* overflow check copied from int4pl */\n"
  "\tif (SAMESIGN(arg1.value.month, arg2.value.month) &&\n"
  "\t\t!SAMESIGN(result.value.month, arg1.value.month))\n"
  "\t{\n"
  "\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\tresult.value.day = arg1.value.day + arg2.value.day;\n"
  "\tif (SAMESIGN(arg1.value.day, arg2.value.day) &&\n"
  "\t\t!SAMESIGN(result.value.day, arg1.value.day))\n"
  "\t{\n"
  "\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\tresult.value.time = arg1.value.time + arg2.value.time;\n"
  "\tif (SAMESIGN(arg1.value.time, arg2.value.time) &&\n"
  "\t\t!SAMESIGN(result.value.time, arg1.value.time))\n"
  "\t{\n"
  "\t\t// ERRCODE_DATETIME_VALUE_OUT_OF_RANGE\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult.isnull = true;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\tresult.isnull = false;\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_interval_t)\n"
  "pgfn_interval_mi(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\targ2.value.time  = - arg2.value.time;\n"
  "\targ2.value.day   = - arg2.value.day;\n"
  "\targ2.value.month = - arg2.value.month;\n"
  "\n"
  "\treturn pgfn_interval_pl(kcxt, arg1, arg2);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "pgfn_datetimetz_timestamptz(kern_context *kcxt, pg_date_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "    pg_timestamptz_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\n"
  "\t\tif (DATE_IS_NOBEGIN(arg1.value))\n"
  "\t\t\tTIMESTAMP_NOBEGIN(result.value);\n"
  "\t\telse if (DATE_IS_NOEND(arg1.value))\n"
  "\t\t\tTIMESTAMP_NOEND(result.value);\n"
  "\t\telse\n"
  "\t\t\tresult.value = arg1.value * USECS_PER_DAY \n"
  "\t\t\t\t+ arg2.value.time + arg2.value.zone * USECS_PER_SEC;\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Date comparison\n"
  " */\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_eq_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_date_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt1 = pgfn_date_timestamp(kcxt, arg1);\n"
  "\n"
  "\tif (dt1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(dt1.value == arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_ne_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_date_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt1 = pgfn_date_timestamp(kcxt, arg1);\n"
  "\n"
  "\tif (dt1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(dt1.value != arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_lt_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_date_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt1 = pgfn_date_timestamp(kcxt, arg1);\n"
  "\n"
  "\tif (dt1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(dt1.value < arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_le_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_date_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt1 = pgfn_date_timestamp(kcxt, arg1);\n"
  "\n"
  "\tif (dt1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(dt1.value <= arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_gt_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_date_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt1 = pgfn_date_timestamp(kcxt, arg1);\n"
  "\n"
  "\tif (dt1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(dt1.value > arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_ge_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_date_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt1 = pgfn_date_timestamp(kcxt, arg1);\n"
  "\n"
  "\tif (dt1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(dt1.value >= arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_date_cmp_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\tpg_date_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\tpg_int4_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt1 = pgfn_date_timestamp(kcxt, arg1);\n"
  "\n"
  "\tif (dt1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tif (dt1.value > arg2.value)\n"
  "\t\t\tresult.value = 1;\n"
  "\t\telse if (dt1.value < arg2.value)\n"
  "\t\t\tresult.value = -1;\n"
  "\t\telse\n"
  "\t\t\tresult.value = 0;\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Comparison between timetz\n"
  " */\n"
  "STATIC_INLINE(cl_int)\n"
  "timetz_cmp_internal(TimeTzADT arg1, TimeTzADT arg2)\n"
  "{\n"
  "\tTimeOffset\tt1 = arg1.time + arg1.zone * USECS_PER_SEC;\n"
  "\tTimeOffset\tt2 = arg2.time + arg2.zone * USECS_PER_SEC;\n"
  "\n"
  "\tcl_int\tresult;\n"
  "\n"
  "\tif (t1 > t2)\n"
  "\t\tresult = 1;\n"
  "\telse if (t1 < t2)\n"
  "\t\tresult = -1;\n"
  "\t/*\n"
  "\t * If same GMT time, sort by timezone; we only want to say that two\n"
  "\t * timetz's are equal if both the time and zone parts are equal.\n"
  "\t */\n"
  "\telse if (arg1.zone > arg2.zone)\n"
  "\t\tresult = 1;\n"
  "\telse if (arg1.zone < arg2.zone)\n"
  "\t\tresult = -1;\n"
  "\telse \n"
  "\t\tresult = 0;\n"
  "\n"
  "    return result;\t\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "timetz_eq_internal(TimeTzADT arg1, TimeTzADT arg2)\n"
  "{\n"
  "\treturn (cl_bool)(timetz_cmp_internal(arg1, arg2) == 0);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "timetz_ne_internal(TimeTzADT arg1, TimeTzADT arg2)\n"
  "{\n"
  "\treturn (cl_bool)(timetz_cmp_internal(arg1, arg2) != 0);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "timetz_lt_internal(TimeTzADT arg1, TimeTzADT arg2)\n"
  "{\n"
  "\treturn (cl_bool)(timetz_cmp_internal(arg1, arg2) < 0);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "timetz_le_internal(TimeTzADT arg1, TimeTzADT arg2)\n"
  "{\n"
  "\treturn (cl_bool)(timetz_cmp_internal(arg1, arg2) <= 0);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "timetz_ge_internal(TimeTzADT arg1, TimeTzADT arg2)\n"
  "{\n"
  "\treturn (cl_bool)(timetz_cmp_internal(arg1, arg2) >= 0);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_bool)\n"
  "timetz_gt_internal(TimeTzADT arg1, TimeTzADT arg2)\n"
  "{\n"
  "\treturn (cl_bool)(timetz_cmp_internal(arg1, arg2) > 0);\n"
  "}\n"
  "\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timetz_eq(kern_context *kcxt, pg_timetz_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\t\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = timetz_eq_internal(arg1.value, arg2.value);\n"
  "\t}\t\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timetz_ne(kern_context *kcxt, pg_timetz_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\t\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = timetz_ne_internal(arg1.value, arg2.value);\n"
  "\t}\t\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timetz_lt(kern_context *kcxt, pg_timetz_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\t\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = timetz_lt_internal(arg1.value, arg2.value);\n"
  "\t}\t\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timetz_le(kern_context *kcxt, pg_timetz_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\t\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = timetz_le_internal(arg1.value, arg2.value);\n"
  "\t}\t\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timetz_ge(kern_context *kcxt, pg_timetz_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\t\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = timetz_ge_internal(arg1.value, arg2.value);\n"
  "\t}\t\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timetz_gt(kern_context *kcxt, pg_timetz_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\t\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = timetz_gt_internal(arg1.value, arg2.value);\n"
  "\t}\t\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_timetz_cmp(kern_context *kcxt, pg_timetz_t arg1, pg_timetz_t arg2)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) \n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = timetz_cmp_internal(arg1.value, arg2.value);\n"
  "\t}\n"
  "\n"
  "    return result;\t\n"
  "}\n"
  "\n"
  "/*\n"
  " * Timestamp comparison\n"
  " */\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_eq_date(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_timestamp_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt2 = pgfn_date_timestamp(kcxt, arg2);\n"
  "\n"
  "\tif (arg1.isnull || dt2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(arg1.value == dt2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_ne_date(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_timestamp_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt2 = pgfn_date_timestamp(kcxt, arg2);\n"
  "\n"
  "\tif (arg1.isnull || dt2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(arg1.value != dt2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_lt_date(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_timestamp_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt2 = pgfn_date_timestamp(kcxt, arg2);\n"
  "\n"
  "\tif (arg1.isnull || dt2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(arg1.value < dt2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_le_date(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_timestamp_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt2 = pgfn_date_timestamp(kcxt, arg2);\n"
  "\n"
  "\tif (arg1.isnull || dt2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(arg1.value <= dt2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_gt_date(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_timestamp_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt2 = pgfn_date_timestamp(kcxt, arg2);\n"
  "\n"
  "\tif (arg1.isnull || dt2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(arg1.value > dt2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_ge_date(kern_context *kcxt,\n"
  "\t\t\t\t\t   pg_timestamp_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_bool_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt2 = pgfn_date_timestamp(kcxt, arg2);\n"
  "\n"
  "\tif (arg1.isnull || dt2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(arg1.value >= dt2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_timestamp_cmp_date(kern_context *kcxt,\n"
  "\t\t\t\t\t\tpg_timestamp_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\tpg_int4_t\t\tresult;\n"
  "\tpg_timestamp_t\tdt2 = pgfn_date_timestamp(kcxt, arg2);\n"
  "\n"
  "\tif (arg1.isnull || dt2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tif (arg1.value > dt2.value)\n"
  "\t\t\tresult.value = 1;\n"
  "\t\telse if (arg1.value < dt2.value)\n"
  "\t\t\tresult.value = -1;\n"
  "\t\telse\n"
  "\t\t\tresult.value = 0;\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Comparison between date and timestamptz\n"
  " */\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_lt_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_date_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = date2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value < arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_le_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_date_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = date2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value <= arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_eq_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_date_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = date2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value == arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_ge_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_date_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = date2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value >= arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_gt_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_date_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = date2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value > arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_date_ne_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_date_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = date2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value != arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Comparison between timestamptz and date\n"
  " */\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_lt_date(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_timestamptz_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_date_gt_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_le_date(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_timestamptz_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_date_ge_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_eq_date(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_timestamptz_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_date_eq_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_ge_date(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_timestamptz_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_date_le_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_gt_date(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_timestamptz_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_date_lt_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_ne_date(kern_context *kcxt,\n"
  "\t\t\t\t\t\t pg_timestamptz_t arg1, pg_date_t arg2)\n"
  "{\n"
  "\treturn pgfn_date_ne_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "/*\n"
  " * Comparison between timestamp and timestamptz\n"
  " */\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_lt_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamp_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = timestamp2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value < arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_le_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamp_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = timestamp2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value <= arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_eq_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamp_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = timestamp2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value == arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_ge_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamp_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = timestamp2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value >= arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_gt_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamp_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = timestamp2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value > arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamp_ne_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamp_t arg1, pg_timestamptz_t arg2)\n"
  "{\n"
  "\tpg_timestamptz_t temp;\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\ttemp = timestamp2timestamptz(kcxt, arg1);\n"
  "\tif (temp.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (cl_bool)(temp.value != arg2.value);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Comparison between timestamptz and timestamp\n"
  " */\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_lt_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamptz_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\treturn pgfn_timestamp_gt_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_le_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamptz_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\treturn pgfn_timestamp_ge_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_eq_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamptz_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\treturn pgfn_timestamp_eq_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_ge_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamptz_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\treturn pgfn_timestamp_le_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_gt_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamptz_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\treturn pgfn_timestamp_lt_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_timestamptz_ne_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\t\t  pg_timestamptz_t arg1, pg_timestamp_t arg2)\n"
  "{\n"
  "\treturn pgfn_timestamp_ne_timestamptz(kcxt, arg2, arg1);\n"
  "}\n"
  "\n"
  "/*\n"
  " * Comparison between pg_interval_t\n"
  " */\n"
  "STATIC_INLINE(TimeOffset)\n"
  "interval_cmp_value(const Interval interval)\n"
  "{\n"
  "\tTimeOffset\tspan;\n"
  "\n"
  "\tspan = interval.time;\n"
  "\tspan += interval.month * INT64CONST(30) * USECS_PER_DAY;\n"
  "\tspan += interval.day * INT64CONST(24) * USECS_PER_HOUR;\n"
  "\n"
  "\treturn span;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_int)\n"
  "interval_cmp_internal(Interval arg1, Interval arg2)\n"
  "{\n"
  "\tTimeOffset\tspan1 = interval_cmp_value(arg1);\n"
  "\tTimeOffset\tspan2 = interval_cmp_value(arg2);\n"
  "\n"
  "\treturn ((span1 < span2) ? -1 : (span1 > span2) ? 1 : 0);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_interval_eq(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t(cl_bool)(interval_cmp_internal(arg1.value, arg2.value) == 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_interval_ne(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t(cl_bool)(interval_cmp_internal(arg1.value, arg2.value) != 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_interval_lt(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t(cl_bool)(interval_cmp_internal(arg1.value, arg2.value) < 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_interval_le(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t(cl_bool)(interval_cmp_internal(arg1.value, arg2.value) <= 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_interval_ge(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t(cl_bool)(interval_cmp_internal(arg1.value, arg2.value) >= 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_interval_gt(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value =\n"
  "\t\t\t(cl_bool)(interval_cmp_internal(arg1.value, arg2.value) > 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_interval_cmp(kern_context *kcxt, pg_interval_t arg1, pg_interval_t arg2)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = interval_cmp_internal(arg1.value, arg2.value);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * current date time function\n"
  " */\n"
  "STATIC_FUNCTION(pg_timestamptz_t)\n"
  "pgfn_now(kern_context *kcxt)\n"
  "{\n"
  "\tpg_timestamptz_t\tresult;\n"
  "\tkern_parambuf\t   *kparams = kcxt->kparams;\n"
  "\n"
  "\tresult.value  = kparams->xactStartTimestamp;\n"
  "\tresult.isnull = false;\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * overlaps() SQL functions\n"
  " *\n"
  " * NOTE: Even though overlaps() has more variations, inline_function()\n"
  " * preliminary break down combination with type-cast.\n"
  " */\n"
  "#if 0\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "overlaps_cl_long(kern_context *kcxt,\n"
  "\t\t\t\t cl_long ts1, cl_bool ts1_isnull,\n"
  "\t\t\t\t cl_long te1, cl_bool te1_isnull,\n"
  "\t\t\t\t cl_long ts2, cl_bool ts2_isnull,\n"
  "\t\t\t\t cl_long te2, cl_bool te2_isnull)\n"
  "{\n"
  "\tpg_bool_t rc;\n"
  "\n"
  "\t/*\n"
  "\t * If both endpoints of interval 1 are null, the result is null (unknown).\n"
  "\t * If just one endpoint is null, take ts1 as the non-null one. Otherwise,\n"
  "\t * take ts1 as the lesser endpoint.\n"
  "\t */\n"
  "\tif (ts1_isnull)\n"
  "\t{\n"
  "\t\tif (te1_isnull)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\t\t/* swap null for non-null */\n"
  "\t\tts1        = te1;\n"
  "\t\tts1_isnull = false;\n"
  "\t\tte1_isnull = true;\n"
  "\t}\n"
  "\telse if (!te1_isnull)\n"
  "\t{\n"
  "\t\tif (ts1 > te1)\n"
  "\t\t{\n"
  "\t\t\tcl_long tmp = ts1;\n"
  "\t\t\tts1 = te1;\n"
  "\t\t\tte1 = tmp;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t/* Likewise for interval 2. */\n"
  "\tif (ts2_isnull)\n"
  "\t{\n"
  "\t\tif (te2_isnull)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\t\t/* swap null for non-null */\n"
  "\t\tts2        = te2;\n"
  "\t\tts2_isnull = false;\n"
  "\t\tte2_isnull = true;\n"
  "\t}\n"
  "\telse if (!te2_isnull)\n"
  "\t{\n"
  "\t\tif (ts2 > te2)\n"
  "\t\t{\n"
  "\t\t\tcl_long tmp = ts2;\n"
  "\t\t\tts2 = te2;\n"
  "\t\t\tte2 = tmp;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t/*\n"
  "\t * At this point neither ts1 nor ts2 is null, so we can consider three\n"
  "\t * cases: ts1 > ts2, ts1 < ts2, ts1 = ts2\n"
  "\t */\n"
  "\tif (ts1 > ts2)\n"
  "\t{\n"
  "\t\t/*\n"
  "\t\t * This case is ts1 < te2 OR te1 < te2, which may look redundant but\n"
  "\t\t * in the presence of nulls it's not quite completely so.\n"
  "\t\t */\n"
  "\t\tif (te2_isnull)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\t\tif (ts1 < te2)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = false;\n"
  "\t\t\trc.value  = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\t\tif (te1_isnull)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\n"
  "\t\t/*\n"
  "\t\t * If te1 is not null then we had ts1 <= te1 above, and we just found\n"
  "\t\t * ts1 >= te2, hence te1 >= te2.\n"
  "\t\t */\n"
  "\t\trc.isnull = false;\n"
  "\t\trc.value  = false;\n"
  "\t\treturn rc;\n"
  "\t}\n"
  "\telse if (ts1 < ts2)\n"
  "\t{\n"
  "\t\t/* This case is ts2 < te1 OR te2 < te1 */\n"
  "\t\tif (te1_isnull)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\t\tif (ts2 < te1)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = false;\n"
  "\t\t\trc.value  = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\t\tif (te2_isnull)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\n"
  "\t\t/*\n"
  "\t\t * If te2 is not null then we had ts2 <= te2 above, and we just found\n"
  "\t\t * ts2 >= te1, hence te2 >= te1.\n"
  "\t\t */\n"
  "\t\trc.isnull = false;\n"
  "\t\trc.value  = false;\n"
  "\t\treturn rc;\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\t/*\n"
  "\t\t * For ts1 = ts2 the spec says te1 <> te2 OR te1 = te2, which is a\n"
  "\t\t * rather silly way of saying \"true if both are nonnull, else null\".\n"
  "\t\t */\n"
  "\t\tif (te1_isnull || te2_isnull)\n"
  "\t\t{\n"
  "\t\t\trc.isnull = true;\n"
  "\t\t\treturn rc;\n"
  "\t\t}\n"
  "\t\trc.isnull = false;\n"
  "\t\trc.value  = true;\n"
  "\t\treturn rc;\n"
  "\t}\n"
  "}\n"
  "#endif\n"
  "\n"
  "#define OVERLAPS(type,cmp_gt_ops,cmp_lt_ops)\t\t\t\t\\\n"
  "\tSTATIC_INLINE(pg_bool_t)\t\t\t\t\t\t\t\t\\\n"
  "\toverlaps_##type(kern_context *kcxt,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\ttype ts1, bool ts1_isnull,\t\t\t\t\\\n"
  "\t\t\t\t\ttype te1, bool te1_isnull,\t\t\t\t\\\n"
  "\t\t\t\t\ttype ts2, bool ts2_isnull,\t\t\t\t\\\n"
  "\t\t\t\t\ttype te4, bool te4_isnull)\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tpg_bool_t result;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (ts1_isnull)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (te1_isnull)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.isnull = true;\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tts1 = te1;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tts1_isnull = false;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tte1_isnull = true;\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse if (! te1_isnull)\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (cmp_gt_ops(ts1, te1)) \t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\ttype tmp = ts1;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tts1 = te1;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tte1 = tmp;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (ts2_isnull)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (te4_isnull)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.isnull = true;\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tts2 = te4;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tts2_isnull = false;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tte4_isnull = true;\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse if (! te4_isnull)\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (cmp_gt_ops(ts2, te4))\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\ttype tmp = ts2;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tts2 = te4;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tte4 = tmp;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (cmp_gt_ops(ts1, ts2))\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (te4_isnull)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.isnull = true;\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (cmp_lt_ops(ts1, te4))\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.isnull = false;\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.value  = true;\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (te1_isnull)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.isnull = true;\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = false;\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.value  = false;\t\t\t\t\t\t\t\\\n"
  "\t\t\treturn result;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (cmp_lt_ops(ts1, ts2))\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (te1_isnull)\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tresult.isnull = true;\t\t\t\t\t\\\n"
  "\t\t\t\t\treturn result;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (cmp_lt_ops(ts2, te1))\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tresult.isnull = false;\t\t\t\t\t\\\n"
  "\t\t\t\t\tresult.value  = true;\t\t\t\t\t\\\n"
  "\t\t\t\t\treturn result;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (te4_isnull)\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tresult.isnull = true;\t\t\t\t\t\\\n"
  "\t\t\t\t\treturn result;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.isnull = false;\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.value  = false;\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (te1_isnull || te4_isnull)\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tresult.isnull = true;\t\t\t\t\t\\\n"
  "\t\t\t\t\treturn result;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.isnull = false;\t\t\t\t\t\t\\\n"
  "\t\t\t\tresult.value  = true;\t\t\t\t\t\t\\\n"
  "\t\t\t\treturn result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define COMPARE_GT_OPS(x,y)\t((x) > (y))\n"
  "#define COMPARE_LT_OPS(x,y)\t((x) < (y))\n"
  "\n"
  "OVERLAPS(cl_long,COMPARE_GT_OPS,COMPARE_LT_OPS)\n"
  "OVERLAPS(TimeTzADT,timetz_gt_internal,timetz_lt_internal)\n"
  "\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_overlaps_time(kern_context *kcxt,\n"
  "\t\t\t\t   pg_time_t arg1, pg_time_t arg2,\n"
  "\t\t\t\t   pg_time_t arg3, pg_time_t arg4)\n"
  "{\n"
  "  return overlaps_cl_long(kcxt,\n"
  "\t\t\t\t\t\t  arg1.value, arg1.isnull,\n"
  "\t\t\t\t\t\t  arg2.value, arg2.isnull,\n"
  "\t\t\t\t\t\t  arg3.value, arg3.isnull,\n"
  "\t\t\t\t\t\t  arg4.value, arg4.isnull);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_overlaps_timetz(kern_context *kcxt,\n"
  "\t\t\t\t\t pg_timetz_t arg1, pg_timetz_t arg2,\n"
  "\t\t\t\t\t pg_timetz_t arg3, pg_timetz_t arg4)\n"
  "{\n"
  "\treturn overlaps_TimeTzADT(kcxt,\n"
  "\t\t\t\t\t\t\t  arg1.value, arg1.isnull,\n"
  "\t\t\t\t\t\t\t  arg2.value, arg2.isnull,\n"
  "\t\t\t\t\t\t\t  arg3.value, arg3.isnull,\n"
  "\t\t\t\t\t\t\t  arg4.value, arg4.isnull);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_overlaps_timestamp(kern_context *kcxt,\n"
  "\t\t\t\t\t\tpg_timestamp_t arg1, pg_timestamp_t arg2,\n"
  "\t\t\t\t\t\tpg_timestamp_t arg3, pg_timestamp_t arg4)\n"
  "{\n"
  "  return overlaps_cl_long(kcxt,\n"
  "\t\t\t\t\t\t  arg1.value, arg1.isnull,\n"
  "\t\t\t\t\t\t  arg2.value, arg2.isnull,\n"
  "\t\t\t\t\t\t  arg3.value, arg3.isnull,\n"
  "\t\t\t\t\t\t  arg4.value, arg4.isnull);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_overlaps_timestamptz(kern_context *kcxt,\n"
  "\t\t\t\t\t\t  pg_timestamptz_t arg1, pg_timestamptz_t arg2,\n"
  "\t\t\t\t\t\t  pg_timestamptz_t arg3, pg_timestamptz_t arg4)\n"
  "{\n"
  "  return overlaps_cl_long(kcxt,\n"
  "\t\t\t\t\t\t  arg1.value, arg1.isnull,\n"
  "\t\t\t\t\t\t  arg2.value, arg2.isnull,\n"
  "\t\t\t\t\t\t  arg3.value, arg3.isnull,\n"
  "\t\t\t\t\t\t  arg4.value, arg4.isnull);\n"
  "}\n"
  "\n"
  "#else\t/* __CUDACC__ */\n"
  "\n"
  "#include \"access/xact.h\"\n"
  "#include \"pgtime.h\"\n"
  "\n"
  "/*\n"
  " * assign_timelib_session_info\n"
  " *\n"
  " * It constructs per-session information around cuda_timelib.h.\n"
  " * At this moment, items below has to be informed.\n"
  " * - session_timezone information\n"
  " */\n"
  "\n"
  "/* copied from src/timezone/tzfile.h */\n"
  "#define TZ_MAX_TIMES\t1200\n"
  "#define TZ_MAX_TYPES\t256\t\t/* Limited by what (uchar)'s can hold */\n"
  "#define TZ_MAX_CHARS\t50\t\t/* Maximum number of abbreviation characters */\n"
  "#define TZ_MAX_LEAPS\t50\t\t/* Maximum number of leap second corrections */\n"
  "\n"
  "/* copied from src/timezone/pgtz.h */\n"
  "#define BIGGEST(a, b)\t(((a) > (b)) ? (a) : (b))\n"
  "\n"
  "struct ttinfo\n"
  "{\t\t\t\t\t\t\t\t/* time type information */\n"
  "\tcl_long\t\ttt_gmtoff;\t\t/* UTC offset in seconds */\n"
  "\tcl_int\t\ttt_isdst;\t\t/* used to set tm_isdst */\n"
  "\tcl_int\t\ttt_abbrind;\t\t/* abbreviation list index */\n"
  "\tcl_int\t\ttt_ttisstd;\t\t/* TRUE if transition is std time */\n"
  "\tcl_int\t\ttt_ttisgmt;\t\t/* TRUE if transition is UTC */\n"
  "};\n"
  "\n"
  "struct lsinfo\n"
  "{                               /* leap second information */\n"
  "    pg_time_t   ls_trans;       /* transition time */\n"
  "    long        ls_corr;        /* correction to apply */\n"
  "};\n"
  "\n"
  "struct state\n"
  "{\n"
  "\tcl_int\t\tleapcnt;\n"
  "\tcl_int\t\ttimecnt;\n"
  "\tcl_int\t\ttypecnt;\n"
  "\tcl_int\t\tcharcnt;\n"
  "\tcl_int\t\tgoback;\n"
  "\tcl_int\t\tgoahead;\n"
  "\t/* NOTE: pg_time_t has different meaning in GPU kernel */\n"
  "    cl_long\t\tats[TZ_MAX_TIMES];\n"
  "\tcl_uchar\ttypes[TZ_MAX_TIMES];\n"
  "\tstruct ttinfo ttis[TZ_MAX_TYPES];\n"
  "\tcl_char\t\tchars[BIGGEST(BIGGEST(TZ_MAX_CHARS + 1, 3 /* sizeof gmt */ ),\n"
  "\t\t\t\t\t\t\t  (2 * (TZ_STRLEN_MAX + 1)))];\n"
  "\tstruct lsinfo lsis[TZ_MAX_LEAPS];\n"
  "};\n"
  "\n"
  "struct pg_tz\n"
  "{\n"
  "\t/* TZname contains the canonically-cased name of the timezone */\n"
  "\tchar\t\t\tTZname[TZ_STRLEN_MAX + 1];\n"
  "\tstruct state\tstate;\n"
  "};\n"
  "\n"
  "STATIC_INLINE(void)\n"
  "assign_timelib_session_info(StringInfo buf)\n"
  "{\n"
  "\tconst struct state *sp;\n"
  "\tint\t\t\ti;\n"
  "\n"
  "\tappendStringInfo(\n"
  "\t\tbuf,\n"
  "\t\t\"#ifdef __CUDACC__\\n\"\n"
  "\t\t\"/* ================================================\\n\"\n"
  "\t\t\" * session information for cuda_timelib.h\\n\"\n"
  "\t\t\" * ================================================ */\\n\");\n"
  "\n"
  "\tsp = &session_timezone->state;\n"
  "\t/*\n"
  "\t * type declaration of tz_state structure\n"
  "\t */\n"
  "\tappendStringInfo(\n"
  "\t\tbuf,\n"
  "\t\t\"typedef struct {\\n\"\n"
  "\t\t\"        cl_long     ls_trans; /* pg_time_t in original */ \\n\"\n"
  "\t\t\"        long        ls_corr;\\n\"\n"
  "\t\t\"} tz_lsinfo;\\n\"\n"
  "\t\t\"\\n\"\n"
  "\t\t\"typedef struct {\\n\"\n"
  "\t\t\"        cl_long     tt_gmtoff;\\n\"\n"
  "\t\t\"        cl_int      tt_isdst;\\n\"\n"
  "\t\t\"        cl_int      tt_abbrind;\\n\"\n"
  "\t\t\"        cl_int      tt_ttisstd;\\n\"\n"
  "\t\t\"        cl_int      tt_ttisgmt;\\n\"\n"
  "\t\t\"} tz_ttinfo;\\n\"\n"
  "\t\t\"\\n\"\n"
  "\t\t\"typedef struct {\\n\"\n"
  "\t\t\"    cl_int          leapcnt;\\n\"\n"
  "\t\t\"    cl_int          timecnt;\\n\"\n"
  "\t\t\"    cl_int          typecnt;\\n\"\n"
  "\t\t\"    cl_int          charcnt;\\n\"\n"
  "\t\t\"    cl_int          goback;\\n\"\n"
  "\t\t\"    cl_int          goahead;\\n\"\n"
  "\t\t\"    cl_long         ats[%d];\\n\"\n"
  "\t\t\"    cl_uchar        types[%d];\\n\"\n"
  "\t\t\"    tz_ttinfo       ttis[%d];\\n\"\n"
  "\t\t\"    /* GPU kernel does not use chars[] */\\n\"\n"
  "\t\t\"    tz_lsinfo       lsis[%d];\\n\"\n"
  "\t\t\"} tz_state;\\n\"\n"
  "\t\t\"\\n\",\n"
  "\t\tsp->timecnt <= 0 ? 1 : sp->timecnt,\n"
  "\t\tsp->timecnt <= 0 ? 1 : sp->timecnt,\n"
  "\t\tsp->typecnt,\n"
  "\t\tsp->leapcnt <= 0 ? 1 : sp->leapcnt\n"
  "\t\t);\n"
  "\t/*\n"
  "\t * initializer of session_timezone_state\n"
  "\t */\n"
  "\tappendStringInfo(\n"
  "        buf,\n"
  "\t\t\"static const tz_state session_timezone_state =\\n\"\n"
  "\t\t\"{\\n\"\n"
  "\t\t\"    %d,    /* leapcnt */\\n\"\n"
  "\t\t\"    %d,    /* timecnt */\\n\"\n"
  "\t\t\"    %d,    /* typecnt */\\n\"\n"
  "\t\t\"    %d,    /* charcnt */\\n\"\n"
  "\t\t\"    %d,    /* goback */\\n\"\n"
  "\t\t\"    %d,    /* goahead */\\n\"\n"
  "\t\t\"    {      /* ats[] */\\n\",\n"
  "\t\tsp->leapcnt,\n"
  "\t\tsp->timecnt,\n"
  "\t\tsp->typecnt,\n"
  "\t\tsp->charcnt,\n"
  "\t\tsp->goback,\n"
  "\t\tsp->goahead);\n"
  "\n"
  "\tif (sp->timecnt <= 0)\n"
  "\t\tappendStringInfo(buf, \"        0\\n\");\n"
  "\telse \n"
  "\t{\n"
  "\t\tfor (i=0; i < sp->timecnt; i++)\n"
  "\t\t{\n"
  "\t\t\tappendStringInfo(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"        %ld,\\n\",\n"
  "\t\t\t\tsp->ats[i]);\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\tappendStringInfo(\n"
  "\t\tbuf,\n"
  "\t\t\"    },\\n\"\n"
  "\t\t\"    {    /* types[] */\");\n"
  "\n"
  "\tif (sp->timecnt <= 0)\n"
  "\t\tappendStringInfo(buf, \"\\n        0\");\n"
  "\telse \n"
  "\t{\n"
  "\t\tfor (i=0; i < sp->timecnt; i++)\n"
  "\t\t{\n"
  "\t\t\tif ((i % 12) == 0)\n"
  "\t\t\t\tappendStringInfo(buf, \"\\n       \");\n"
  "\t\t\tappendStringInfo(buf, \" %d,\", sp->types[i]);\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\tappendStringInfo(\n"
  "\t\tbuf,\n"
  "\t\t\"\\n\"\n"
  "\t\t\"    },\\n\"\n"
  "\t\t\"    {    /* ttis[] */\\n\");\n"
  "\n"
  "\tfor (i=0; i < sp->typecnt; i++)\n"
  "\t{\n"
  "\t\tappendStringInfo(\n"
  "\t\t\tbuf,\n"
  "\t\t\t\"        { %ld, %d, %d, %d, %d },\\n\",\n"
  "\t\t\tsp->ttis[i].tt_gmtoff,\n"
  "\t\t\tsp->ttis[i].tt_isdst,\n"
  "\t\t\tsp->ttis[i].tt_abbrind,\n"
  "\t\t\tsp->ttis[i].tt_ttisstd,\n"
  "\t\t\tsp->ttis[i].tt_ttisgmt);\n"
  "\t}\n"
  "\n"
  "\tappendStringInfo(\n"
  "\t\tbuf,\n"
  "\t\t\"    },\\n\"\n"
  "\t\t\"    {    /* lsis[] */\\n\");\n"
  "\n"
  "\tif (sp->leapcnt <= 0)\n"
  "\t\tappendStringInfo(buf, \"        { 0, 0 }\\n\");\n"
  "\telse \n"
  "\t{\n"
  "\t\tfor (i=0; i < sp->leapcnt; i++)\n"
  "\t\t{\n"
  "\t\t\tappendStringInfo(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"        { %ld, %ld },\\n\",\n"
  "\t\t\t\tsp->lsis[i].ls_trans,\n"
  "\t\t\t\tsp->lsis[i].ls_corr);\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\tappendStringInfo(\n"
  "\t\tbuf,\n"
  "\t\t\"    },\\n\"\n"
  "\t\t\"};\\n\");\n"
  "\n"
  "\tappendStringInfo(\n"
  "\t\tbuf,\n"
  "\t\t\"#endif /* __CUDACC__ */\\n\");\n"
  "}\n"
  "\n"
  "#endif\t/* __CUDACC__ */\n"
  "#endif\t/* CUDA_TIMELIB_H */\n"
;
