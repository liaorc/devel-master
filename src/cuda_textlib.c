const char *pgstrom_cuda_textlib_code =
  "/*\n"
  " * cuda_textlib.h\n"
  " *\n"
  " * Collection of text functions for OpenCL devices\n"
  " * --\n"
  " * Copyright 2011-2016 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014-2016 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef CUDA_TEXTLIB_H\n"
  "#define CUDA_TEXTLIB_H\n"
  "#ifdef __CUDACC__\n"
  "\n"
  "/* ----------------------------------------------------------------\n"
  " *\n"
  " * Basic Text comparison functions\n"
  " * \n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "STATIC_INLINE(cl_int)\n"
  "bpchar_truelen(struct varlena *arg)\n"
  "{\n"
  "\tcl_char\t   *s = VARDATA_ANY(arg);\n"
  "\tcl_int\t\ti, len;\n"
  "\n"
  "\tlen = VARSIZE_ANY_EXHDR(arg);\n"
  "\tfor (i = len - 1; i >= 0; i--)\n"
  "\t{\n"
  "\t\tif (s[i] != ' ')\n"
  "\t\t\tbreak;\n"
  "\t}\n"
  "\treturn i + 1;\n"
  "}\n"
  "\n"
  "#ifndef PG_BPCHAR_TYPE_DEFINED\n"
  "#define PG_BPCHAR_TYPE_DEFINED\n"
  "STROMCL_VARLENA_DATATYPE_TEMPLATE(bpchar)\n"
  "STROMCL_VARLENA_VARREF_TEMPLATE(bpchar)\n"
  "STROMCL_VARLENA_VARSTORE_TEMPLATE(bpchar)\n"
  "STROMCL_VARLENA_PARAMREF_TEMPLATE(bpchar)\n"
  "STROMCL_VARLENA_NULLTEST_TEMPLATE(bpchar)\n"
  "/* pg_bpchar_comp_crc32 has to be defined with own way */\n"
  "STATIC_FUNCTION(cl_uint)\n"
  "pg_bpchar_comp_crc32(const cl_uint *crc32_table,\n"
  "\t\t\t\t\t cl_uint hash, pg_bpchar_t datum)\n"
  "{\n"
  "\tif (!datum.isnull)\n"
  "\t{\n"
  "\t\thash = pg_common_comp_crc32(crc32_table, hash,\n"
  "\t\t\t\t\t\t\t\t\tVARDATA_ANY(datum.value),\n"
  "\t\t\t\t\t\t\t\t\tbpchar_truelen(datum.value));\n"
  "\t}\n"
  "\treturn hash;\n"
  "}\n"
  "#endif\n"
  "\n"
  "STATIC_FUNCTION(cl_int)\n"
  "bpchar_compare(kern_context *kcxt, varlena *arg1, varlena *arg2)\n"
  "{\n"
  "\tcl_char\t   *s1 = VARDATA_ANY(arg1);\n"
  "\tcl_char\t   *s2 = VARDATA_ANY(arg2);\n"
  "\tcl_int\t\tlen1 = bpchar_truelen(arg1);\n"
  "\tcl_int\t\tlen2 = bpchar_truelen(arg2);\n"
  "\tcl_int\t\tlen = min(len1, len2);\n"
  "\n"
  "\twhile (len > 0)\n"
  "\t{\n"
  "\t\tif (*s1 < *s2)\n"
  "\t\t\treturn -1;\n"
  "\t\tif (*s1 > *s2)\n"
  "\t\t\treturn 1;\n"
  "\t\ts1++;\n"
  "\t\ts2++;\n"
  "\t\tlen--;\n"
  "\t}\n"
  "\tif (len1 != len2)\n"
  "\t\treturn (len1 > len2 ? 1 : -1);\n"
  "\treturn 0;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_bpchareq(kern_context *kcxt, pg_bpchar_t arg1, pg_bpchar_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(bpchar_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ2.value) == 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_bpcharne(kern_context *kcxt, pg_bpchar_t arg1, pg_bpchar_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(bpchar_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ2.value) != 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_bpcharlt(kern_context *kcxt, pg_bpchar_t arg1, pg_bpchar_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(bpchar_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ2.value) < 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_bpcharle(kern_context *kcxt, pg_bpchar_t arg1, pg_bpchar_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(bpchar_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ2.value) <= 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_bpchargt(kern_context *kcxt, pg_bpchar_t arg1, pg_bpchar_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(bpchar_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ2.value) > 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_bpcharge(kern_context *kcxt, pg_bpchar_t arg1, pg_bpchar_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(bpchar_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\targ2.value) >= 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_bpcharcmp(kern_context *kcxt, pg_bpchar_t arg1, pg_bpchar_t arg2)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = bpchar_compare(kcxt, arg1.value, arg2.value);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_bpcharlen(kern_context *kcxt, pg_bpchar_t arg1)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\t/* NOTE: At this moment, we don't support any special encodings,\n"
  "\t * so no multibytes character is assumed.\n"
  "\t */\n"
  "\tresult.isnull = arg1.isnull;\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = bpchar_truelen(arg1.value);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/* ----------------------------------------------------------------\n"
  " *\n"
  " * Basic Text comparison functions\n"
  " * \n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "#ifndef PG_TEXT_TYPE_DEFINED\n"
  "#define PG_TEXT_TYPE_DEFINED\n"
  "STROMCL_VARLENA_TYPE_TEMPLATE(text)\n"
  "#endif\n"
  "\n"
  "STATIC_FUNCTION(cl_int)\n"
  "text_compare(kern_context *kcxt, varlena *arg1, varlena *arg2)\n"
  "{\n"
  "\tcl_char\t   *s1 = VARDATA_ANY(arg1);\n"
  "\tcl_char\t   *s2 = VARDATA_ANY(arg2);\n"
  "\tcl_int\t\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n"
  "\tcl_int\t\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n"
  "\tcl_int\t\tlen = min(len1, len2);\n"
  "\n"
  "\twhile (len > 0)\n"
  "\t{\n"
  "\t\tif (*s1 < *s2)\n"
  "\t\t\treturn -1;\n"
  "\t\tif (*s1 > *s2)\n"
  "\t\t\treturn 1;\n"
  "\n"
  "\t\ts1++;\n"
  "\t\ts2++;\n"
  "\t\tlen--;\n"
  "\t}\n"
  "\tif (len1 != len2)\n"
  "\t\treturn (len1 > len2 ? 1 : -1);\n"
  "\treturn 0;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_texteq(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(text_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg2.value) == 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_textne(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(text_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg2.value) != 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_text_lt(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(text_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg2.value) < 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_text_le(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(text_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg2.value) <= 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_text_gt(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(text_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg2.value) > 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_text_ge(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = (cl_bool)(text_compare(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg1.value,\n"
  "\t\t\t\t\t\t\t\t\t\t\t  arg2.value) >= 0);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_text_cmp(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\tresult.isnull = (arg1.isnull | arg2.isnull);\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = text_compare(kcxt, arg1.value, arg2.value);\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_int4_t)\n"
  "pgfn_textlen(kern_context *kcxt, pg_text_t arg1)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\t/* NOTE: At this moment, we don't support any special encodings,\n"
  "\t * so no multibytes character is assumed.\n"
  "\t */\n"
  "\tresult.isnull = arg1.isnull;\n"
  "\tif (!result.isnull)\n"
  "\t\tresult.value = toast_raw_datum_size(kcxt, arg1.value) - VARHDRSZ;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * varchar(*) type definition\n"
  " */\n"
  "#ifndef PG_VARCHAR_TYPE_DEFINED\n"
  "#define PG_VARCHAR_TYPE_DEFINED\n"
  "STROMCL_VARLENA_TYPE_TEMPLATE(varchar)\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * Support for LIKE operator\n"
  " */\n"
  "#define LIKE_TRUE\t\t\t\t1\n"
  "#define LIKE_FALSE\t\t\t\t0\n"
  "#define LIKE_ABORT\t\t\t\t(-1)\n"
  "\n"
  "#define GetCharNormal(t)\t\t(t)\n"
  "STATIC_INLINE(cl_char)\n"
  "GetCharLowerCase(cl_char c)\n"
  "{\n"
  "\treturn (c >= 'A' && c <= 'Z') ? c + ('a' - 'A') : c;\n"
  "}\n"
  "\n"
  "#define NextByte(p, plen)\t\t\\\n"
  "\tdo { (p)++; (plen)--; } while(0)\n"
  "#define NextChar(p, plen)\t\t\\\n"
  "\tdo { int __l = pg_wchar_mblen(p); (p) += __l; (plen) -= __l; } while(0)\n"
  "\n"
  "#define RECURSIVE_RETURN(__retcode)\t\t\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (depth == 0)\t\t\t\t\t\t\\\n"
  "\t\t\treturn (__retcode);\t\t\t\t\\\n"
  "\t\tretcode = (__retcode);\t\t\t\t\\\n"
  "\t\tgoto recursive_return;\t\t\t\t\\\n"
  "\t} while(0)\n"
  "#define VIRTUAL_STACK_MAX_DEPTH\t\t8\n"
  "\n"
  "\n"
  "#define GENERIC_MATCH_TEXT_TEMPLATE(FUNCNAME, GETCHAR)\t\t\t\t\t\\\n"
  "\tSTATIC_FUNCTION(cl_int)\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tFUNCNAME(kern_context *kcxt,\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t char *t, int tlen,\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t char *p, int plen,\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t int depth)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_int\t\tretcode;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tstruct {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tchar   *__t;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tchar   *__p;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tint\t\t__tlen;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tint\t\t__plen;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t} vstack[VIRTUAL_STACK_MAX_DEPTH];\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\trecursive_entry:\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* Fast path for match-everything pattern */\t\t\t\t\t\\\n"
  "\t\tif (plen == 1 && *p == '%')\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tRECURSIVE_RETURN(LIKE_TRUE);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t * In this loop, we advance by char when matching wildcards\t\t\\\n"
  "\t\t * (and thus on recursive entry to this function we are\t\t\t\\\n"
  "\t\t * properly char-synced). On other occasions it is safe to\t\t\\\n"
  "\t\t * advance by byte,as the text and pattern will be in lockstep.\t\\\n"
  "\t\t * This allows us to perform all comparisons between the text\t\\\n"
  "\t\t * and pattern on a byte by byte basis, even for multi-byte\t\t\\\n"
  "\t\t * encodings.\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\twhile (tlen > 0 && plen > 0)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (*p == '\\\\')\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/* Next pattern byte must match literally,\t\t\t\t\\\n"
  "\t\t\t\t * whatever it is */\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tNextByte(p, plen);\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/* ... and there had better be one, per SQL standard */\t\\\n"
  "\t\t\t\tif (plen <= 0)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\t\\\n"
  "\t\t\t\t\treturn LIKE_ABORT;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (GETCHAR(*p) != GETCHAR(*t))\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tRECURSIVE_RETURN(LIKE_FALSE);\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\telse if (*p == '%')\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tchar\t\tfirstpat;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * % processing is essentially a search for a text\t\t\\\n"
  "\t\t\t\t * position at which the remainder of the text matches\t\\\n"
  "\t\t\t\t * the remainder of the pattern, using a recursive call\t\\\n"
  "\t\t\t\t * to check each potential match.\t\t\t\t\t\t\\\n"
  "\t\t\t\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * If there are wildcards immediately following the %,\t\\\n"
  "\t\t\t\t * we can skip over them first, using the idea that any\t\\\n"
  "\t\t\t\t * sequence of N _\\'s and one or more %\\'s is equivalent \\\n"
  "\t\t\t\t * to N\\'s and one % (ie, it will match any sequence of\t\\\n"
  "\t\t\t\t * at least N text characters).  In this way we will\t\\\n"
  "\t\t\t\t * always run the recursive search loop using a pattern \\\n"
  "\t\t\t\t * fragment that begins with a literal character-to-match, \\\n"
  "\t\t\t\t * thereby not recursing more than we have to.\t\t\t\\\n"
  "\t\t\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tNextByte(p, plen);\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\twhile (plen > 0)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tif (*p == '%')\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tNextByte(p, plen);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\telse if (*p == '_')\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t/* If not enough text left to match\t\t\t\t\\\n"
  "\t\t\t\t\t\t * the pattern ABORT */\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tif (tlen <= 0)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\tRECURSIVE_RETURN(LIKE_ABORT);\t\t\t\t\\\n"
  "\t\t\t\t\t\tNextChar(t, tlen);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tNextByte(p, plen);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tbreak;\t/* Reached a non-wildcard pattern char */ \\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * If we are at end of pattern, match: we have\t\t\t\\\n"
  "\t\t\t\t * a trailing % which matches any remaining text string. \\\n"
  "\t\t\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (plen <= 0)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tRECURSIVE_RETURN(LIKE_TRUE);\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * Otherwise, scan for a text position at which we can\t\\\n"
  "\t\t\t\t * match the rest of the pattern.  The first remaining\t\\\n"
  "\t\t\t\t * pattern char is known to be a regular or escaped\t\t\\\n"
  "\t\t\t\t * literal character, so we can compare the first\t\t\\\n"
  "\t\t\t\t * pattern byte to each text byte to avoid recursing\t\\\n"
  "\t\t\t\t * more than we have to.\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * This fact also guarantees that we don\\'t have to\t\t\\\n"
  "\t\t\t\t * consider\ta match to the zero-length substring at\t\t\\\n"
  "\t\t\t\t * the end of the text.\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * text.\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tif (*p == '\\\\')\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tif (plen < 0)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tSTROM_SET_ERROR(&kcxt->e,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\tStromError_CpuReCheck);\t\t\t\\\n"
  "\t\t\t\t\t\treturn LIKE_ABORT;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tfirstpat = GETCHAR(p[1]);\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tfirstpat = GETCHAR(*p);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\twhile (tlen > 0)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tif (GETCHAR(*t) == firstpat)\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tif (depth >= VIRTUAL_STACK_MAX_DEPTH)\t\t\t\\\n"
  "\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\tSTROM_SET_ERROR(&kcxt->e,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\tStromError_CpuReCheck);\t\t\\\n"
  "\t\t\t\t\t\t\treturn LIKE_ABORT;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t/* push values */\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tvstack[depth].__t = t;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tvstack[depth].__p = p;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tvstack[depth].__tlen = tlen;\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tvstack[depth].__plen = plen;\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tdepth++;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tgoto recursive_entry;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\trecursive_return:\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tdepth--;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tif (retcode != LIKE_FALSE)\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\tRECURSIVE_RETURN(retcode);\t/* TRUE or ABORT */\t\\\n"
  "\t\t\t\t\t\t/* pop values */\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tt = vstack[depth].__t;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tp = vstack[depth].__p;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\ttlen = vstack[depth].__tlen;\t\t\t\t\t\\\n"
  "\t\t\t\t\t\tplen = vstack[depth].__plen;\t\t\t\t\t\\\n"
  "\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\tNextChar(t, tlen);\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t * End of text with no match, so no point in trying \\\n"
  "\t\t\t\t * later places to start matching this pattern.\t\t\t\t\\\n"
  "\t\t\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tRECURSIVE_RETURN(LIKE_ABORT);\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\telse if (*p == '_')\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t/* _ matches any single character */\t\t\t\t\t\\\n"
  "\t\t\t\tNextChar(t, tlen);\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tNextByte(p, plen);\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tcontinue;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\telse if (GETCHAR(*p) != GETCHAR(*t))\t\t\t\t\t\t\\\n"
  "\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tRECURSIVE_RETURN(LIKE_FALSE);\t\t\t\t\t\t\t\\\n"
  "\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t * Pattern and text match, so advance.\t\t\t\t\t\t\\\n"
  "\t\t\t *\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t * It is safe to use NextByte instead of NextChar here,\t\t\\\n"
  "\t\t\t * even for multi-byte character sets, because we are not\t\\\n"
  "\t\t\t * following immediately after a wildcard character. If we\t\\\n"
  "\t\t\t * are in the middle of a multibyte character, we must already \\\n"
  "\t\t\t * have matched at least one byte of the character from both \\\n"
  "\t\t\t * text and pattern; so we cannot get out-of-sync on character \\\n"
  "\t\t\t * boundaries.  And we know that no backend-legal encoding\t\\\n"
  "\t\t\t * allows ASCII characters such as \\'%\\' to appear as non-first\t\\\n"
  "\t\t\t bytes of characters, so we won\\'t mistakenly detect a new\t\\\n"
  "\t\t\t * wildcard.\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tNextByte(t, tlen);\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tNextByte(p, plen);\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (tlen > 0)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tRECURSIVE_RETURN(LIKE_FALSE);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t * End of text, but perhaps not of pattern.  Match iff the\t\t\\\n"
  "\t\t * remaining pattern can match a zero-length string, ie, it\\'s\t\\\n"
  "\t\t * zero or more %\\'s.\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\twhile (plen > 0 && *p == '%')\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tNextByte(p, plen);\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (plen <= 0)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tRECURSIVE_RETURN(LIKE_TRUE);\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t * End of text with no match, so no point in trying later\t\t\\\n"
  "\t\t * places to start matching this pattern.\t\t\t\t\t\t\\\n"
  "\t\t */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tRECURSIVE_RETURN(LIKE_ABORT);\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "GENERIC_MATCH_TEXT_TEMPLATE(GenericMatchText, GetCharNormal)\n"
  "GENERIC_MATCH_TEXT_TEMPLATE(GenericCaseMatchText, GetCharLowerCase)\n"
  "\n"
  "#undef GetCharNormal\n"
  "#undef GetCharLowerCase\n"
  "#undef NextByte\n"
  "#undef NextChar\n"
  "#undef RECURSIVE_RETURN\n"
  "#undef VIRTUAL_STACK_MAX_DEPTH\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_textlike(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = arg1.isnull | arg2.isnull;\n"
  "\tif (!result.isnull)\n"
  "\t{\n"
  "\t\tchar\t   *s = VARDATA_ANY(arg1.value);\n"
  "\t\tchar\t   *p = VARDATA_ANY(arg2.value);\n"
  "\t\tcl_uint\t\tslen = VARSIZE_ANY_EXHDR(arg1.value);\n"
  "\t\tcl_uint\t\tplen = VARSIZE_ANY_EXHDR(arg2.value);\n"
  "\n"
  "\t\tresult.value = (GenericMatchText(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t s, slen,\n"
  "\t\t\t\t\t\t\t\t\t\t p, plen, 0) == LIKE_TRUE);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_textnlike(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = arg1.isnull | arg2.isnull;\n"
  "\tif (!result.isnull)\n"
  "\t{\n"
  "\t\tchar\t   *s = VARDATA_ANY(arg1.value);\n"
  "\t\tchar\t   *p = VARDATA_ANY(arg2.value);\n"
  "\t\tcl_uint\t\tslen = VARSIZE_ANY_EXHDR(arg1.value);\n"
  "\t\tcl_uint\t\tplen = VARSIZE_ANY_EXHDR(arg2.value);\n"
  "\n"
  "\t\tresult.value = (GenericMatchText(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t s, slen,\n"
  "\t\t\t\t\t\t\t\t\t\t p, plen, 0) != LIKE_TRUE);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_texticlike(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = arg1.isnull | arg2.isnull;\n"
  "\tif (!result.isnull)\n"
  "\t{\n"
  "\t\tchar\t   *s = VARDATA_ANY(arg1.value);\n"
  "\t\tchar\t   *p = VARDATA_ANY(arg2.value);\n"
  "\t\tcl_uint\t\tslen = VARSIZE_ANY_EXHDR(arg1.value);\n"
  "\t\tcl_uint\t\tplen = VARSIZE_ANY_EXHDR(arg2.value);\n"
  "\n"
  "\t\tresult.value = (GenericCaseMatchText(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t s, slen,\n"
  "\t\t\t\t\t\t\t\t\t\t\t p, plen, 0) == LIKE_TRUE);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_bool_t)\n"
  "pgfn_texticnlike(kern_context *kcxt, pg_text_t arg1, pg_text_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = arg1.isnull | arg2.isnull;\n"
  "\tif (!result.isnull)\n"
  "\t{\n"
  "\t\tchar\t   *s = VARDATA_ANY(arg1.value);\n"
  "\t\tchar\t   *p = VARDATA_ANY(arg2.value);\n"
  "\t\tcl_uint\t\tslen = VARSIZE_ANY_EXHDR(arg1.value);\n"
  "\t\tcl_uint\t\tplen = VARSIZE_ANY_EXHDR(arg2.value);\n"
  "\n"
  "\t\tresult.value = (GenericCaseMatchText(kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t s, slen,\n"
  "\t\t\t\t\t\t\t\t\t\t\t p, plen, 0) != LIKE_TRUE);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "#undef LIKE_TRUE\n"
  "#undef LIKE_FALSE\n"
  "#undef LIKE_ABORT\n"
  "\n"
  "\n"
  "\n"
  "#else\t/* __CUDACC__ */\n"
  "#include \"mb/pg_wchar.h\"\n"
  "\n"
  "STATIC_INLINE(void)\n"
  "assign_textlib_session_info(StringInfo buf)\n"
  "{\n"
  "\t/*\n"
  "\t * Put encoding aware character length function\n"
  "\t */\n"
  "\tappendStringInfoString(\n"
  "\t\tbuf,\n"
  "\t\t\"STATIC_INLINE(cl_int)\\n\"\n"
  "\t\t\"pg_wchar_mblen(const char *str)\\n\"\n"
  "\t\t\"{\\n\");\n"
  "\n"
  "\tswitch (GetDatabaseEncoding())\n"
  "\t{\n"
  "\t\tcase PG_EUC_JP:\t\t/* logic in pg_euc_mblen() */\n"
  "\t\tcase PG_EUC_KR:\n"
  "\t\tcase PG_EUC_TW:\t\t/* logic in pg_euctw_mblen(), but identical */\n"
  "\t\tcase PG_EUC_JIS_2004:\n"
  "\t\tcase PG_JOHAB:\t\t/* logic in pg_johab_mblen(), but identical */\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  cl_uchar c = *((const cl_uchar *)str);\\n\"\n"
  "\t\t\t\t\"  if (c == 0x8e)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  else if (c == 0x8f)\\n\"\n"
  "\t\t\t\t\"    return 3;\\n\"\n"
  "\t\t\t\t\"  else if (c & 0x80)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  return 1;\\n\");\n"
  "\t\t\tbreak;\n"
  "\n"
  "\t\tcase PG_EUC_CN:\t\t/* logic in pg_euccn_mblen */\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  cl_uchar c = *((const cl_uchar *)str);\\n\"\n"
  "\t\t\t\t\"  if (c & 0x80)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  return 1;\\n\");\n"
  "\t\t\tbreak;\n"
  "\n"
  "\t\tcase PG_UTF8:\t\t/* logic in pg_utf_mblen */\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  cl_uchar c = *((const cl_uchar *)str);\\n\"\n"
  "\t\t\t\t\"  if ((c & 0x80) == 0)\\n\"\n"
  "\t\t\t\t\"    return 1;\\n\"\n"
  "\t\t\t\t\"  else if ((c & 0xe0) == 0xc0)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  else if ((c & 0xf0) == 0xe0)\\n\"\n"
  "\t\t\t\t\"    return 3;\\n\"\n"
  "\t\t\t\t\"  else if ((c & 0xf8) == 0xf0)\\n\"\n"
  "\t\t\t\t\"    return 4;\\n\"\n"
  "\t\t\t\t\"#ifdef NOT_USED\\n\"\n"
  "\t\t\t\t\"  else if ((c & 0xfc) == 0xf8)\\n\"\n"
  "\t\t\t\t\"    return 5;\\n\"\n"
  "\t\t\t\t\"  else if ((c & 0xfe) == 0xfc)\\n\"\n"
  "\t\t\t\t\"    return 6;\\n\"\n"
  "\t\t\t\t\"#endif\\n\"\n"
  "\t\t\t\t\"  return 1;\\n\");\n"
  "\t\t\tbreak;\n"
  "\n"
  "\t\tcase PG_MULE_INTERNAL:\t/* logic in pg_mule_mblen */\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  cl_uchar c = *((const cl_uchar *)str);\\n\"\n"
  "\t\t\t\t\"  if (c >= 0x81 && c <= 0x8d)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  else if (c == 0x9a || c == 0x9b)\\n\"\n"
  "\t\t\t\t\"    return 3;\\n\"\n"
  "\t\t\t\t\"  else if (c >= 0x90 && c <= 0x99)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  else if (c == 0x9c || c == 0x9d)\\n\"\n"
  "\t\t\t\t\"    return 4;\\n\"\n"
  "\t\t\t\t\"  return 1;\\n\");\n"
  "\t\t\tbreak;\n"
  "\n"
  "\t\tcase PG_SJIS:\t/* logic in pg_sjis_mblen */\n"
  "\t\tcase PG_SHIFT_JIS_2004:\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  cl_uchar c = *((const cl_uchar *)str);\\n\"\n"
  "\t\t\t\t\"  if (c >= 0xa1 && c <= 0xdf)\\n\"\n"
  "\t\t\t\t\"    return 1;\t/* 1byte kana? */\\n\"\n"
  "\t\t\t\t\"  else if (c & 0x80)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  return 1;\\n\");\n"
  "\t\t\tbreak;\n"
  "\n"
  "\t\tcase PG_BIG5:\t/* logic in pg_big5_mblen */\n"
  "\t\tcase PG_GBK:\t/* logic in pg_gbk_mblen, but identical */\n"
  "\t\tcase PG_UHC:\t/* logic in pg_uhc_mblen, but identical */\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  cl_uchar c = *((const cl_uchar *)str);\\n\"\n"
  "\t\t\t\t\"  if (c & 0x80)\\n\"\n"
  "\t\t\t\t\"    return 2;\\n\"\n"
  "\t\t\t\t\"  return 1;\\n\");\n"
  "\t\t\tbreak;\n"
  "\n"
  "\t\tcase PG_GB18030:/* logic in pg_gb18030_mblen */\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  cl_uchar c1 = *((const cl_uchar *)str);\\n\"\n"
  "\t\t\t\t\"  cl_uchar c2;\\n\"\n"
  "\t\t\t\t\"  if ((c & 0x80) == 0)\\n\"\n"
  "\t\t\t\t\"    return 1; /* ASCII */\\n\"\n"
  "\t\t\t\t\"  c2 = *((const cl_uchar *)(str + 1));\\n\"\n"
  "\t\t\t\t\"  if (c2 >= 0x30 && c2 <= 0x39)\\n\"\n"
  "\t\t\t\t\"    return 4;\\n\"\n"
  "\t\t\t\t\"  return 2;\\n\");\n"
  "\t\t\tbreak;\n"
  "\n"
  "\t\tdefault:\t/* encoding with maxlen==1 */\n"
  "\t\t\tif (pg_database_encoding_max_length() != 1)\n"
  "\t\t\t\telog(ERROR, \"Bug? unsupported database encoding: %s\",\n"
  "\t\t\t\t\t GetDatabaseEncodingName());\n"
  "\t\t\tappendStringInfoString(\n"
  "\t\t\t\tbuf,\n"
  "\t\t\t\t\"  return 1;\\n\");\n"
  "\t\t\tbreak;\n"
  "\t}\n"
  "\tappendStringInfoString(\n"
  "\t\tbuf,\n"
  "\t\t\"}\\n\\n\");\n"
  "}\n"
  "\n"
  "#endif\t/* __CUDACC__ */\n"
  "#endif\t/* CUDA_TEXTLIB_H */\n"
;
