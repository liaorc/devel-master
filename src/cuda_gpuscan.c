const char *pgstrom_cuda_gpuscan_code =
  "/*\n"
  " * cuda_gpuscan.h\n"
  " *\n"
  " * CUDA device code specific to GpuScan logic\n"
  " * --\n"
  " * Copyright 2011-2016 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014-2016 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef CUDA_GPUSCAN_H\n"
  "#define CUDA_GPUSCAN_H\n"
  "\n"
  "/*\n"
  " * Sequential Scan using GPU/MIC acceleration\n"
  " *\n"
  " * It packs a kern_parambuf and kern_resultbuf structure within a continuous\n"
  " * memory ares, to transfer (usually) small chunk by one DMA call.\n"
  " *\n"
  " * +----------------+       -----\n"
  " * | kern_parambuf  |         ^\n"
  " * | +--------------+         |\n"
  " * | | length   o--------------------+\n"
  " * | +--------------+         |      | kern_vrelation is located just after\n"
  " * | | nparams      |         |      | the kern_parambuf (because of DMA\n"
  " * | +--------------+         |      | optimization), so head address of\n"
  " * | | poffset[0]   |         |      | kern_gpuscan + parambuf.length\n"
  " * | | poffset[1]   |         |      | points kern_resultbuf.\n"
  " * | |    :         |         |      |\n"
  " * | | poffset[M-1] |         |      |\n"
  " * | +--------------+         |      |\n"
  " * | | variable     |         |      |\n"
  " * | | length field |         |      |\n"
  " * | | for Param /  |         |      |\n"
  " * | | Const values |         |      |\n"
  " * | |     :        |         |      |\n"
  " * +-+--------------+  -----  |  <---+\n"
  " * | kern_resultbuf |    ^    |\n"
  " * | +--------------+    |    |  Area to be sent to OpenCL device.\n"
  " * | | nrels (=1)   |    |    |  Forward DMA shall be issued here.\n"
  " * | +--------------+    |    |\n"
  " * | | nitems       |    |    |\n"
  " * | +--------------+    |    |\n"
  " * | | nrooms (=N)  |    |    |\n"
  " * | +--------------+    |    |\n"
  " * | | errcode      |    |    V\n"
  " * | +--------------+    |  -----\n"
  " * | | rindex[0]    |    |\n"
  " * | | rindex[1]    |    |  Area to be written back from OpenCL device.\n"
  " * | |     :        |    |  Reverse DMA shall be issued here.\n"
  " * | | rindex[N-1]  |    V\n"
  " * +-+--------------+  -----\n"
  " *\n"
  " * Gpuscan kernel code assumes all the fields shall be initialized to zero.\n"
  " */\n"
  "typedef struct {\n"
  "\tkern_errorbuf\tkerror;\n"
  "\tkern_parambuf\tkparams;\n"
  "} kern_gpuscan;\n"
  "\n"
  "#define KERN_GPUSCAN_PARAMBUF(kgpuscan)\t\t\t\\\n"
  "\t((kern_parambuf *)(&(kgpuscan)->kparams))\n"
  "#define KERN_GPUSCAN_PARAMBUF_LENGTH(kgpuscan)\t\\\n"
  "\tSTROMALIGN((kgpuscan)->kparams.length)\n"
  "#define KERN_GPUSCAN_RESULTBUF(kgpuscan)\t\t\\\n"
  "\t((kern_resultbuf *)((char *)&(kgpuscan)->kparams +\t\t\t\t\\\n"
  "\t\t\t\t\t\tSTROMALIGN((kgpuscan)->kparams.length)))\n"
  "#define KERN_GPUSCAN_RESULTBUF_LENGTH(kgpuscan)\t\\\n"
  "\tSTROMALIGN(offsetof(kern_resultbuf,\t\t\t\\\n"
  "\t\tresults[KERN_GPUSCAN_RESULTBUF(kgpuscan)->nrels * \\\n"
  "\t\t\t\tKERN_GPUSCAN_RESULTBUF(kgpuscan)->nrooms]))\n"
  "#define KERN_GPUSCAN_LENGTH(kgpuscan)\t\t\t\\\n"
  "\t(offsetof(kern_gpuscan, kparams) +\t\t\t\\\n"
  "\t KERN_GPUSCAN_PARAMBUF_LENGTH(kgpuscan) +\t\\\n"
  "\t KERN_GPUSCAN_RESULTBUF_LENGTH(kgpuscan))\n"
  "#define KERN_GPUSCAN_DMASEND_OFFSET(kgpuscan)\t0\n"
  "#define KERN_GPUSCAN_DMASEND_LENGTH(kgpuscan)\t\\\n"
  "\t(KERN_GPUSCAN_PARAMBUF_LENGTH(kgpuscan) +\t\\\n"
  "\t offsetof(kern_resultbuf, results[0]))\n"
  "#define KERN_GPUSCAN_DMARECV_OFFSET(kgpuscan)\t0\n"
  "#define KERN_GPUSCAN_DMARECV_LENGTH(kgpuscan, nitems)\t\\\n"
  "\t(KERN_GPUSCAN_PARAMBUF_LENGTH(kgpuscan) +\t\t\t\\\n"
  "\t offsetof(kern_resultbuf, results[(nitems)]))\n"
  "\n"
  "#ifdef __CUDACC__\n"
  "/*\n"
  " * forward declaration of the function to be generated on the fly\n"
  " */\n"
  "STATIC_FUNCTION(cl_bool)\n"
  "gpuscan_quals_eval(kern_context *kcxt,\n"
  "\t\t\t\t   kern_data_store *kds,\n"
  "\t\t\t\t   size_t kds_index);\n"
  "\n"
  "/*\n"
  " * forward declaration of the function to be generated on the fly\n"
  " */\n"
  "STATIC_FUNCTION(void)\n"
  "gpuscan_projection(kern_context *kcxt,\n"
  "\t\t\t\t   kern_data_store *kds_src,\n"
  "\t\t\t\t   kern_tupitem *tupitem,\n"
  "\t\t\t\t   kern_data_store *kds_dst,\n"
  "\t\t\t\t   cl_uint dst_nitems,\n"
  "\t\t\t\t   Datum *tup_values,\n"
  "\t\t\t\t   cl_bool *tup_isnull,\n"
  "\t\t\t\t   cl_bool *tup_internal);\n"
  "\n"
  "#ifdef 0\n"
  "/*\n"
  " * kernel entrypoint of gpuscan\n"
  " */\n"
  "KERNEL_FUNCTION(void)\n"
  "gpuscan_exec_quals(kern_gpuscan *kgpuscan,\n"
  "\t\t\t\t   kern_data_store *kds_src)\n"
  "{\n"
  "\tkern_parambuf  *kparams = KERN_GPUSCAN_PARAMBUF(kgpuscan);\n"
  "\tkern_resultbuf *kresults = KERN_GPUSCAN_RESULTBUF(kgpuscan);\n"
  "\tkern_context\tkcxt;\n"
  "\tsize_t\t\t\tkds_index = get_global_id();\n"
  "\tcl_bool\t\t\trc;\n"
  "\tcl_uint\t\t\toffset;\n"
  "\tcl_uint\t\t\tcount;\n"
  "\t__shared__ cl_uint base;\n"
  "\n"
  "\t/* sanity checks */\n"
  "\tassert(kds_src->format == KDS_FORMAT_ROW);\n"
  "\tassert(!kresults->all_visible);\n"
  "\n"
  "\tINIT_KERNEL_CONTEXT(&kcxt,gpuscan_exec_quals,kparams);\n"
  "\n"
  "\t/* evaluate device qualifier */\n"
  "\tif (kds_index < kds_src->nitems)\n"
  "\t\trc = gpuscan_quals_eval(&kcxt, kds_src, kds_index);\n"
  "\telse\n"
  "\t\trc = false;\n"
  "\n"
  "\t/* expand kresults buffer */\n"
  "\toffset = pgstromStairlikeSum(rc ? 1 : 0, &count);\n"
  "\n"
  "\n"
  "\tif (count > 0)\n"
  "\t{\n"
  "\t\tif (get_local_id() == 0)\n"
  "\t\t\tbase = atomicAdd(&kresults->nitems, count);\n"
  "\t\t__syncthreads();\n"
  "\n"
  "\t\tif (base + count > kresults->nrooms)\n"
  "\t\t{\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt.e, StromError_DataStoreNoSpace);\n"
  "\t\t\tgoto out;\n"
  "\t\t}\n"
  "\t\telse if (rc)\n"
  "\t\t{\n"
  "\t\t\t/* OK, store the result */\n"
  "\t\t\tkresults->results[base + offset] = (cl_uint)\n"
  "\t\t\t\t((char *)KERN_DATA_STORE_TUPITEM(kds_src, kds_index) -\n"
  "\t\t\t\t (char *)kds_src);\n"
  "\t\t}\n"
  "\t}\n"
  "\t__syncthreads();\n"
  "out:\n"
  "\t/* write back error status if any */\n"
  "\tkern_writeback_error_status(&kgpuscan->kerror, kcxt.e);\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * kernel entrypoint of gpuscan\n"
  " */\n"
  "KERNEL_FUNCTION(void)\n"
  "gpuscan_exec_quals(kern_gpuscan *kgpuscan,\n"
  "\t\t\t\t   kern_data_store *kds_src)\n"
  "{\n"
  "\tkern_parambuf  *kparams = KERN_GPUSCAN_PARAMBUF(kgpuscan);\n"
  "\tkern_resultbuf *kresults = KERN_GPUSCAN_RESULTBUF(kgpuscan);\n"
  "\tkern_context\tkcxt;\n"
  "\tsize_t\t\t\tkds_index = get_global_id();\n"
  "\tcl_bool\t\t\trc;\n"
  "\tcl_uint\t\t\toffset;\n"
  "\tcl_uint\t\t\tcount;\n"
  "\t__shared__ cl_uint base;\n"
  "\n"
  "\t/**** lrc ***/\n"
  "\tsize_t\t\t\tkds_index_1 = kds_index * 2;\n"
  "\tsize_t\t\t\tkds_index_2 = kds_index * 2 + 1;\n"
  "\tcl_bool\t\t\trc_1;\n"
  "\tcl_bool\t\t\trc_2;\n"
  "\n"
  "\t/* sanity checks */\n"
  "\tassert(kds_src->format == KDS_FORMAT_ROW);\n"
  "\tassert(!kresults->all_visible);\n"
  "\n"
  "\tINIT_KERNEL_CONTEXT(&kcxt,gpuscan_exec_quals,kparams);\n"
  "\n"
  "\t/* evaluate device qualifier */\n"
  "\t/**** lrc ***/\n"
  "\tif (kds_index_1 < kds_src->nitems)\n"
  "\t\trc_1 = gpuscan_quals_eval(&kcxt, kds_src, kds_index_1);\n"
  "\telse\n"
  "\t\trc_1 = false;\n"
  "\tif (kds_index_2 < kds_src->nitems)\n"
  "\t\trc_2 = gpuscan_quals_eval(&kcxt, kds_src, kds_index_2);\n"
  "\telse\n"
  "\t\trc_2 = false;\n"
  "\n"
  "\t/* expand kresults buffer */\n"
  "\toffset = pgstromStairlikeSum(rc ? 1 : 0, &count);\n"
  "\n"
  "\t/**** lrc ***/\n"
  "\toffset = pgstromStairlikeSum( (rc_1 ? 1 : 0) + (rc_2 ? 1 : 0), &count);\n"
  "\n"
  "\tif (count > 0)\n"
  "\t{\n"
  "\t\tif (get_local_id() == 0)\n"
  "\t\t\tbase = atomicAdd(&kresults->nitems, count);\n"
  "\t\t__syncthreads();\n"
  "\n"
  "\t\tif (base + count > kresults->nrooms)\n"
  "\t\t{\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt.e, StromError_DataStoreNoSpace);\n"
  "\t\t\tgoto out;\n"
  "\t\t}\n"
  "\t\telse if (rc_1)\n"
  "\t\t{\n"
  "\t\t\t/* OK, store the result */\n"
  "\t\t\tkresults->results[base + offset] = (cl_uint)\n"
  "\t\t\t\t((char *)KERN_DATA_STORE_TUPITEM(kds_src, kds_index_1) -\n"
  "\t\t\t\t (char *)kds_src);\n"
  "\t\t\tif (rc_2)\n"
  "\t\t\t{\n"
  "\t\t\t\tkresults->results[base + offset + 1] = (cl_uint)\n"
  "\t\t\t\t((char *)KERN_DATA_STORE_TUPITEM(kds_src, kds_index_2) -\n"
  "\t\t\t\t (char *)kds_src);\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\t\telse if (rc_2)\n"
  "\t\t{\n"
  "\t\t\tkresults->results[base + offset] = (cl_uint)\n"
  "\t\t\t((char *)KERN_DATA_STORE_TUPITEM(kds_src, kds_index_2) -\n"
  "\t\t\t (char *)kds_src);\n"
  "\t\t}\n"
  "\t}\n"
  "\t__syncthreads();\n"
  "out:\n"
  "\t/* write back error status if any */\n"
  "\tkern_writeback_error_status(&kgpuscan->kerror, kcxt.e);\n"
  "}\n"
  "\n"
  "\n"
  "#ifdef GPUSCAN_DEVICE_PROJECTION\n"
  "/*\n"
  " * gpuscan_projection_row\n"
  " *\n"
  " * It constructs a result tuple of GpuScan according to the required layout\n"
  " * of the result tuple. In case when row-format is required, host code never\n"
  " * call the device projection kernel unless result layout is not compatible.\n"
  " * So, entire kernel function is within #ifdef ... #endif block\n"
  " */\n"
  "KERNEL_FUNCTION(void)\n"
  "gpuscan_projection_row(kern_gpuscan *kgpuscan,\n"
  "\t\t\t\t\t   kern_data_store *kds_src,\n"
  "\t\t\t\t\t   kern_data_store *kds_dst)\n"
  "{\n"
  "\tkern_parambuf  *kparams = KERN_GPUSCAN_PARAMBUF(kgpuscan);\n"
  "\tkern_resultbuf *kresults = KERN_GPUSCAN_RESULTBUF(kgpuscan);\n"
  "\tkern_context\tkcxt;\n"
  "\tcl_uint\t\t\tdst_nitems;\n"
  "\tcl_uint\t\t\toffset;\n"
  "\tcl_uint\t\t\tcount;\n"
  "\t__shared__ cl_uint base;\n"
  "\tcl_uint\t\t\trequired;\n"
  "\tDatum\t\t\ttup_values[GPUSCAN_DEVICE_PROJECTION_NFIELDS];\n"
  "\tcl_bool\t\t\ttup_isnull[GPUSCAN_DEVICE_PROJECTION_NFIELDS];\n"
  "\tcl_bool\t\t\ttup_internal[GPUSCAN_DEVICE_PROJECTION_NFIELDS];\n"
  "\tcl_uint\t\t   *tup_index = KERN_DATA_STORE_ROWINDEX(kds_dst);\n"
  "\n"
  "\t/*\n"
  "\t * immediate bailout if previous stage already have error status\n"
  "\t */\n"
  "\tkcxt.e = kgpuscan->kerror;\n"
  "\tif (kcxt.e.errcode != StromError_Success)\n"
  "\t\tgoto out;\n"
  "\tINIT_KERNEL_CONTEXT(&kcxt, gpuscan_projection_row, kparams);\n"
  "\n"
  "\t/* sanity checks */\n"
  "\tassert(kresults->nrels == 1);\n"
  "\tassert(kds_src->format == KDS_FORMAT_ROW);\n"
  "\tassert(kds_dst->format == KDS_FORMAT_ROW && kds_dst->nslots == 0);\n"
  "\t/* update number of visible items */\n"
  "\tdst_nitems = (kresults->all_visible ? kds_src->nitems : kresults->nitems);\n"
  "\tif (get_global_id() == 0)\n"
  "\t\tkds_dst->nitems = dst_nitems;\n"
  "\tif (dst_nitems > kds_dst->nrooms)\n"
  "\t{\n"
  "\t\tSTROM_SET_ERROR(&kcxt.e, StromError_DataStoreNoSpace);\n"
  "\t\tgoto out;\n"
  "\t}\n"
  "\n"
  "\t/*\n"
  "\t * step.1 - compute length of the result tuple to be written\n"
  "\t */\n"
  "\tmemset(tup_internal, 0, sizeof(tup_internal));\n"
  "\n"
  "\tif (get_global_id() < dst_nitems)\n"
  "\t{\n"
  "\t\tkern_tupitem   *tupitem_src;\n"
  "\n"
  "\t\tif (kresults->all_visible)\n"
  "\t\t\ttupitem_src = KERN_DATA_STORE_TUPITEM(kds_src, get_global_id());\n"
  "\t\telse\n"
  "\t\t\ttupitem_src = (kern_tupitem *)((char *)kds_src +\n"
  "\t\t\t\t\t\t\t\t\t\t   kresults->results[get_global_id()]);\n"
  "\t\tgpuscan_projection(&kcxt,\n"
  "\t\t\t\t\t\t   kds_src,\n"
  "\t\t\t\t\t\t   tupitem_src,\n"
  "\t\t\t\t\t\t   kds_dst,\n"
  "\t\t\t\t\t\t   dst_nitems,\n"
  "\t\t\t\t\t\t   tup_values,\n"
  "\t\t\t\t\t\t   tup_isnull,\n"
  "\t\t\t\t\t\t   tup_internal);\n"
  "\t\trequired = MAXALIGN(offsetof(kern_tupitem, htup) +\n"
  "\t\t\t\t\t\t\tcompute_heaptuple_size(&kcxt,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   kds_dst,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   tup_values,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   tup_isnull,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t   tup_internal));\n"
  "\t}\n"
  "\telse\n"
  "\t\trequired = 0;\t\t/* not consume any buffer */\n"
  "\n"
  "\t/*\n"
  "\t * step.2 - increment the buffer usage of kds_dst\n"
  "\t */\n"
  "\toffset = pgstromStairlikeSum(required, &count);\n"
  "\tif (count > 0)\n"
  "\t{\n"
  "\t\tif (get_local_id() == 0)\n"
  "\t\t\tbase = atomicAdd(&kds_dst->usage, count);\n"
  "\t\t__syncthreads();\n"
  "\n"
  "\t\tif (KERN_DATA_STORE_HEAD_LENGTH(kds_dst) +\n"
  "\t\t\tSTROMALIGN(sizeof(cl_uint) * kresults->nitems) +\n"
  "\t\t\tbase + count > kds_dst->length)\n"
  "\t\t{\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt.e, StromError_DataStoreNoSpace);\n"
  "\t\t\tgoto out;\n"
  "\t\t}\n"
  "\t\telse if (required > 0)\n"
  "\t\t{\n"
  "\t\t\t/*\n"
  "\t\t\t * step.3 - extract the result heap-tuple\n"
  "\t\t\t */\n"
  "\t\t\tcl_uint\t\t\tpos = kds_dst->length - (base + offset + required);\n"
  "\t\t\tkern_tupitem   *tupitem_dst\n"
  "\t\t\t\t= (kern_tupitem *)((char *)kds_dst + pos);\n"
  "\n"
  "\t\t\ttup_index[get_global_id()] = pos;\n"
  "\t\t\tform_kern_heaptuple(&kcxt, kds_dst, tupitem_dst,\n"
  "\t\t\t\t\t\t\t\ttup_values, tup_isnull, tup_internal);\n"
  "\t\t}\n"
  "\t}\n"
  "\t__syncthreads();\n"
  "out:\n"
  "\t/* write back error status if any */\n"
  "\tkern_writeback_error_status(&kgpuscan->kerror, kcxt.e);\n"
  "}\n"
  "#endif\n"
  "\n"
  "KERNEL_FUNCTION(void)\n"
  "gpuscan_projection_slot(kern_gpuscan *kgpuscan,\n"
  "\t\t\t\t\t\tkern_data_store *kds_src,\n"
  "\t\t\t\t\t\tkern_data_store *kds_dst)\n"
  "{\n"
  "\tkern_parambuf  *kparams = KERN_GPUSCAN_PARAMBUF(kgpuscan);\n"
  "\tkern_resultbuf *kresults = KERN_GPUSCAN_RESULTBUF(kgpuscan);\n"
  "\tkern_context\tkcxt;\n"
  "\tcl_uint\t\t\tdst_nitems;\n"
  "\tkern_tupitem   *tupitem;\n"
  "\tDatum\t\t   *tup_values;\n"
  "\tcl_bool\t\t   *tup_isnull;\n"
  "#ifdef GPUSCAN_DEVICE_PROJECTION\n"
  "\tcl_bool\t\t\ttup_internal[GPUSCAN_DEVICE_PROJECTION_NFIELDS];\n"
  "#endif\n"
  "\n"
  "\t/*\n"
  "\t * immediate bailout if previous stage already have error status\n"
  "\t */\n"
  "\tkcxt.e = kgpuscan->kerror;\n"
  "\tif (kcxt.e.errcode != StromError_Success)\n"
  "\t\tgoto out;\n"
  "\tINIT_KERNEL_CONTEXT(&kcxt, gpuscan_projection_row, kparams);\n"
  "\n"
  "\t/* sanity checks */\n"
  "\tassert(kresults->nrels == 1);\n"
  "\tassert(kds_src->format == KDS_FORMAT_ROW);\n"
  "\tassert(kds_dst->format == KDS_FORMAT_SLOT);\n"
  "\tif (kresults->nitems > kds_dst->nrooms)\n"
  "\t{\n"
  "\t\tSTROM_SET_ERROR(&kcxt.e, StromError_DataStoreNoSpace);\n"
  "\t\tgoto out;\n"
  "\t}\n"
  "\t/* update number of visible items */\n"
  "\tdst_nitems = (kresults->all_visible ? kds_src->nitems : kresults->nitems);\n"
  "\tif (get_global_id() == 0)\n"
  "\t\tkds_dst->nitems = dst_nitems;\n"
  "\tif (dst_nitems > kds_dst->nrooms)\n"
  "\t{\n"
  "\t\tSTROM_SET_ERROR(&kcxt.e, StromError_DataStoreNoSpace);\n"
  "\t\tgoto out;\n"
  "\t}\n"
  "\t/* fetch the source tuple */\n"
  "\tif (get_global_id() < dst_nitems)\n"
  "\t{\n"
  "\t\tif (kresults->all_visible)\n"
  "\t\t\ttupitem = KERN_DATA_STORE_TUPITEM(kds_src, get_global_id());\n"
  "\t\telse\n"
  "\t\t\ttupitem = (kern_tupitem *)((char *)kds_src +\n"
  "\t\t\t\t\t\t\t\t\t   kresults->results[get_global_id()]);\n"
  "\t}\n"
  "\telse\n"
  "\t\ttupitem = NULL;\n"
  "\n"
  "\ttup_values = KERN_DATA_STORE_VALUES(kds_dst, get_global_id());\n"
  "\ttup_isnull = KERN_DATA_STORE_ISNULL(kds_dst, get_global_id());\n"
  "#ifdef GPUSCAN_DEVICE_PROJECTION\n"
  "\tassert(kds_dst->ncols == GPUSCAN_DEVICE_PROJECTION_NFIELDS);\n"
  "\tgpuscan_projection(&kcxt,\n"
  "\t\t\t\t\t   kds_src,\n"
  "\t\t\t\t\t   tupitem,\n"
  "\t\t\t\t\t   kds_dst,\n"
  "\t\t\t\t\t   dst_nitems,\n"
  "\t\t\t\t\t   tup_values,\n"
  "\t\t\t\t\t   tup_isnull,\n"
  "\t\t\t\t\t   tup_internal);\n"
  "#else\n"
  "\tif (tupitem != NULL)\n"
  "\t{\n"
  "\t\tdeform_kern_heaptuple(&kcxt,\n"
  "\t\t\t\t\t\t\t  kds_src,\n"
  "\t\t\t\t\t\t\t  tupitem,\n"
  "\t\t\t\t\t\t\t  kds_dst->ncols,\n"
  "\t\t\t\t\t\t\t  true,\n"
  "\t\t\t\t\t\t\t  tup_values,\n"
  "\t\t\t\t\t\t\t  tup_isnull);\n"
  "\t}\n"
  "#endif\n"
  "out:\n"
  "\t/* write back error status if any */\n"
  "\tkern_writeback_error_status(&kgpuscan->kerror, kcxt.e);\n"
  "}\n"
  "#endif\t/* __CUDACC__ */\n"
  "#endif\t/* CUDA_GPUSCAN_H */\n"
;
