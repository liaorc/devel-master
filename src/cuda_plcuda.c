const char *pgstrom_cuda_plcuda_code =
  "/*\n"
  " * cuda_plcuda.h\n"
  " *\n"
  " * GPU accelerated parallel relations join based on hash-join or\n"
  " * nested-loop logic.\n"
  " * --\n"
  " * Copyright 2011-2016 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014-2016 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef CUDA_PLCUDA_H\n"
  "#define CUDA_PLCUDA_H\n"
  "\n"
  "#define __DATATYPE_MAX_WIDTH\t80\n"
  "\n"
  "typedef struct\n"
  "{\n"
  "\tkern_errorbuf\tkerror_prep;\n"
  "\tkern_errorbuf\tkerror_main;\n"
  "\tkern_errorbuf\tkerror_post;\n"
  "\t/*\n"
  "\t * NOTE: __retval is the primary result buffer. It shall be initialized\n"
  "\t * on kernel invocation (prior to the prep-kernel) as follows:\n"
  "\t *\n"
  "\t * If result is fixed-length data type:\n"
  "\t *   --> all zero clear (that implies not-null)\n"
  "\t * If result is variable-length data type:\n"
  "\t *   --> NULL varlena if 'results' == NULL\n"
  "\t *   --> valid varlena if 'results' != NULL\n"
  "\t */\n"
  "\tchar\t\t\t__retval[__DATATYPE_MAX_WIDTH];\n"
  "\tcl_uint\t\t\tprep_num_threads;\n"
  "\tcl_uint\t\t\tprep_shmem_unitsz;\n"
  "\tcl_uint\t\t\tmain_num_threads;\n"
  "\tcl_uint\t\t\tmain_shmem_unitsz;\n"
  "\tcl_uint\t\t\tpost_num_threads;\n"
  "\tcl_uint\t\t\tpost_shmem_unitsz;\n"
  "\tcl_ulong\t\tworking_bufsz;\n"
  "\tcl_ulong\t\tworking_usage;\n"
  "\tcl_ulong\t\tresults_bufsz;\n"
  "\tcl_ulong\t\tresults_usage;\n"
  "\tcl_uint\t\t\ttotal_length;\t/* total lenght including kparams buffer */\n"
  "\tcl_uint\t\t\tnargs;\n"
  "\tkern_colmeta\tretmeta;\n"
  "\tkern_colmeta\targmeta[FLEXIBLE_ARRAY_MEMBER];\t/* metadata of arguments */\n"
  "} kern_plcuda;\n"
  "\n"
  "#define KERN_PLCUDA_PARAMBUF(kplcuda)\t\t\t\\\n"
  "\t((kern_parambuf *)((char *)(kplcuda) +\t\t\\\n"
  "\t\t\t\t\t   STROMALIGN(offsetof(kern_plcuda,\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t   argmeta[(kplcuda)->nargs]))))\n"
  "#define KERN_PLCUDA_PARAMBUF_LENGTH(kplcuda)\t\\\n"
  "\t(KERN_PLCUDA_PARAMBUF(kplcuda)->length)\n"
  "#define KERN_PLCUDA_DMASEND_LENGTH(kplcuda)\t\t\\\n"
  "\t((kplcuda)->total_length)\n"
  "#define KERN_PLCUDA_DMARECV_LENGTH(kplcuda)\t\t\\\n"
  "\t(offsetof(kern_plcuda, retmeta))\n"
  "#define PLCUDA_ERROR_RETURN(errcode)\t\t\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, (errcode));\t\\\n"
  "\t\treturn;\t\t\t\t\t\t\t\t\t\\\n"
  "\t} while(0)\n"
  "#define PLCUDA_RUNTIME_ERROR_RETURN(errcode)\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tSTROM_SET_RUNTIME_ERROR(&kcxt->e, (errcode));\t\\\n"
  "\t\treturn;\t\t\t\t\t\t\t\t\t\\\n"
  "\t} while(0)\n"
  "\n"
  "#endif\t/* CUDA_PLCUDA.H */\n"
;
