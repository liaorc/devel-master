const char *pgstrom_cuda_common_code =
  "/*\n"
  " * cuda_common.h\n"
  " *\n"
  " * A common header for CUDA device code\n"
  " * --\n"
  " * Copyright 2011-2016 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014-2016 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef CUDA_COMMON_H\n"
  "#define CUDA_COMMON_H\n"
  "\n"
  "/*\n"
  " * Basic type definition - because of historical reason, we use \"cl_\"\n"
  " * prefix for the definition of data types below. It might imply\n"
  " * something related to OpenCL, but what we intend at this moment is\n"
  " * \"CUDA Language\".\n"
  " */\n"
  "typedef char\t\t\t\tcl_bool;\n"
  "typedef char\t\t\t\tcl_char;\n"
  "typedef unsigned char\t\tcl_uchar;\n"
  "typedef short\t\t\t\tcl_short;\n"
  "typedef unsigned short\t\tcl_ushort;\n"
  "typedef int\t\t\t\t\tcl_int;\n"
  "typedef unsigned int\t\tcl_uint;\n"
  "#ifdef __CUDACC__\n"
  "typedef long long\t\t\tcl_long;\n"
  "typedef unsigned long long\tcl_ulong;\n"
  "#else\n"
  "typedef long\t\t\t\tcl_long;\n"
  "typedef unsigned long\t\tcl_ulong;\n"
  "#endif\n"
  "typedef float\t\t\t\tcl_float;\n"
  "typedef double\t\t\t\tcl_double;\n"
  "\n"
  "/*\n"
  " * OpenCL intermediator always adds -DOPENCL_DEVICE_CODE on kernel build,\n"
  " * but not for the host code, so this #if ... #endif block is available\n"
  " * only OpenCL device code.\n"
  " */\n"
  "#ifdef __CUDACC__\n"
  "\n"
  "/* Misc definitions */\n"
  "#ifdef offsetof\n"
  "#undef offsetof\n"
  "#endif\n"
  "#define offsetof(TYPE,FIELD)\t((devptr_t) &((TYPE *)0)->FIELD)\n"
  "\n"
  "#ifdef lengthof\n"
  "#undef lengthof\n"
  "#endif\n"
  "#define lengthof(ARRAY)\t\t\t(sizeof(ARRAY) / sizeof((ARRAY)[0]))\n"
  "\n"
  "#ifdef container_of\n"
  "#undef container_of\n"
  "#endif\n"
  "#define container_of(TYPE,FIELD,PTR)\t\t\t\\\n"
  "\t((TYPE *)((char *) (PTR) - offsetof(TYPE, FIELD)))\n"
  "\n"
  "#define BITS_PER_BYTE\t\t\t8\n"
  "#define FLEXIBLE_ARRAY_MEMBER\t1\n"
  "#define true\t\t\t((cl_bool) 1)\n"
  "#define false\t\t\t((cl_bool) 0)\n"
  "\n"
  "/* Another basic type definitions */\n"
  "typedef cl_ulong\thostptr_t;\n"
  "typedef size_t\t\tdevptr_t;\n"
  "typedef cl_ulong\tDatum;\n"
  "#define PointerGetDatum(X)\t\t((Datum) (X))\n"
  "#define DatumGetPointer(X)\t\t((char *) (X))\n"
  "\n"
  "#define INT64CONST(x)\t((cl_long) x##L)\n"
  "#define UINT64CONST(x)\t((cl_ulong) x##UL)\n"
  "\n"
  "#define Max(a,b)\t\t((a) > (b) ? (a) : (b))\n"
  "#define Max3(a,b,c)\t\t((a) > (b) ? Max((a),(c)) : Max((b),(c)))\n"
  "#define Max4(a,b,c,d)\tMax(Max((a),(b)),Max((c),(d)))\n"
  "\n"
  "#define Min(a,b)\t\t((a) < (b) ? (a) : (b))\n"
  "#define Min3(a,b,c)\t\t((a) < (b) ? Min((a),(c)) : Min((b),(c)))\n"
  "#define Min4(a,b,c,d)\tMin(Min((a),(b)),Min((c),(d)))\n"
  "\n"
  "#define Add(a,b)\t\t((a) + (b))\n"
  "#define Add3(a,b,c)\t\t((a) + (b) + (c))\n"
  "#define Add4(a,b,c,d)\t((a) + (b) + (c) + (d))\n"
  "\n"
  "/* same as host side get_next_log2() */\n"
  "#define get_next_log2(value)\t\t\t\t\t\t\t\t\\\n"
  "\t((value) == 0 ? 0 : (sizeof(cl_ulong) * BITS_PER_BYTE - \\\n"
  "\t\t\t\t\t\t __clzll((cl_ulong)(value) - 1)))\n"
  "\n"
  "/*\n"
  " * Alignment macros\n"
  " */\n"
  "#define TYPEALIGN(ALIGNVAL,LEN)\t\\\n"
  "\t(((devptr_t) (LEN) + ((ALIGNVAL) - 1)) & ~((devptr_t) ((ALIGNVAL) - 1)))\n"
  "#define TYPEALIGN_DOWN(ALIGNVAL,LEN) \\\n"
  "\t(((devptr_t) (LEN)) & ~((devptr_t) ((ALIGNVAL) - 1)))\n"
  "#define INTALIGN(LEN)\t\t\tTYPEALIGN(sizeof(cl_int), (LEN))\n"
  "#define INTALIGN_DOWN(LEN)\t\tTYPEALIGN_DOWN(sizeof(cl_int), (LEN))\n"
  "#define LONGALIGN(LEN)          TYPEALIGN(sizeof(cl_long), (LEN))\n"
  "#define LONGALIGN_DOWN(LEN)     TYPEALIGN_DOWN(sizeof(cl_long), (LEN))\n"
  "#define MAXALIGN(LEN)\t\t\tTYPEALIGN(MAXIMUM_ALIGNOF, (LEN))\n"
  "#define MAXALIGN_DOWN(LEN)\t\tTYPEALIGN_DOWN(MAXIMUM_ALIGNOF, (LEN))\n"
  "\n"
  "/*\n"
  " * Limitation of types\n"
  " */\n"
  "#define SHRT_MAX\t\t32767\n"
  "#define SHRT_MIN\t\t(-32767-1)\n"
  "#define USHRT_MAX\t\t65535\n"
  "#define INT_MAX\t\t\t2147483647\n"
  "#define INT_MIN\t\t\t(-INT_MAX - 1)\n"
  "#define UINT_MAX\t\t4294967295U\n"
  "#define LONG_MAX\t\t0x7FFFFFFFFFFFFFFFLL\n"
  "#define LONG_MIN        (-LONG_MAX - 1LL)\n"
  "#define ULONG_MAX\t\t0xFFFFFFFFFFFFFFFFULL\n"
  "#define FLT_MAX\t\t\t__int_as_float(0x7f7fffffU)\n"
  "#define FLT_MIN\t\t\t__int_as_float(0x00800000U)\n"
  "#define FLT_DIG\t\t\t6\n"
  "#define FLT_MANT_DIG\t24\n"
  "#define DBL_MAX\t\t\t__longlong_as_double(0x7fefffffffffffffULL)\n"
  "#define DBL_MIN\t\t\t__longlong_as_double(0x0010000000000000ULL)\n"
  "#define DBL_DIG\t\t\t15\n"
  "#define DBL_MANT_DIG\t53\n"
  "\n"
  "/*\n"
  " * MEMO: We takes dynamic local memory using cl_ulong data-type because of\n"
  " * alignment problem. The nvidia's driver adjust alignment of local memory\n"
  " * according to the data type; 1byte for cl_char, 4bytes for cl_uint and\n"
  " * so on. Unexpectedly, void * pointer has 1byte alignment even if it is\n"
  " * expected to be casted another data types.\n"
  " * A pragma option __attribute__((aligned)) didn't work at least driver\n"
  " * version 340.xx. So, we declared the local_workmem as cl_ulong * pointer\n"
  " * as a workaround.\n"
  " */\n"
  "#define SHARED_WORKMEM(TYPE)\t((TYPE *) __pgstrom_dynamic_shared_workmem)\n"
  "extern __shared__ cl_ulong __pgstrom_dynamic_shared_workmem[];\n"
  "\n"
  "/*\n"
  " * Thread index like OpenCL style.\n"
  " *\n"
  " * Be careful to use this convenient alias if grid/block size may become\n"
  " * larger than INT_MAX, because threadIdx and blockDim are declared as\n"
  " * 32bit integer, thus, it makes overflow during intermediation results\n"
  " * if it is larger than INT_MAX.\n"
  " */\n"
  "#define get_local_id()\t\t\t(threadIdx.x)\n"
  "#define get_local_size()\t\t(blockDim.x)\n"
  "#define get_global_id()\t\t\t(threadIdx.x + blockIdx.x * blockDim.x)\n"
  "#define get_global_size()\t\t(blockDim.x * gridDim.x)\n"
  "#define get_global_base()\t\t(blockIdx.x * blockDim.x)\n"
  "#define get_global_index()\t\t(blockIdx.x)\n"
  "\n"
  "#define lget_global_id()\t\t((size_t)threadIdx.x +\t\\\n"
  "\t\t\t\t\t\t\t\t (size_t)blockIdx.x *\t\\\n"
  "\t\t\t\t\t\t\t\t (size_t)blockDim.x)\n"
  "#define lget_global_size()\t\t((size_t)blockDim.x * (size_t)gridDim.x)\n"
  "#define lget_global_base()\t\t((size_t)blockIdx.x * (size_t)blockDim.x)\n"
  "#define lget_global_index()\t\t((size_t)blockIdx.x)\n"
  "\n"
  "#else\t/* __CUDACC__ */\n"
  "#include \"access/htup_details.h\"\n"
  "#include \"storage/itemptr.h\"\n"
  "#define __device__\t\t/* address space qualifier is noise on host */\n"
  "#define __global__\t\t/* address space qualifier is noise on host */\n"
  "#define __constant__\t/* address space qualifier is noise on host */\n"
  "#define __shared__\t\t/* address space qualifier is noise on host */\n"
  "typedef uintptr_t\t\thostptr_t;\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * Template of static function declarations\n"
  " *\n"
  " * CUDA compilar raises warning if static functions are not used, but\n"
  " * we can restain this message with\"unused\" attribute of function/values.\n"
  " * STATIC_INLINE / STATIC_FUNCTION packs common attributes to be\n"
  " * assigned on host/device functions\n"
  " */\n"
  "#ifdef __CUDACC__\n"
  "#define STATIC_INLINE(RET_TYPE)\t\t\t\t\t\t\\\n"
  "\t__device__ __forceinline__ static RET_TYPE __attribute__ ((unused))\n"
  "#define STATIC_FUNCTION(RET_TYPE)\t\t\t\t\t\\\n"
  "\t__device__ static RET_TYPE __attribute__ ((unused))\n"
  "#define KERNEL_FUNCTION(RET_TYPE)\t__global__ RET_TYPE\n"
  "#if __CUDA_ARCH__ < 200\n"
  "#define KERNEL_FUNCTION_MAXTHREADS(RET_TYPE)\t\\\n"
  "\t__global__ RET_TYPE __launch_bounds__(512)\n"
  "#else\n"
  "#define KERNEL_FUNCTION_MAXTHREADS(RET_TYPE)\t\\\n"
  "\t__global__ RET_TYPE __launch_bounds__(1024)\n"
  "#endif\n"
  "#else\n"
  "#define STATIC_INLINE(RET_TYPE)\t\tstatic inline RET_TYPE\n"
  "#define STATIC_FUNCTION(RET_TYPE)\tstatic inline RET_TYPE\n"
  "#define KERNEL_FUNCTION(RET_TYPE)\tRET_TYPE\n"
  "#define KERNEL_FUNCTION_MAXTHREADS(RET_TYPE)\tKERNEL_FUNCTION(RET_TYPE)\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * Error code definition\n"
  " *\n"
  " *           0 : Success in all error code scheme\n"
  " *    1 -  999 : Error code in CUDA driver API\n"
  " * 1000 - 9999 : Error code of PG-Strom\n"
  " *     > 10000 : Error code in CUDA device runtime\n"
  " *\n"
  " * Error code definition\n"
  " */\n"
  "#define StromError_Success\t\t\t\t\t   0 /* OK */\n"
  "#define StromError_CpuReCheck\t\t\t\t1000 /* To be re-checked by CPU */\n"
  "#define StromError_CudaInternal\t\t\t\t1001 /* CUDA internal error */\n"
  "#define StromError_OutOfMemory\t\t\t\t1002 /* Out of memory */\n"
  "#define StromError_OutOfSharedMemory\t\t1003 /* Out of shared memory */\n"
  "#define StromError_OutOfKernelArgs\t\t\t1004 /* Out of kernel arguments */\n"
  "#define StromError_InvalidValue\t\t\t\t1999 /* Something invalid */\n"
  "#define StromError_DataStoreCorruption\t\t2000 /* KDS corrupted */\n"
  "#define StromError_DataStoreNoSpace\t\t\t2001 /* KDS has no space */\n"
  "#define StromError_DataStoreOutOfRange\t\t2002 /* out of KDS range access */\n"
  "#define StromError_SanityCheckViolation\t\t2003 /* sanity check violation */\n"
  "#define StromError_WrongCodeGeneration\t\t2004 /* Bugs on code generation */\n"
  "#define StromError_CudaDevRunTimeBase\t   10000 /* Base value for runtime */\n"
  "\n"
  "/*\n"
  " * Kernel functions identifier\n"
  " */\n"
  "#define StromKernel_HostPGStrom\t\t\t\t\t\t0x0001\n"
  "#define StromKernel_CudaRuntime\t\t\t\t\t\t0x0002\n"
  "#define StromKernel_gpuscan_exec_quals\t\t\t\t0x0101\n"
  "#define StromKernel_gpuscan_projection_row\t\t\t0x0102\n"
  "#define StromKernel_gpuscan_projection_slot\t\t\t0x0103\n"
  "#define StromKernel_gpuscan_main\t\t\t\t\t0x0199\n"
  "#define StromKernel_gpujoin_exec_outerscan\t\t\t0x0201\n"
  "#define StromKernel_gpujoin_exec_nestloop\t\t\t0x0202\n"
  "#define StromKernel_gpujoin_exec_hashjoin\t\t\t0x0203\n"
  "#define StromKernel_gpujoin_outer_nestloop\t\t\t0x0204\n"
  "#define StromKernel_gpujoin_outer_hashjoin\t\t\t0x0205\n"
  "#define StromKernel_gpujoin_projection_row\t\t\t0x0206\n"
  "#define StromKernel_gpujoin_projection_slot\t\t\t0x0207\n"
  "#define StromKernel_gpujoin_count_rows_dist\t\t\t0x0208\n"
  "#define StromKernel_gpujoin_main\t\t\t\t\t0x0299\n"
  "#define StromKernel_gpupreagg_preparation\t\t\t0x0301\n"
  "#define StromKernel_gpupreagg_local_reduction\t\t0x0302\n"
  "#define StromKernel_gpupreagg_global_reduction\t\t0x0303\n"
  "#define StromKernel_gpupreagg_nogroup_reduction\t\t0x0304\n"
  "#define StromKernel_gpupreagg_final_preparation\t\t0x0305\n"
  "#define StromKernel_gpupreagg_final_reduction\t\t0x0306\n"
  "#define StromKernel_gpupreagg_fixup_varlena\t\t\t0x0307\n"
  "#define StromKernel_gpupreagg_main\t\t\t\t\t0x0399\n"
  "#define StromKernel_gpusort_projection\t\t\t\t0x0401\n"
  "#define StromKernel_gpusort_bitonic_local\t\t\t0x0402\n"
  "#define StromKernel_gpusort_bitonic_step\t\t\t0x0403\n"
  "#define StromKernel_gpusort_bitonic_merge\t\t\t0x0404\n"
  "#define StromKernel_gpusort_fixup_pointers\t\t\t0x0405\n"
  "#define StromKernel_gpusort_main\t\t\t\t\t0x0499\n"
  "#define StromKernel_plcuda_prep_kernel\t\t\t\t0x0501\n"
  "#define StromKernel_plcuda_main_kernel\t\t\t\t0x0502\n"
  "#define StromKernel_plcuda_post_kernel\t\t\t\t0x0503\n"
  "\n"
  "typedef struct\n"
  "{\n"
  "\tcl_int\t\terrcode;\t/* one of the StromError_* */\n"
  "\tcl_short\tkernel;\t\t/* one of the StromKernel_* */\n"
  "\tcl_short\tlineno;\t\t/* line number STROM_SET_ERROR is called */\n"
  "#ifdef PGSTROM_DEBUG\n"
  "\tcl_long\t\textra_x;\t/* for debug purpose */\n"
  "\tcl_long\t\textra_y;\t/* for debug purpose */\n"
  "\tcl_long\t\textra_z;\t/* for debug purpose */\n"
  "#endif\n"
  "} kern_errorbuf;\n"
  "\n"
  "#ifdef PGSTROM_DEBUG\n"
  "#define KERN_ERRORBUF_SET_EXTRA(p_kerror,x,y,z)\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t(p_kerror)->extra_x = (cl_long)(x);\t\t\\\n"
  "\t\t(p_kerror)->extra_y = (cl_long)(y);\t\t\\\n"
  "\t\t(p_kerror)->extra_z = (cl_long)(z);\t\t\\\n"
  "\t} while(0)\n"
  "#else\n"
  "#define KERN_ERRORBUF_SET_EXTRA(kcxt,x,y,z)\t\tdo {} while(0)\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * kern_context - a set of run-time information\n"
  " */\n"
  "struct kern_parambuf;\n"
  "\n"
  "typedef struct\n"
  "{\n"
  "\tkern_errorbuf\te;\n"
  "\tstruct kern_parambuf *kparams;\n"
  "} kern_context;\n"
  "\n"
  "#define INIT_KERNEL_CONTEXT(kcxt,kfunction,kparams)\t\t\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t(kcxt)->e.errcode = StromError_Success;\t\t\t\t\\\n"
  "\t\t(kcxt)->e.kernel = StromKernel_##kfunction;\t\t\t\\\n"
  "\t\t(kcxt)->e.lineno = 0;\t\t\t\t\t\t\t\t\\\n"
  "\t\tKERN_ERRORBUF_SET_EXTRA(&(kcxt)->e,0,0,0);\t\t\t\\\n"
  "\t\t(kcxt)->kparams = (kparams);\t\t\t\t\t\t\\\n"
  "\t\tassert((cl_ulong)(kparams) == MAXALIGN(kparams));\t\\\n"
  "\t} while(0)\n"
  "\n"
  "/*\n"
  " * It sets an error code unless no significant error code is already set.\n"
  " * Also, CpuReCheck has higher priority than RowFiltered because CpuReCheck\n"
  " * implies device cannot run the given expression completely.\n"
  " * (Usually, due to compressed or external varlena datum)\n"
  " */\n"
  "#ifdef __CUDACC__\n"
  "STATIC_INLINE(void)\n"
  "__STROM_SET_ERROR(kern_errorbuf *p_kerror, cl_int errcode, cl_int lineno,\n"
  "\t\t\t\t  cl_long extra_x, cl_long extra_y, cl_long extra_z)\n"
  "{\n"
  "\tcl_int\t\t\toldcode = p_kerror->errcode;\n"
  "\n"
  "\tif (oldcode == StromError_Success &&\n"
  "\t\terrcode != StromError_Success)\n"
  "\t{\n"
  "\t\tp_kerror->errcode = errcode;\n"
  "\t\tp_kerror->lineno = lineno;\n"
  "\t\tKERN_ERRORBUF_SET_EXTRA(p_kerror, extra_x, extra_y, extra_z);\n"
  "\t}\n"
  "}\n"
  "\n"
  "#define STROM_SET_ERROR(p_kerror, errcode)\t\t\\\n"
  "\t__STROM_SET_ERROR((p_kerror), (errcode), __LINE__, 123, 456, 789)\n"
  "#define STROM_SET_ERROR_EXTRA(p_kerror, errcode, x, y, z)\t\\\n"
  "\t__STROM_SET_ERROR((p_kerror), (errcode), __LINE__, (x), (y), (z))\n"
  "#define STROM_SET_RUNTIME_ERROR(p_kerror, errcode)\t\t\t\t\t\t\\\n"
  "\tSTROM_SET_ERROR((p_kerror), (errcode) == cudaSuccess ?\t\t\t\t\\\n"
  "\t\t\t\t\t(cl_int)(errcode) :\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t(cl_int)(errcode) + StromError_CudaDevRunTimeBase)\n"
  "#define STROM_SET_RUNTIME_ERROR_EXTRA(p_kerror, errcode, x, y, z)\t\t\\\n"
  "\tSTROM_SET_ERROR_EXTRA((p_kerror),\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  (errcode) == cudaSuccess ?\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  (cl_int)(errcode) :\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  (cl_int)(errcode) + StromError_CudaDevRunTimeBase, \\\n"
  "\t\t\t\t\t\t  (x), (y), (z))\n"
  "\n"
  "/*\n"
  " * kern_writeback_error_status\n"
  " */\n"
  "STATIC_INLINE(void)\n"
  "kern_writeback_error_status(kern_errorbuf *result, kern_errorbuf own_error)\n"
  "{\n"
  "\t/*\n"
  "\t * It writes back a thread local error status only when the global\n"
  "\t * error status is not set yet and the caller thread contains any\n"
  "\t * error status. Elsewhere, we don't involves any atomic operation\n"
  "\t * in the most of code path.\n"
  "\t */\n"
  "\tif (own_error.errcode != StromError_Success &&\n"
  "\t\tatomicCAS(&result->errcode,\n"
  "\t\t\t\t  StromError_Success,\n"
  "\t\t\t\t  own_error.errcode) == StromError_Success)\n"
  "\t{\n"
  "\t\t/* only primary error workgroup can come into */\n"
  "\t\tresult->kernel = own_error.kernel;\n"
  "\t\tresult->lineno = own_error.lineno;\n"
  "#ifdef PGSTROM_DEBUG\n"
  "\t\tresult->extra_x = own_error.extra_x;\n"
  "\t\tresult->extra_y = own_error.extra_y;\n"
  "\t\tresult->extra_z = own_error.extra_z;\n"
  "#endif\n"
  "\t}\n"
  "}\n"
  "\n"
  "#else\t/* __CUDACC__ */\n"
  "#ifdef PGSTROM_DEBUG\n"
  "#define KERROR_EXTRA_X(p_kerror)\t\t((p_kerror)->extra_x)\n"
  "#define KERROR_EXTRA_Y(p_kerror)\t\t((p_kerror)->extra_y)\n"
  "#define KERROR_EXTRA_Z(p_kerror)\t\t((p_kerror)->extra_z)\n"
  "#else\n"
  "#define KERROR_EXTRA_X(p_kerror)\t\t0UL\n"
  "#define KERROR_EXTRA_Y(p_kerror)\t\t0UL\n"
  "#define KERROR_EXTRA_Z(p_kerror)\t\t0UL\n"
  "#endif\n"
  "/*\n"
  " * If case when STROM_SET_ERROR is called in the host code,\n"
  " * it raises an error using ereport()\n"
  " */\n"
  "#define STROM_SET_ERROR(p_kerror, errcode)\t\t\\\n"
  "\telog(ERROR, \"%s:%d %s\", __FUNCTION__, __LINE__, errorText(errcode))\n"
  "#endif\t/* !__CUDACC__! */\n"
  "#ifdef __CUDACC__\n"
  "/*\n"
  " * NumSmx - reference to the %nsmid register\n"
  " */\n"
  "STATIC_INLINE(cl_uint) NumSmx(void)\n"
  "{\n"
  "\tcl_uint\t\tret;\n"
  "\tasm volatile(\"mov.u32 %0, %nsmid;\" : \"=r\"(ret) );\n"
  "\treturn ret;\n"
  "}\n"
  "\n"
  "/*\n"
  " * SmxId - reference to the %smid register\n"
  " */\n"
  "STATIC_INLINE(cl_uint) SmxId(void)\n"
  "{\n"
  "\tcl_uint\t\tret;\n"
  "\tasm volatile(\"mov.u32 %0, %smid;\" : \"=r\"(ret) );\n"
  "\treturn ret;\n"
  "}\n"
  "\n"
  "/*\n"
  " * WarpId() - reference to the %warpid register\n"
  " */\n"
  "STATIC_INLINE(cl_uint) WarpId(void)\n"
  "{\n"
  "\tcl_uint\t\tret;\n"
  "\tasm volatile(\"mov.u32 %0, %warpid;\" : \"=r\"(ret) );\n"
  "\treturn ret;\n"
  "}\n"
  "\n"
  "/*\n"
  " * GlobalTimer - A pre-defined, 64bit global nanosecond timer.\n"
  " *\n"
  " * NOTE: clock64() is not consistent across different SMX, thus, should not\n"
  " *       use this API in case when device time-run may reschedule the kernel.\n"
  " */\n"
  "STATIC_INLINE(cl_ulong) GlobalTimer(void)\n"
  "{\n"
  "\tcl_ulong\tret;\n"
  "\tasm volatile(\"mov.u64 %0, %globaltimer;\" : \"=l\"(ret) );\n"
  "\treturn ret;\n"
  "}\n"
  "\n"
  "/*\n"
  " * We need to re-define HeapTupleHeaderData and t_infomask related stuff\n"
  " */\n"
  "typedef struct {\n"
  "\tstruct {\n"
  "\t\tcl_ushort\tbi_hi;\n"
  "\t\tcl_ushort\tbi_lo;\n"
  "\t} ip_blkid;\n"
  "\tcl_ushort\t\tip_posid;\n"
  "} ItemPointerData;\n"
  "\n"
  "typedef struct {\n"
  "\tunion {\n"
  "\t\tstruct {\n"
  "\t\t\tcl_uint\tt_xmin;\t\t/* inserting xact ID */\n"
  "\t\t\tcl_uint\tt_xmax;\t\t/* deleting or locking xact ID */\n"
  "\t\t\tunion {\n"
  "\t\t\t\tcl_uint\tt_cid;\t/* inserting or deleting command ID, or both */\n"
  "\t\t\t\tcl_uint\tt_xvac;\t/* old-style VACUUM FULL xact ID */\n"
  "\t\t\t} t_field3;\n"
  "\t\t} t_heap;\n"
  "\t\tstruct {\n"
  "\t\t\tcl_uint\tdatum_len_;\t/* varlena header (do not touch directly!) */\n"
  "\t\t\tcl_uint\tdatum_typmod;\t/* -1, or identifier of a record type */\n"
  "\t\t\tcl_uint\tdatum_typeid;\t/* composite type OID, or RECORDOID */\n"
  "\t\t} t_datum;\n"
  "\t} t_choice;\n"
  "\n"
  "\tItemPointerData\tt_ctid;\t\t\t/* current TID of this or newer tuple */\n"
  "\n"
  "\tcl_ushort\t\tt_infomask2;\t/* number of attributes + various flags */\n"
  "\tcl_ushort\t\tt_infomask;\t\t/* various flag bits, see below */\n"
  "\tcl_uchar\t\tt_hoff;\t\t\t/* sizeof header incl. bitmap, padding */\n"
  "\t/* ^ - 23 bytes - ^ */\n"
  "\tcl_uchar\t\tt_bits[1];\t\t/* bitmap of NULLs -- VARIABLE LENGTH */\n"
  "} HeapTupleHeaderData;\n"
  "\n"
  "#define att_isnull(ATT, BITS) (!((BITS)[(ATT) >> 3] & (1 << ((ATT) & 0x07))))\n"
  "#define bitmaplen(NATTS) (((int)(NATTS) + BITS_PER_BYTE - 1) / BITS_PER_BYTE)\n"
  "\n"
  "/*\n"
  " * information stored in t_infomask:\n"
  " */\n"
  "#define HEAP_HASNULL\t\t\t0x0001\t/* has null attribute(s) */\n"
  "#define HEAP_HASVARWIDTH\t\t0x0002\t/* has variable-width attribute(s) */\n"
  "#define HEAP_HASEXTERNAL\t\t0x0004\t/* has external stored attribute(s) */\n"
  "#define HEAP_HASOID\t\t\t\t0x0008\t/* has an object-id field */\n"
  "#define HEAP_XMAX_KEYSHR_LOCK\t0x0010\t/* xmax is a key-shared locker */\n"
  "#define HEAP_COMBOCID\t\t\t0x0020\t/* t_cid is a combo cid */\n"
  "#define HEAP_XMAX_EXCL_LOCK\t\t0x0040\t/* xmax is exclusive locker */\n"
  "#define HEAP_XMAX_LOCK_ONLY\t\t0x0080\t/* xmax, if valid, is only a locker */\n"
  "\n"
  "/*\n"
  " * information stored in t_infomask2:\n"
  " */\n"
  "#define HEAP_NATTS_MASK\t\t\t0x07FF\t/* 11 bits for number of attributes */\n"
  "#define HEAP_KEYS_UPDATED\t\t0x2000\t/* tuple was updated and key cols\n"
  "\t\t\t\t\t\t\t\t\t\t * modified, or tuple deleted */\n"
  "#define HEAP_HOT_UPDATED\t\t0x4000\t/* tuple was HOT-updated */\n"
  "#define HEAP_ONLY_TUPLE\t\t\t0x8000\t/* this is heap-only tuple */\n"
  "#define HEAP2_XACT_MASK\t\t\t0xE000\t/* visibility-related bits */\n"
  "\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * alignment for pg-strom\n"
  " */\n"
  "#define STROMALIGN_LEN\t\t\t16\n"
  "#define STROMALIGN(LEN)\t\t\tTYPEALIGN(STROMALIGN_LEN,(LEN))\n"
  "#define STROMALIGN_DOWN(LEN)\tTYPEALIGN_DOWN(STROMALIGN_LEN,(LEN))\n"
  "\n"
  "#define GPUMEMALIGN_LEN\t\t\t1024\n"
  "#define GPUMEMALIGN(LEN)\t\tTYPEALIGN(GPUMEMALIGN_LEN,(LEN))\n"
  "#define GPUMEMALIGN_DOWN(LEN)\tTYPEALIGN_DOWN(GPUMEMALIGN_LEN,(LEN))\n"
  "\n"
  "#ifdef __CUDACC__\n"
  "/*\n"
  " * alignment aware value reference\n"
  " */\n"
  "STATIC_INLINE(cl_short)\n"
  "get_uint16_val(const void *addr)\n"
  "{\n"
  "\treturn ((devptr_t)addr & (sizeof(cl_ushort) - 1)) == 0\n"
  "\t\t? *((cl_ushort *) addr)\n"
  "\t\t: ((cl_ushort)((cl_uchar *)addr)[0] |\n"
  "\t\t   (cl_ushort)((cl_uchar *)addr)[1] << 8);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_uint)\n"
  "get_uint32_val(const void *addr)\n"
  "{\n"
  "\tswitch ((devptr_t)addr & (sizeof(cl_uint) - 1))\n"
  "\t{\n"
  "\t\tcase 0:\n"
  "\t\t\treturn *((cl_uint *) addr);\n"
  "\t\tcase 2:\n"
  "\t\t\treturn ((cl_uint)(*((cl_ushort *)((char *)addr))) |\n"
  "\t\t\t\t\t(cl_uint)(*((cl_ushort *)((char *)addr + 2))) << 16);\n"
  "\t\tdefault:\n"
  "\t\t\treturn ((cl_uint)(*((cl_uchar *) ((char *)addr))) |\n"
  "\t\t\t\t\t(cl_uint)(*((cl_ushort *)((char *)addr + 1))) << 8 |\n"
  "\t\t\t\t\t(cl_uint)(*((cl_uchar *) ((char *)addr + 3))) << 24);\n"
  "\t}\n"
  "}\n"
  "\n"
  "STATIC_INLINE(cl_ulong)\n"
  "get_uint64_val(const void *addr)\n"
  "{\n"
  "\tswitch ((devptr_t)addr & (sizeof(cl_ulong) - 1))\n"
  "\t{\n"
  "\t\tcase 0:\n"
  "\t\t\treturn *((cl_ulong *)addr);\n"
  "\t\tcase 4:\n"
  "\t\t\treturn ((cl_ulong)(*((cl_uint *)((char *)addr))) |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_uint *)((char *)addr + 4))));\n"
  "\t\tcase 2:\n"
  "\t\tcase 6:\n"
  "\t\t\treturn ((cl_ulong)(*((cl_ushort *)((char *)addr))) |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_uint *)  ((char *)addr + 2))) << 16 |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_ushort *)((char *)addr + 6))) << 48);\n"
  "\t\tcase 1:\n"
  "\t\tcase 5:\n"
  "\t\t\treturn ((cl_ulong)(*((cl_uchar *) ((char *)addr))) |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_ushort *)((char *)addr + 1))) <<  8 |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_uint *)  ((char *)addr + 3))) << 24 |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_uchar *) ((char *)addr + 7))) << 56);\n"
  "\t\tdefault:\t/* 3 or 7 */\n"
  "\t\t\treturn ((cl_ulong)(*((cl_uchar *) ((char *)addr))) |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_uint *)  ((char *)addr + 1))) <<  8 |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_ushort *)((char *)addr + 5))) << 40 |\n"
  "\t\t\t\t\t(cl_ulong)(*((cl_uchar *) ((char *)addr + 7))) << 56);\n"
  "\t}\n"
  "}\n"
  "\n"
  "#define get_int16_val(ADDR)\t\t((cl_int)get_uint16_val(ADDR))\n"
  "#define get_int32_val(ADDR)\t\t((cl_int)get_uint32_val(ADDR))\n"
  "#define get_int64_val(ADDR)\t\t((cl_int)get_uint64_val(ADDR))\n"
  "#define get_float32_val(ADDR)\t__int_as_float(get_uint32_val(ADDR))\n"
  "#define get_float64_val(ADDR)\t__longlong_as_double(get_int64_val(ADDR))\n"
  "#endif\t/* __CUDACC__ */\n"
  "\n"
  "/*\n"
  " * kern_data_store\n"
  " *\n"
  " * +----------------------------------------------+\n"
  " * | Common header portion of the kern_data_store |\n"
  " * |         :                                    |\n"
  " * | 'format' determines the layout below         |\n"
  " * +----------------------------------------------+\n"
  " * | Attributes of columns                        |\n"
  " * |                                              |\n"
  " * | kern_colmeta colmeta[0]                      |\n"
  " * | kern_colmeta colmeta[1]                      |\n"
  " * |        :                                     |\n"
  " * | kern_colmeta colmeta[M-1]                    |\n"
  " * +----------------------------------------------+\n"
  " * | <slot format> | <row format> / <hash format> |\n"
  " * +---------------+------------------------------+  -----\n"
  " * | values/isnull | Offset to the first hash-    |\n"
  " * | pair of the   | item for each slot (*).      |\n"
  " * | 1st tuple     |                              |\n"
  " * | +-------------+ (*) nslots=0 if row-format,  |\n"
  " * | | values[0]   | thus, it has no offset to    |\n"
  " * | |    :        | hash items.                  |\n"
  " * | | values[M-1] |                              |\n"
  " * | +-------------+  hash_slot[0]                |\n"
  " * | | isnull[0]   |  hash_slot[1]                |\n"
  " * | |    :        |      :                       |\n"
  " * | | isnull[M-1] |  hash_slot[nslots-1]         |\n"
  " * +-+-------------+------------------------------+\n"
  " * | values/isnull | Offset to the individual     |\n"
  " * | pair of the   | kern_tupitem.                |\n"
  " * | 2nd tuple     |                              |\n"
  " * | +-------------+ row_index[0]                 |\n"
  " * | | values[0]   | row_index[1]                 |\n"
  " * | |    :        |    :                         |\n"
  " * | | values[M-1] | row_index[nitems-1]          |\n"
  " * | +-------------+--------------+---------------+\n"
  " * | | isnull[0]   |    :         |       :       |\n"
  " * | |    :        +--------------+---------------+\n"
  " * | | isnull[M-1] | kern_tupitem | kern_hashitem |\n"
  " * +-+-------------+--------------+---------------+\n"
  " * | values/isnull | kern_tupitem | kern_hashitem |\n"
  " * | pair of the   +--------------+---------------+\n"
  " * | 3rd tuple     | kern_tupitem | kern_hashitem |\n"
  " * |      :        |     :        |     :         |\n"
  " * |      :        |     :        |     :         |\n"
  " * +---------------+--------------+---------------+\n"
  " */\n"
  "typedef struct {\n"
  "\t/* true, if column is held by value. Elsewhere, a reference */\n"
  "\tcl_char\t\t\tattbyval;\n"
  "\t/* alignment; 1,2,4 or 8, not characters in pg_attribute */\n"
  "\tcl_char\t\t\tattalign;\n"
  "\t/* length of attribute */\n"
  "\tcl_short\t\tattlen;\n"
  "\t/* attribute number */\n"
  "\tcl_short\t\tattnum;\n"
  "\t/* offset of attribute location, if deterministic */\n"
  "\tcl_short\t\tattcacheoff;\n"
  "\t/* oid of the SQL data type */\n"
  "\tcl_uint\t\t\tatttypid;\n"
  "\t/* typmod of the SQL data type */\n"
  "\tcl_int\t\t\tatttypmod;\n"
  "} kern_colmeta;\n"
  "\n"
  "/*\n"
  " * kern_tupitem - individual items for KDS_FORMAT_ROW\n"
  " */\n"
  "typedef struct\n"
  "{\n"
  "\tcl_ushort\t\t\tt_len;\t/* length of tuple */\n"
  "\tItemPointerData\t\tt_self;\t/* SelfItemPointer */\n"
  "\tHeapTupleHeaderData\thtup;\n"
  "} kern_tupitem;\n"
  "\n"
  "/*\n"
  " * kern_hashitem - individual items for KDS_FORMAT_HASH\n"
  " */\n"
  "typedef struct\n"
  "{\n"
  "\tcl_uint\t\t\t\thash;\t/* 32-bit hash value */\n"
  "\tcl_uint\t\t\t\tnext;\t/* offset of the next */\n"
  "\tcl_uint\t\t\t\trowid;\t/* unique identifier of this hash entry */\n"
  "\tcl_uint\t\t\t\t__padding__; /* for alignment */\n"
  "\tkern_tupitem\t\tt;\t\t/* HeapTuple of this entry */\n"
  "} kern_hashitem;\n"
  "\n"
  "#define KDS_FORMAT_ROW\t\t\t1\n"
  "#define KDS_FORMAT_SLOT\t\t\t2\n"
  "#define KDS_FORMAT_HASH\t\t\t3\t/* inner hash table for GpuHashJoin */\n"
  "\n"
  "typedef struct {\n"
  "\thostptr_t\t\thostptr;\t/* address of kds on the host */\n"
  "\tcl_uint\t\t\tlength;\t\t/* length of this data-store */\n"
  "\tcl_uint\t\t\tusage;\t\t/* usage of this data-store */\n"
  "\tcl_uint\t\t\tncols;\t\t/* number of columns in this store */\n"
  "\tcl_uint\t\t\tnitems; \t/* number of rows in this store */\n"
  "\tcl_uint\t\t\tnrooms;\t\t/* number of available rows in this store */\n"
  "\tcl_char\t\t\tformat;\t\t/* one of KDS_FORMAT_* above */\n"
  "\tcl_char\t\t\thas_notbyval; /* true, if any of column is !attbyval */\n"
  "\tcl_char\t\t\thas_numeric;/* true, if any of column is numeric */\n"
  "\tcl_char\t\t\ttdhasoid;\t/* copy of TupleDesc.tdhasoid */\n"
  "\tcl_uint\t\t\ttdtypeid;\t/* copy of TupleDesc.tdtypeid */\n"
  "\tcl_int\t\t\ttdtypmod;\t/* copy of TupleDesc.tdtypmod */\n"
  "\tcl_uint\t\t\ttable_oid;\t/* OID of the table (only if GpuScan) */\n"
  "\tcl_uint\t\t\tnslots;\t\t/* width of hash-slot (only HASH format) */\n"
  "\tcl_uint\t\t\thash_min;\t/* minimum hash-value (only HASH format) */\n"
  "\tcl_uint\t\t\thash_max;\t/* maximum hash-value (only HASH format) */\n"
  "\tkern_colmeta\tcolmeta[FLEXIBLE_ARRAY_MEMBER]; /* metadata of columns */\n"
  "} kern_data_store;\n"
  "\n"
  "\n"
  "/* length estimator */\n"
  "#define KDS_CALCULATE_HEAD_LENGTH(ncols)\t\t\\\n"
  "\tSTROMALIGN(offsetof(kern_data_store, colmeta[(ncols)]))\n"
  "\n"
  "#define KDS_CALCULATE_FRONTEND_LENGTH(ncols,nslots,nitems)\t\\\n"
  "\t(KDS_CALCULATE_HEAD_LENGTH(ncols) +\t\t\t\\\n"
  "\t STROMALIGN(sizeof(cl_uint) * (nitems)) +\t\\\n"
  "\t STROMALIGN(sizeof(cl_uint) * (nslots)))\n"
  "\n"
  "/* 'nslots' estimation; 25% larger than nitems, but 128 at least */\n"
  "#define __KDS_NSLOTS(nitems)\t\t\t\t\t\\\n"
  "\tMax(128, ((nitems) * 5) >> 2)\n"
  "#define KDS_CALCULATE_ROW_FRONTLEN(ncols,nitems)\t\\\n"
  "\tKDS_CALCULATE_FRONTEND_LENGTH((ncols),0,(nitems))\n"
  "#define KDS_CALCULATE_HASH_FRONTLEN(ncols,nitems)\t\\\n"
  "\tKDS_CALCULATE_FRONTEND_LENGTH((ncols),__KDS_NSLOTS(nitems),(nitems))\n"
  "#define KDS_CALCULATE_ROW_LENGTH(ncols,nitems,data_len)\t\t\\\n"
  "\t(KDS_CALCULATE_ROW_FRONTLEN((ncols),(nitems)) + STROMALIGN(data_len))\n"
  "#define KDS_CALCULATE_HASH_LENGTH(ncols,nitems,data_len)\t\\\n"
  "\t(KDS_CALCULATE_HASH_FRONTLEN((ncols),(nitems)) + STROMALIGN(data_len))\n"
  "#define KDS_CALCULATE_SLOT_LENGTH(ncols,nitems)\t\\\n"
  "\t(KDS_CALCULATE_HEAD_LENGTH(ncols) +\t\t\t\\\n"
  "\t LONGALIGN((sizeof(Datum) +\t\t\t\t\t\\\n"
  "\t\t\t\tsizeof(char)) * (ncols)) * (nitems))\n"
  "/* gsage growth by the next tuple (row) */\n"
  "#define KDS_ROW_USAGE_GROWTH(nitems, consumption)\t\t\t\\\n"
  "\t(STROMALIGN(sizeof(cl_uint) * ((nitems) + 1)) -\t\t\t\\\n"
  "\t STROMALIGN(sizeof(cl_uint) * (nitems)) +\t\t\t\t\\\n"
  "\t MAXALIGN(consumption))\n"
  "/* usage growth by the next one tuple (hash) */\n"
  "#define KDS_HASH_USAGE_GROWTH(nitems, consumption)\t\t\t\\\n"
  "\t(STROMALIGN(sizeof(cl_uint) * ((nitems) + 1)) -\t\t\t\\\n"
  "\t STROMALIGN(sizeof(cl_uint) * (nitems)) +\t\t\t\t\\\n"
  "\t STROMALIGN(sizeof(cl_uint) * __KDS_NSLOTS((nitems) + 1)) -\t\\\n"
  "\t STROMALIGN(sizeof(cl_uint) * __KDS_NSLOTS(nitems)) +\t\\\n"
  "\t MAXALIGN(consumption))\n"
  "\n"
  "/* length of kern_data_store */\n"
  "#define KERN_DATA_STORE_LENGTH(kds)\t\t((kds)->length)\n"
  "\n"
  "/* length of the header portion of kern_data_store */\n"
  "#define KERN_DATA_STORE_HEAD_LENGTH(kds)\t\t\t\\\n"
  "\tKDS_CALCULATE_HEAD_LENGTH((kds)->ncols)\n"
  "\n"
  "/* head address of data body */\n"
  "#define KERN_DATA_STORE_BODY(kds)\t\t\t\t\t\\\n"
  "\t((char *)(kds) + KERN_DATA_STORE_HEAD_LENGTH(kds))\n"
  "\n"
  "/* access macro for row- and hash-format */\n"
  "#define KERN_DATA_STORE_ROWINDEX(kds)\t\t\t\t\\\n"
  "\t((cl_uint *)(KERN_DATA_STORE_BODY(kds)))\n"
  "\n"
  "/* access macro for hash-format */\n"
  "#define KERN_DATA_STORE_HASHSLOT(kds)\t\t\t\t\\\n"
  "\t((cl_uint *)(KERN_DATA_STORE_BODY(kds) +\t\t\\\n"
  "\t\t\t\t STROMALIGN(sizeof(cl_uint) * (kds)->nitems)))\n"
  "\n"
  "/* access macro for row- and hash-format */\n"
  "#define KERN_DATA_STORE_TUPITEM(kds,kds_index)\t\t\\\n"
  "\t((kern_tupitem *)((char *)(kds) +\t\t\t\t\\\n"
  "\t\t\t\t\t  (KERN_DATA_STORE_ROWINDEX(kds)[(kds_index)])))\n"
  "\n"
  "/* access macro for hash-format */\n"
  "#define KERN_DATA_STORE_HASHITEM(kds,kds_index)\t\t\\\n"
  "\t((kern_hashitem *)\t\t\t\t\t\t\t\t\\\n"
  "\t ((char *)KERN_DATA_STORE_TUPITEM(kds,kds_index) -\t\\\n"
  "\t  offsetof(kern_hashitem, t)))\n"
  "\n"
  "/* access macro for tuple-slot format */\n"
  "#define KERN_DATA_STORE_SLOT_LENGTH(kds,nitems)\t\t\t\t\\\n"
  "\tKDS_CALCULATE_SLOT_LENGTH((kds)->ncols,(nitems))\n"
  "\n"
  "#define KERN_DATA_STORE_VALUES(kds,kds_index)\t\t\t\t\\\n"
  "\t((Datum *)((char *)(kds) +\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t   KDS_CALCULATE_SLOT_LENGTH((kds)->ncols,(kds_index))))\n"
  "\n"
  "#define KERN_DATA_STORE_ISNULL(kds,kds_index)\t\t\t\t\\\n"
  "\t((char *)(KERN_DATA_STORE_VALUES((kds),(kds_index)) + (kds)->ncols))\n"
  "\n"
  "\n"
  "STATIC_INLINE(kern_hashitem *)\n"
  "KERN_HASH_FIRST_ITEM(kern_data_store *kds, cl_uint hash)\n"
  "{\n"
  "\tcl_uint\t   *slot = KERN_DATA_STORE_HASHSLOT(kds);\n"
  "\tcl_uint\t\tindex = hash % kds->nslots;\n"
  "\n"
  "\tif (slot[index] == 0)\n"
  "\t\treturn NULL;\n"
  "\treturn (kern_hashitem *)((char *)kds + slot[index]);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(kern_hashitem *)\n"
  "KERN_HASH_NEXT_ITEM(kern_data_store *kds, kern_hashitem *khitem)\n"
  "{\n"
  "\tif (!khitem || khitem->next == 0)\n"
  "\t\treturn NULL;\n"
  "\treturn (kern_hashitem *)((char *)kds + khitem->next);\n"
  "}\n"
  "\n"
  "/* transform device pointer to host address */\n"
  "#define devptr_to_host(kds,devptr)\t\t\\\n"
  "\t((hostptr_t)(devptr) -\t\t\t\t\\\n"
  "\t (hostptr_t)(&(kds)->hostptr) +\t\t\\\n"
  "\t (hostptr_t)((kds)->hostptr))\n"
  "/* transform host pointer to device address */\n"
  "#define hostptr_to_dev(kds,hostptr)\t\t\\\n"
  "\t((hostptr_t)(hostptr) -\t\t\t\t\\\n"
  "\t (hostptr_t)((kds)->hostptr) +\t\t\\\n"
  "\t (hostptr_t)(&(kds)->hostptr))\n"
  "\n"
  "/*\n"
  " * kern_parambuf\n"
  " *\n"
  " * Const and Parameter buffer. It stores constant values during a particular\n"
  " * scan, so it may make sense if it is obvious length of kern_parambuf is\n"
  " * less than constant memory (NOTE: not implemented yet).\n"
  " */\n"
  "typedef struct kern_parambuf\n"
  "{\n"
  "\thostptr_t\thostptr;\t/* address of the parambuf on host-side */\n"
  "\n"
  "\t/*\n"
  "\t * Fields of system information on execution\n"
  "\t */\n"
  "\tcl_long\t\txactStartTimestamp;\t/* timestamp when transaction start */\n"
  "\n"
  "\t/* variable length parameters / constants */\n"
  "\tcl_uint\t\tlength;\t\t/* total length of parambuf */\n"
  "\tcl_uint\t\tnparams;\t/* number of parameters */\n"
  "\tcl_uint\t\tpoffset[FLEXIBLE_ARRAY_MEMBER];\t/* offset of params */\n"
  "} kern_parambuf;\n"
  "\n"
  "STATIC_INLINE(void *)\n"
  "kparam_get_value(kern_parambuf *kparams, cl_uint pindex)\n"
  "{\n"
  "\tif (pindex >= kparams->nparams)\n"
  "\t\treturn NULL;\n"
  "\tif (kparams->poffset[pindex] == 0)\n"
  "\t\treturn NULL;\n"
  "\treturn (char *)kparams + kparams->poffset[pindex];\n"
  "}\n"
  "\n"
  "/*\n"
  " * kern_resultbuf\n"
  " *\n"
  " * Output buffer to write back calculation results on a parciular chunk.\n"
  " * kern_errorbuf informs an error status that shall be raised on host-\n"
  " * side to abort current transaction.\n"
  " */\n"
  "typedef struct {\n"
  "\tcl_uint\t\tnrels;\t\t/* number of relations to be appeared */\n"
  "\tcl_uint\t\tnrooms;\t\t/* max number of results rooms */\n"
  "\tcl_uint\t\tnitems;\t\t/* number of results being written */\n"
  "\tcl_char\t\tall_visible;/* GpuScan dumps all the tuples in chunk */\n"
  "\tcl_char\t\t__padding__[3];\n"
  "\tkern_errorbuf kerror;\t/* error information */\n"
  "\tcl_uint\t\tresults[FLEXIBLE_ARRAY_MEMBER];\n"
  "} kern_resultbuf;\n"
  "\n"
  "#define KERN_GET_RESULT(kresults, index)\t\t\\\n"
  "\t((kresults)->results + (kresults)->nrels * (index))\n"
  "\n"
  "#ifdef __CUDACC__\n"
  "/*\n"
  " * PostgreSQL Data Type support in OpenCL kernel\n"
  " *\n"
  " * A stream of data sequencea are moved to OpenCL kernel, according to\n"
  " * the above row-/column-store definition. The device code being generated\n"
  " * by PG-Strom deals with each data item using the following data type;\n"
  " *\n"
  " * typedef struct\n"
  " * {\n"
  " *     BASE    value;\n"
  " *     bool    isnull;\n"
  " * } pg_##NAME##_t\n"
  " *\n"
  " * PostgreSQL has three different data classes:\n"
  " *  - fixed-length referenced by value\n"
  " *  - fixed-length referenced by pointer\n"
  " *  - variable-length value\n"
  " *\n"
  " * Right now, we support the two except for fixed-length referenced by\n"
  " * pointer (because these are relatively minor data type than others).\n"
  " * BASE reflects the data type in PostgreSQL; may be an integer, a float\n"
  " * or something others, however, all the variable-length value has same\n"
  " * BASE type; that is an offset of associated toast buffer, to reference\n"
  " * varlena structure on the global memory.\n"
  " */\n"
  "\n"
  "/* forward declaration of access interface to kern_data_store */\n"
  "STATIC_INLINE(void *)\n"
  "kern_get_datum(kern_data_store *kds,\n"
  "\t\t\t   cl_uint colidx, cl_uint rowidx);\n"
  "\n"
  "/*\n"
  " * common function to store a value on tuple-slot format\n"
  " */\n"
  "STATIC_FUNCTION(void)\n"
  "pg_common_vstore(kern_data_store *kds,\n"
  "\t\t\t\t kern_context *kcxt,\n"
  "\t\t\t\t cl_uint colidx, cl_uint rowidx,\n"
  "\t\t\t\t Datum pg_value, cl_bool pg_isnull)\n"
  "{\n"
  "\tif (kds->format != KDS_FORMAT_SLOT)\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_SanityCheckViolation);\n"
  "\telse if (colidx >= kds->ncols || rowidx >= kds->nitems)\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_DataStoreOutOfRange);\n"
  "\telse\n"
  "\t{\n"
  "\t\tDatum\t   *ts_values = KERN_DATA_STORE_VALUES(kds, rowidx);\n"
  "\t\tcl_bool\t   *ts_isnull = KERN_DATA_STORE_ISNULL(kds, rowidx);\n"
  "\n"
  "\t\tts_isnull[colidx] = pg_isnull;\n"
  "\t\tts_values[colidx] = pg_value;\n"
  "\t}\n"
  "}\n"
  "\n"
  "/*\n"
  " * Template of variable classes: fixed-length referenced by value\n"
  " * ---------------------------------------------------------------\n"
  " */\n"
  "#define STROMCL_SIMPLE_DATATYPE_TEMPLATE(NAME,BASE)\t\t\t\\\n"
  "\ttypedef struct {\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tBASE\t\tvalue;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_bool\t\tisnull;\t\t\t\t\t\t\t\t\t\\\n"
  "\t} pg_##NAME##_t;\n"
  "\n"
  "#define STROMCL_SIMPLE_VARREF_TEMPLATE(NAME,BASE)\t\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_datum_ref(kern_context *kcxt,\t\t\t\t\\\n"
  "\t\t\t\t\t\t  void *datum,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  cl_bool internal_format)\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tpg_##NAME##_t\tresult;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (!datum)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = true;\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = false;\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.value = *((BASE *) datum);\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn result;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_vref(kern_data_store *kds,\t\t\t\t\t\\\n"
  "\t\t\t\t\t kern_context *kcxt,\t\t\t\t\t\\\n"
  "\t\t\t\t\t cl_uint colidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t cl_uint rowidx)\t\t\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tvoid  *datum = kern_get_datum(kds,colidx,rowidx);\t\\\n"
  "\t\treturn pg_##NAME##_datum_ref(kcxt,datum,false);\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_SIMPLE_VARSTORE_TEMPLATE(NAME,BASE)\t\t\t\\\n"
  "\tSTATIC_FUNCTION(void)\t\t\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_vstore(kern_data_store *kds,\t\t\t\t\\\n"
  "\t\t\t\t\t   kern_context *kcxt,\t\t\t\t\t\\\n"
  "\t\t\t\t\t   cl_uint colidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t   cl_uint rowidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t   pg_##NAME##_t pg_datum)\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tunion {\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tBASE\t\tv_base;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tDatum\t\tv_datum;\t\t\t\t\t\t\t\\\n"
  "\t\t} temp;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\ttemp.v_datum = 0UL;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\ttemp.v_base = pg_datum.value;\t\t\t\t\t\t\\\n"
  "\t\tpg_common_vstore(kds, kcxt, colidx, rowidx,\t\t\t\\\n"
  "\t\t\t\t\t\t temp.v_datum, pg_datum.isnull);\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_SIMPLE_PARAMREF_TEMPLATE(NAME,BASE)\t\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_param(kern_context *kcxt,cl_uint param_id)\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tkern_parambuf *kparams = kcxt->kparams;\t\t\t\t\\\n"
  "\t\tpg_##NAME##_t result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (param_id < kparams->nparams &&\t\t\t\t\t\\\n"
  "\t\t\tkparams->poffset[param_id] > 0)\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tBASE *addr = (BASE *)\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t((char *)kparams +\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t kparams->poffset[param_id]);\t\t\t\t\\\n"
  "\t\t\tresult.value = *addr;\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = false;\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = true;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn result;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_SIMPLE_NULLTEST_TEMPLATE(NAME)\t\t\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_bool_t)\t\t\t\t\t\t\t\t\\\n"
  "\tpgfn_##NAME##_isnull(kern_context *kcxt, pg_##NAME##_t arg)\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tpg_bool_t result;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tresult.isnull = false;\t\t\t\t\t\t\t\t\\\n"
  "\t\tresult.value = arg.isnull;\t\t\t\t\t\t\t\\\n"
  "\t\treturn result;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_bool_t)\t\t\t\t\t\t\t\t\\\n"
  "\tpgfn_##NAME##_isnotnull(kern_context *kcxt, pg_##NAME##_t arg)\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tpg_bool_t result;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tresult.isnull = false;\t\t\t\t\t\t\t\t\\\n"
  "\t\tresult.value = !arg.isnull;\t\t\t\t\t\t\t\\\n"
  "\t\treturn result;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "/*\n"
  " * Template of variable classes: fixed-length referenced by pointer\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "#define STROMCL_INDIRECT_VARREF_TEMPLATE(NAME,BASE)\t\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_datum_ref(kern_context *kcxt,\t\t\t\t\\\n"
  "\t\t\t\t\t\t  void *datum,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  cl_bool internal_format)\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tpg_##NAME##_t\tresult;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (!datum)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = true;\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = false;\t\t\t\t\t\t\t\\\n"
  "\t\t\tmemcpy(&result.value, (BASE *) datum,\t\t\t\\\n"
  "\t\t\t\t   sizeof(BASE));\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn result;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_vref(kern_data_store *kds,\t\t\t\t\t\\\n"
  "\t\t\t\t\t kern_context *kcxt,\t\t\t\t\t\\\n"
  "\t\t\t\t\t cl_uint colidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t cl_uint rowidx)\t\t\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tvoid  *datum = kern_get_datum(kds,colidx,rowidx);\t\\\n"
  "\t\treturn pg_##NAME##_datum_ref(kcxt,datum,false);\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_INDIRECT_VARSTORE_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTATIC_FUNCTION(void)\t\t\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_vstore(kern_data_store *kds,\t\t\t\t\\\n"
  "\t\t\t\t\t   kern_context *kcxt,\t\t\t\t\t\\\n"
  "\t\t\t\t\t   cl_uint colidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t   cl_uint rowidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t   pg_##NAME##_t pg_datum)\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t/* should not be used at this moment */\t\t\t\t\\\n"
  "\t\tassert(0);\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_INDIRECT_PARAMREF_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTATIC_FUNCTION(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_param(kern_context *kcxt,cl_uint param_id)\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tkern_parambuf *kparams = kcxt->kparams;\t\t\t\t\\\n"
  "\t\tpg_##NAME##_t result;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (param_id < kparams->nparams &&\t\t\t\t\t\\\n"
  "\t\t\tkparams->poffset[param_id] > 0)\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tBASE *addr = (BASE *)((char *)kparams +\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t  kparams->poffset[param_id]);\t\\\n"
  "\t\t\tmemcpy(&result.value, addr, sizeof(BASE));\t\t\\\n"
  "\t\t\tresult.isnull = false;\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tresult.isnull = true;\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn result;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "/*\n"
  " * Macros to calculate CRC32 value.\n"
  " * (logic was copied from pg_crc32.c)\n"
  " */\n"
  "#define INIT_LEGACY_CRC32(crc)\t\t((crc) = 0xFFFFFFFF)\n"
  "#define FIN_LEGACY_CRC32(crc)\t\t((crc) ^= 0xFFFFFFFF)\n"
  "#define EQ_LEGACY_CRC32(crc1,crc2)\t((crc1) == (crc2))\n"
  "\n"
  "STATIC_INLINE(cl_uint)\n"
  "pg_common_comp_crc32(const cl_uint *crc32_table,\n"
  "\t\t\t\t\t cl_uint hash,\n"
  "\t\t\t\t\t const char *__data, cl_uint __len)\n"
  "{\n"
  "\tcl_uint\t\t__index;\n"
  "\n"
  "\twhile (__len-- > 0)\n"
  "\t{\n"
  "\t\t__index = ((int) ((hash) >> 24) ^ *__data++) & 0xff;\n"
  "\t\thash = crc32_table[__index] ^ ((hash) << 8);\n"
  "\t}\n"
  "\treturn hash;\n"
  "}\n"
  "\n"
  "#define STROMCL_SIMPLE_COMP_CRC32_TEMPLATE(NAME,BASE)\t\t\t\\\n"
  "\tSTATIC_FUNCTION(cl_uint)\t\t\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_comp_crc32(const cl_uint *crc32_table,\t\t\t\\\n"
  "\t\t\t\t\t\t   cl_uint hash, pg_##NAME##_t datum)\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (!datum.isnull)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tunion {\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tBASE\tas_base;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\tchar\tas_char[sizeof(BASE)];\t\t\t\t\t\\\n"
  "\t\t\t} __data;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__data.as_base = datum.value;\t\t\t\t\t\t\\\n"
  "\t\t\thash = pg_common_comp_crc32(crc32_table,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\thash,\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t__data.as_char,\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\tsizeof(BASE));\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn hash;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_SIMPLE_TYPE_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTROMCL_SIMPLE_DATATYPE_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTROMCL_SIMPLE_VARREF_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTROMCL_SIMPLE_VARSTORE_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTROMCL_SIMPLE_PARAMREF_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTROMCL_SIMPLE_NULLTEST_TEMPLATE(NAME)\t\t\t\\\n"
  "\tSTROMCL_SIMPLE_COMP_CRC32_TEMPLATE(NAME,BASE)\n"
  "\n"
  "#define STROMCL_INDIRECT_TYPE_TEMPLATE(NAME,BASE)\t\\\n"
  "\tSTROMCL_SIMPLE_DATATYPE_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTROMCL_INDIRECT_VARREF_TEMPLATE(NAME,BASE)\t\t\\\n"
  "\tSTROMCL_INDIRECT_VARSTORE_TEMPLATE(NAME,BASE)\t\\\n"
  "\tSTROMCL_INDIRECT_PARAMREF_TEMPLATE(NAME,BASE)\t\\\n"
  "\tSTROMCL_SIMPLE_NULLTEST_TEMPLATE(NAME)          \\\n"
  "\tSTROMCL_SIMPLE_COMP_CRC32_TEMPLATE(NAME,BASE)\t\\\n"
  "\tSTATIC_INLINE(Datum)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_to_datum(BASE *p_value)\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn PointerGetDatum(p_value);\t\t\t\\\n"
  "\t}\n"
  "\n"
  "/* pg_bool_t */\n"
  "#ifndef PG_BOOL_TYPE_DEFINED\n"
  "#define PG_BOOL_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(bool, cl_bool)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_bool_to_datum(cl_bool value)\n"
  "{\n"
  "\treturn (Datum)(value ? true : false);\n"
  "}\n"
  "#endif\n"
  "\n"
  "/* pg_int2_t */\n"
  "#ifndef PG_INT2_TYPE_DEFINED\n"
  "#define PG_INT2_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(int2, cl_short)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_int2_to_datum(cl_short value)\n"
  "{\n"
  "\treturn (Datum)(((Datum) value) & 0x0000ffffUL);\n"
  "}\n"
  "#endif\n"
  "\n"
  "/* pg_int4_t */\n"
  "#ifndef PG_INT4_TYPE_DEFINED\n"
  "#define PG_INT4_TYPE_DEFINED\n"
  "/*STROMCL_SIMPLE_TYPE_TEMPLATE(int4, cl_long)*/\n"
  "\n"
  "/*#define STROMCL_SIMPLE_DATATYPE_TEMPLATE(NAME,BASE)\n"
  "STROMCL_SIMPLE_DATATYPE_TEMPLATE(int4, cl_int)*/\n"
  "typedef struct {\n"
  "\tcl_int\t\tvalue;\n"
  "\tcl_long\t\tvalue_comb;\n"
  "\tcl_bool\t\tisnull;\n"
  "} pg_int4_t;\t\n"
  "/*STROMCL_SIMPLE_VARREF_TEMPLATE(int4, cl_int)*/\n"
  "STATIC_FUNCTION(pg_int4_t)\t\t\t\t\t\t\t\\\n"
  "pg_int4_datum_ref(kern_context *kcxt,\t\t\t\t\\\n"
  "\t\t\t\t\t  void *datum,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t  cl_bool internal_format)\t\t\t\\\n"
  "{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tpg_int4_t\tresult;\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tif (!datum)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tresult.isnull = true;\t\t\t\t\t\t\t\\\n"
  "\telse\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tresult.isnull = false;\t\t\t\t\t\t\t\\\n"
  "\t\tresult.value = *((cl_int *) datum);\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\treturn result;\t\t\t\t\t\t\t\t\t\t\\\n"
  "}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "STATIC_FUNCTION(pg_int4_t)\t\t\t\t\t\t\t\\\n"
  "pg_int4_vref(kern_data_store *kds,\t\t\t\t\t\\\n"
  "\t\t\t\t kern_context *kcxt,\t\t\t\t\t\\\n"
  "\t\t\t\t cl_uint colidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t cl_uint rowidx)\t\t\t\t\t\t\\\n"
  "{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tvoid  *datum = kern_get_datum(kds,colidx,rowidx);\t\\\n"
  "\treturn pg_int4_datum_ref(kcxt,datum,false);\t\t\\\n"
  "}\n"
  "STROMCL_SIMPLE_VARSTORE_TEMPLATE(int4, cl_int)\n"
  "STROMCL_SIMPLE_PARAMREF_TEMPLATE(int4, cl_int)\n"
  "STROMCL_SIMPLE_NULLTEST_TEMPLATE(int4)\n"
  "STROMCL_SIMPLE_COMP_CRC32_TEMPLATE(int4, cl_int)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_int4_to_datum(cl_int value)\n"
  "{\n"
  "\treturn (Datum)(((Datum) value) & 0xffffffffUL);\n"
  "}\n"
  "#endif\n"
  "\n"
  "/* pg_int8_t */\n"
  "#ifndef PG_INT8_TYPE_DEFINED\n"
  "#define PG_INT8_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(int8, cl_long)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_int8_to_datum(cl_long value)\n"
  "{\n"
  "\treturn (Datum)(value);\n"
  "}\n"
  "#endif\n"
  "\n"
  "/* pg_float4_t */\n"
  "#ifndef PG_FLOAT4_TYPE_DEFINED\n"
  "#define PG_FLOAT4_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(float4, cl_float)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_float4_to_datum(cl_float value)\n"
  "{\n"
  "\treturn (Datum)((Datum)__float_as_int(value) & 0xffffffffUL);\n"
  "}\n"
  "#endif\n"
  "\n"
  "/* pg_float8_t */\n"
  "#ifndef PG_FLOAT8_TYPE_DEFINED\n"
  "#define PG_FLOAT8_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(float8, cl_double)\n"
  "STATIC_INLINE(Datum)\n"
  "pg_float8_to_datum(cl_double value)\n"
  "{\n"
  "\treturn (Datum)__double_as_longlong(value);\n"
  "}\n"
  "#endif\n"
  "\n"
  "/*\n"
  " * Template of variable classes: variable-length variables\n"
  " * ---------------------------------------------------------------\n"
  " *\n"
  " * Unlike host code, device code cannot touch external and/or compressed\n"
  " * toast datum. All the format device code can understand is usual\n"
  " * in-memory form; 4-bytes length is put on the head and contents follows.\n"
  " * So, it is a responsibility of host code to decompress the toast values\n"
  " * if device code may access compressed varlena.\n"
  " * In case when device code touches unsupported format, calculation result\n"
  " * shall be postponed to calculate on the host side.\n"
  " *\n"
  " * Note that it is harmless to have external and/or compressed toast datam\n"
  " * unless it is NOT referenced in the device code. It can understand the\n"
  " * length of these values, unlike contents.\n"
  " */\n"
  "typedef struct varlena {\n"
  "\tcl_char\t\tvl_len_[4];\t\t/* Do not touch this field directly! */\n"
  "\tcl_char\t\tvl_dat[1];\n"
  "} varlena;\n"
  "\n"
  "#define VARHDRSZ\t\t\t((int) sizeof(cl_int))\n"
  "#define VARDATA(PTR)\t\tVARDATA_4B(PTR)\n"
  "#define VARSIZE(PTR)\t\tVARSIZE_4B(PTR)\n"
  "#define VARSIZE_EXHDR(PTR)\t(VARSIZE(PTR) - VARHDRSZ)\n"
  "\n"
  "#define VARSIZE_SHORT(PTR)\tVARSIZE_1B(PTR)\n"
  "#define VARDATA_SHORT(PTR)\tVARDATA_1B(PTR)\n"
  "\n"
  "typedef union\n"
  "{\n"
  "\tstruct\t\t\t\t\t\t/* Normal varlena (4-byte length) */\n"
  "\t{\n"
  "\t\tcl_uint\t\tva_header;\n"
  "\t\tcl_char\t\tva_data[1];\n"
  "    }\t\tva_4byte;\n"
  "\tstruct\t\t\t\t\t\t/* Compressed-in-line format */\n"
  "\t{\n"
  "\t\tcl_uint\t\tva_header;\n"
  "\t\tcl_uint\t\tva_rawsize;\t/* Original data size (excludes header) */\n"
  "\t\tcl_char\t\tva_data[1];\t/* Compressed data */\n"
  "\t}\t\tva_compressed;\n"
  "} varattrib_4b;\n"
  "\n"
  "typedef struct\n"
  "{\n"
  "\tcl_uchar\tva_header;\n"
  "\tcl_char\t\tva_data[1];\t\t/* Data begins here */\n"
  "} varattrib_1b;\n"
  "\n"
  "/* inline portion of a short varlena pointing to an external resource */\n"
  "typedef struct\n"
  "{\n"
  "\tcl_uchar    va_header;\t\t/* Always 0x80 or 0x01 */\n"
  "\tcl_uchar\tva_tag;\t\t\t/* Type of datum */\n"
  "\tcl_char\t\tva_data[1];\t\t/* Data (of the type indicated by va_tag) */\n"
  "} varattrib_1b_e;\n"
  "\n"
  "typedef enum vartag_external\n"
  "{\n"
  "\tVARTAG_INDIRECT = 1,\n"
  "\tVARTAG_ONDISK = 18\n"
  "} vartag_external;\n"
  "\n"
  "#define VARHDRSZ_SHORT\t\t\toffsetof(varattrib_1b, va_data)\n"
  "#define VARATT_SHORT_MAX\t\t0x7F\n"
  "\n"
  "typedef struct varatt_external\n"
  "{\n"
  "\tcl_int\t\tva_rawsize;\t\t/* Original data size (includes header) */\n"
  "\tcl_int\t\tva_extsize;\t\t/* External saved size (doesn't) */\n"
  "\tcl_int\t\tva_valueid;\t\t/* Unique ID of value within TOAST table */\n"
  "\tcl_int\t\tva_toastrelid;\t/* RelID of TOAST table containing it */\n"
  "} varatt_external;\n"
  "\n"
  "typedef struct varatt_indirect\n"
  "{\n"
  "\thostptr_t\tpointer;\t/* Host pointer to in-memory varlena */\n"
  "} varatt_indirect;\n"
  "\n"
  "#define VARTAG_SIZE(tag) \\\n"
  "\t((tag) == VARTAG_INDIRECT ? sizeof(varatt_indirect) :\t\\\n"
  "\t (tag) == VARTAG_ONDISK ? sizeof(varatt_external) :\t\t\\\n"
  "\t 0 /* should not happen */)\n"
  "\n"
  "#define VARHDRSZ_EXTERNAL\t\toffsetof(varattrib_1b_e, va_data)\n"
  "#define VARTAG_EXTERNAL(PTR)\tVARTAG_1B_E(PTR)\n"
  "#define VARSIZE_EXTERNAL(PTR)\t\\\n"
  "\t(VARHDRSZ_EXTERNAL + VARTAG_SIZE(VARTAG_EXTERNAL(PTR)))\n"
  "\n"
  "#define VARATT_IS_4B(PTR) \\\n"
  "\t((((varattrib_1b *) (PTR))->va_header & 0x01) == 0x00)\n"
  "#define VARATT_IS_4B_U(PTR) \\\n"
  "\t((((varattrib_1b *) (PTR))->va_header & 0x03) == 0x00)\n"
  "#define VARATT_IS_4B_C(PTR) \\\n"
  "\t((((varattrib_1b *) (PTR))->va_header & 0x03) == 0x02)\n"
  "#define VARATT_IS_1B(PTR) \\\n"
  "\t((((varattrib_1b *) (PTR))->va_header & 0x01) == 0x01)\n"
  "#define VARATT_IS_1B_E(PTR) \\\n"
  "\t((((varattrib_1b *) (PTR))->va_header) == 0x01)\n"
  "#define VARATT_IS_COMPRESSED(PTR)\t\tVARATT_IS_4B_C(PTR)\n"
  "#define VARATT_IS_EXTERNAL(PTR)\t\t\tVARATT_IS_1B_E(PTR)\n"
  "#define VARATT_IS_EXTERNAL_ONDISK(PTR)\t\t\\\n"
  "\t(VARATT_IS_EXTERNAL(PTR) && VARTAG_EXTERNAL(PTR) == VARTAG_ONDISK)\n"
  "#define VARATT_IS_EXTERNAL_INDIRECT(PTR)\t\\\n"
  "\t(VARATT_IS_EXTERNAL(PTR) && VARTAG_EXTERNAL(PTR) == VARTAG_INDIRECT)\n"
  "#define VARATT_IS_SHORT(PTR)\t\t\tVARATT_IS_1B(PTR)\n"
  "#define VARATT_IS_EXTENDED(PTR)\t\t\t(!VARATT_IS_4B_U(PTR))\n"
  "#define VARATT_NOT_PAD_BYTE(PTR) \t\t(*((cl_uchar *) (PTR)) != 0)\n"
  "\n"
  "#define VARSIZE_4B(PTR)\t\t\t\t\t\t\\\n"
  "\t((((varattrib_4b *) (PTR))->va_4byte.va_header >> 2) & 0x3FFFFFFF)\n"
  "#define VARSIZE_1B(PTR) \\\n"
  "\t((((varattrib_1b *) (PTR))->va_header >> 1) & 0x7F)\n"
  "#define VARTAG_1B_E(PTR) \\\n"
  "\t(((varattrib_1b_e *) (PTR))->va_tag)\n"
  "\n"
  "#define VARRAWSIZE_4B_C(PTR)\t\\\n"
  "\t(((varattrib_4b *) (PTR))->va_compressed.va_rawsize)\n"
  "\n"
  "#define VARSIZE_ANY_EXHDR(PTR) \\\n"
  "\t(VARATT_IS_1B_E(PTR) ? VARSIZE_EXTERNAL(PTR)-VARHDRSZ_EXTERNAL : \\\n"
  "\t (VARATT_IS_1B(PTR) ? VARSIZE_1B(PTR)-VARHDRSZ_SHORT :\t\t\t \\\n"
  "\t  VARSIZE_4B(PTR)-VARHDRSZ))\n"
  "\n"
  "#define VARSIZE_ANY(PTR)\t\t\t\t\t\t\t\\\n"
  "\t(VARATT_IS_1B_E(PTR) ? VARSIZE_EXTERNAL(PTR) :\t\\\n"
  "\t (VARATT_IS_1B(PTR) ? VARSIZE_1B(PTR) :\t\t\t\\\n"
  "\t  VARSIZE_4B(PTR)))\n"
  "\n"
  "#define VARDATA_4B(PTR)\t(((varattrib_4b *) (PTR))->va_4byte.va_data)\n"
  "#define VARDATA_1B(PTR)\t(((varattrib_1b *) (PTR))->va_data)\n"
  "#define VARDATA_ANY(PTR) \\\n"
  "\t(VARATT_IS_1B(PTR) ? VARDATA_1B(PTR) : VARDATA_4B(PTR))\n"
  "\n"
  "#define SET_VARSIZE(PTR, len)\t\t\t\t\t\t\\\n"
  "\t(((varattrib_4b *)(PTR))->va_4byte.va_header = (((cl_uint) (len)) << 2))\n"
  "\n"
  "/*\n"
  " * toast_raw_datum_size - return the raw (detoasted) size of a varlena\n"
  " * datum (including the VARHDRSZ header)\n"
  " */\n"
  "STATIC_FUNCTION(size_t)\n"
  "toast_raw_datum_size(kern_context *kcxt, varlena *attr)\n"
  "{\n"
  "\tsize_t\t\tresult;\n"
  "\n"
  "\tif (VARATT_IS_EXTERNAL(attr))\n"
  "\t{\n"
  "\t\t/* should not appear in kernel space */\n"
  "\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\tresult = 0;\n"
  "\t}\n"
  "\telse if (VARATT_IS_COMPRESSED(attr))\n"
  "\t{\n"
  "\t\t/* here, va_rawsize is just the payload size */\n"
  "\t\tresult = VARRAWSIZE_4B_C(attr) + VARHDRSZ;\n"
  "\t}\n"
  "\telse if (VARATT_IS_SHORT(attr))\n"
  "\t{\n"
  "\t\t/*\n"
  "\t\t * we have to normalize the header length to VARHDRSZ or else the\n"
  "\t\t * callers of this function will be confused.\n"
  "\t\t */\n"
  "\t\tresult = VARSIZE_SHORT(attr) - VARHDRSZ_SHORT + VARHDRSZ;\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\t/* plain untoasted datum */\n"
  "\t\tresult = VARSIZE(attr);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Macro to extract a heap-tuple\n"
  " *\n"
  " * usage:\n"
  " * char   *addr;\n"
  " *\n"
  " * EXTRACT_HEAP_TUPLE_BEGIN(kds, htup, addr)\n"
  " *  -> addr shall point the device pointer of the first field, or NULL\n"
  " * EXTRACT_HEAP_TUPLE_NEXT(addr)\n"
  " *  -> addr shall point the device pointer of the second field, or NULL\n"
  " *     :\n"
  " * EXTRACT_HEAP_TUPLE_END()\n"
  " */\n"
  "#define EXTRACT_HEAP_TUPLE_BEGIN(ADDR, kds, htup)\t\t\t\t\t\t\\\n"
  "\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tHeapTupleHeaderData *__htup = (htup);\t\t\t\t\t\t\t\\\n"
  "\t\tkern_data_store\t*__kds = (kds);\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tkern_colmeta\t__cmeta;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\t\t__colidx = 0;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_uint\t\t\t__ncols;\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tcl_bool\t\t\t__heap_hasnull;\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tchar\t\t   *__pos;\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (!__htup)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__ncols = 0;\t/* to be considered as NULL */\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__heap_hasnull = ((__htup->t_infomask & HEAP_HASNULL) != 0); \\\n"
  "\t\t\t__ncols = min((kds)->ncols,\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  __htup->t_infomask2 & HEAP_NATTS_MASK);\t\t\\\n"
  "\t\t\t__cmeta = __kds->colmeta[__colidx];\t\t\t\t\t\t\t\\\n"
  "\t\t\t__pos = (char *)(__htup) + __htup->t_hoff;\t\t\t\t\t\\\n"
  "\t\t\tassert(__pos == (char *)MAXALIGN(__pos));\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (__colidx < __ncols &&\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t(!__heap_hasnull || !att_isnull(__colidx, __htup->t_bits)))\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t(ADDR) = __pos;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__pos += (__cmeta.attlen > 0 ?\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t  __cmeta.attlen :\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t  VARSIZE_ANY(__pos));\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t(ADDR) = NULL\n"
  "\n"
  "#define EXTRACT_HEAP_TUPLE_NEXT(ADDR)\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t__colidx++;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tif (__colidx < __ncols &&\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t(!__heap_hasnull || !att_isnull(__colidx, __htup->t_bits)))\t\\\n"
  "\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__cmeta = __kds->colmeta[__colidx];\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\tif (__cmeta.attlen > 0)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t__pos = (char *)TYPEALIGN(__cmeta.attalign, __pos);\t\t\\\n"
  "\t\t\telse if (!VARATT_NOT_PAD_BYTE(__pos))\t\t\t\t\t\t\\\n"
  "\t\t\t\t__pos = (char *)TYPEALIGN(__cmeta.attalign, __pos);\t\t\\\n"
  "\t\t\t(ADDR) = __pos;\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t__pos += (__cmeta.attlen > 0 ?\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t  __cmeta.attlen :\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t  VARSIZE_ANY(__pos));\t\t\t\t\t\t\t\t\\\n"
  "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t(ADDR) = NULL\n"
  "\n"
  "#define EXTRACT_HEAP_TUPLE_END()\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t} while(0)\n"
  "\n"
  "/*\n"
  " * kern_get_datum\n"
  " *\n"
  " * Reference to a particular datum on the supplied kernel data store.\n"
  " * It returns NULL, if it is a really null-value in context of SQL,\n"
  " * or in case when out of range with error code\n"
  " *\n"
  " * NOTE: We are paranoia for validation of the data being fetched from\n"
  " * the kern_data_store in row-format because we may see a phantom page\n"
  " * if the source transaction that required this kernel execution was\n"
  " * aborted during execution.\n"
  " * Once a transaction gets aborted, shared buffers being pinned are\n"
  " * released, even if DMA send request on the buffers are already\n"
  " * enqueued. In this case, the calculation result shall be discarded,\n"
  " * so no need to worry about correctness of the calculation, however,\n"
  " * needs to be care about address of the variables being referenced.\n"
  " */\n"
  "STATIC_FUNCTION(void *)\n"
  "kern_get_datum_tuple(kern_colmeta *colmeta,\n"
  "\t\t\t\t\t HeapTupleHeaderData *htup,\n"
  "\t\t\t\t\t cl_uint colidx)\n"
  "{\n"
  "\tcl_bool\t\theap_hasnull = ((htup->t_infomask & HEAP_HASNULL) != 0);\n"
  "\tcl_uint\t\toffset = htup->t_hoff;\n"
  "\tcl_uint\t\ti, ncols = (htup->t_infomask2 & HEAP_NATTS_MASK);\n"
  "\n"
  "\t/* shortcut if colidx is obviously out of range */\n"
  "\tif (colidx >= ncols)\n"
  "\t\treturn NULL;\n"
  "\t/* shortcut if tuple contains no NULL values */\n"
  "\tif (!heap_hasnull)\n"
  "\t{\n"
  "\t\tkern_colmeta\tcmeta = colmeta[colidx];\n"
  "\n"
  "\t\tif (cmeta.attcacheoff >= 0)\n"
  "\t\t\treturn (char *)htup + cmeta.attcacheoff;\n"
  "\t}\n"
  "\t/* regular path that walks on heap-tuple from the head */\n"
  "\tfor (i=0; i < ncols; i++)\n"
  "\t{\n"
  "\t\tif (heap_hasnull && att_isnull(i, htup->t_bits))\n"
  "\t\t{\n"
  "\t\t\tif (i == colidx)\n"
  "\t\t\t\treturn NULL;\n"
  "\t\t}\n"
  "\t\telse\n"
  "\t\t{\n"
  "\t\t\tkern_colmeta\tcmeta = colmeta[i];\n"
  "\t\t\tchar\t\t   *addr;\n"
  "\n"
  "\t\t\tif (cmeta.attlen > 0)\n"
  "\t\t\t\toffset = TYPEALIGN(cmeta.attalign, offset);\n"
  "\t\t\telse if (!VARATT_NOT_PAD_BYTE((char *)htup + offset))\n"
  "\t\t\t\toffset = TYPEALIGN(cmeta.attalign, offset);\n"
  "\t\t\t/* TODO: overrun checks here */\n"
  "\t\t\taddr = ((char *) htup + offset);\n"
  "\t\t\tif (i == colidx)\n"
  "\t\t\t\treturn addr;\n"
  "\t\t\toffset += (cmeta.attlen > 0\n"
  "\t\t\t\t\t   ? cmeta.attlen\n"
  "\t\t\t\t\t   : VARSIZE_ANY(addr));\n"
  "\t\t}\n"
  "\t}\n"
  "\treturn NULL;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(HeapTupleHeaderData *)\n"
  "kern_get_tuple_row(kern_data_store *kds, cl_uint rowidx)\n"
  "{\n"
  "\tkern_tupitem   *tupitem;\n"
  "\n"
  "\tif (rowidx >= kds->nitems)\n"
  "\t\treturn NULL;\t/* likely a BUG */\n"
  "\ttupitem = KERN_DATA_STORE_TUPITEM(kds, rowidx);\n"
  "\treturn &tupitem->htup;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(void *)\n"
  "kern_get_datum_row(kern_data_store *kds,\n"
  "\t\t\t\t   cl_uint colidx, cl_uint rowidx)\n"
  "{\n"
  "\tHeapTupleHeaderData *htup;\n"
  "\n"
  "\tif (colidx >= kds->ncols)\n"
  "\t\treturn NULL;\t/* likely a BUG */\n"
  "\thtup = kern_get_tuple_row(kds, rowidx);\n"
  "\tif (!htup)\n"
  "\t\treturn NULL;\n"
  "\treturn kern_get_datum_tuple(kds->colmeta, htup, colidx);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(void *)\n"
  "kern_get_datum_slot(kern_data_store *kds,\n"
  "\t\t\t\t\tcl_uint colidx, cl_uint rowidx)\n"
  "{\n"
  "\tDatum\t   *values = KERN_DATA_STORE_VALUES(kds,rowidx);\n"
  "\tcl_bool\t   *isnull = KERN_DATA_STORE_ISNULL(kds,rowidx);\n"
  "\tkern_colmeta\t\tcmeta = kds->colmeta[colidx];\n"
  "\n"
  "\tif (isnull[colidx])\n"
  "\t\treturn NULL;\n"
  "\tif (cmeta.attbyval)\n"
  "\t\treturn values + colidx;\n"
  "\treturn (char *)values[colidx];\n"
  "}\n"
  "\n"
  "STATIC_INLINE(void *)\n"
  "kern_get_datum(kern_data_store *kds,\n"
  "\t\t\t   cl_uint colidx, cl_uint rowidx)\n"
  "{\n"
  "\t/* is it out of range? */\n"
  "\tif (colidx >= kds->ncols || rowidx >= kds->nitems)\n"
  "\t\treturn NULL;\n"
  "\tif (kds->format == KDS_FORMAT_ROW ||\n"
  "\t\tkds->format == KDS_FORMAT_HASH)\n"
  "\t\treturn kern_get_datum_row(kds, colidx, rowidx);\n"
  "\tif (kds->format == KDS_FORMAT_SLOT)\n"
  "\t\treturn kern_get_datum_slot(kds, colidx, rowidx);\n"
  "\t/* TODO: put StromError_DataStoreCorruption error here */\n"
  "\treturn NULL;\n"
  "}\n"
  "\n"
  "/*\n"
  " * functions to reference variable length variables\n"
  " */\n"
  "STROMCL_SIMPLE_DATATYPE_TEMPLATE(varlena, varlena *)\n"
  "\n"
  "STATIC_FUNCTION(pg_varlena_t)\n"
  "pg_varlena_datum_ref(kern_context *kcxt,\n"
  "\t\t\t\t\t void *datum,\n"
  "\t\t\t\t\t cl_bool internal_format)\n"
  "{\n"
  "\tvarlena\t\t   *vl_val = (varlena *) datum;\n"
  "\tpg_varlena_t\tresult;\n"
  "\n"
  "\tif (!datum)\n"
  "\t\tresult.isnull = true;\n"
  "\telse\n"
  "\t{\n"
  "\t\tif (VARATT_IS_4B_U(vl_val) || VARATT_IS_1B(vl_val))\n"
  "\t\t{\n"
  "\t\t\tresult.isnull = false;\n"
  "\t\t\tresult.value = vl_val;\n"
  "\t\t}\n"
  "\t\telse\n"
  "\t\t{\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t}\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_varlena_t)\n"
  "pg_varlena_vref(kern_data_store *kds,\n"
  "\t\t\t\tkern_context *kcxt,\n"
  "\t\t\t\tcl_uint colidx,\n"
  "\t\t\t\tcl_uint rowidx)\n"
  "{\n"
  "\tvoid   *datum = kern_get_datum(kds,colidx,rowidx);\n"
  "\n"
  "\treturn pg_varlena_datum_ref(kcxt,datum,false);\n"
  "}\n"
  "\n"
  "STATIC_FUNCTION(pg_varlena_t)\n"
  "pg_varlena_param(kern_context *kcxt, cl_uint param_id)\n"
  "{\n"
  "\tkern_parambuf  *kparams = kcxt->kparams;\n"
  "\tpg_varlena_t\tresult;\n"
  "\n"
  "\tif (param_id < kparams->nparams &&\n"
  "\t\tkparams->poffset[param_id] > 0)\n"
  "\t{\n"
  "\t\tvarlena *vl_val = (varlena *)((char *)kparams +\n"
  "\t\t\t\t\t\t\t\t\t  kparams->poffset[param_id]);\n"
  "\t\tif (VARATT_IS_4B_U(vl_val) || VARATT_IS_1B(vl_val))\n"
  "\t\t{\n"
  "\t\t\tresult.value = vl_val;\n"
  "\t\t\tresult.isnull = false;\n"
  "\t\t}\n"
  "\t\telse\n"
  "\t\t{\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tSTROM_SET_ERROR(&kcxt->e, StromError_CpuReCheck);\n"
  "\t\t}\n"
  "\t}\n"
  "\telse\n"
  "\t\tresult.isnull = true;\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STROMCL_SIMPLE_NULLTEST_TEMPLATE(varlena)\n"
  "\n"
  "STATIC_FUNCTION(cl_uint)\n"
  "pg_varlena_comp_crc32(const cl_uint *crc32_table,\n"
  "\t\t\t\t\t  cl_uint hash, pg_varlena_t datum)\n"
  "{\n"
  "\tif (!datum.isnull)\n"
  "\t{\n"
  "\t\thash = pg_common_comp_crc32(crc32_table,\n"
  "\t\t\t\t\t\t\t\t\thash,\n"
  "\t\t\t\t\t\t\t\t\tVARDATA_ANY(datum.value),\n"
  "\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(datum.value));\n"
  "\t}\n"
  "\treturn hash;\n"
  "}\n"
  "\n"
  "#define STROMCL_VARLENA_DATATYPE_TEMPLATE(NAME)\t\t\t\t\\\n"
  "\ttypedef pg_varlena_t\tpg_##NAME##_t;\n"
  "\n"
  "#define STROMCL_VARLENA_VARREF_TEMPLATE(NAME)\t\t\t\t\\\n"
  "\tSTATIC_INLINE(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_datum_ref(kern_context *kcxt,\t\t\t\t\\\n"
  "\t\t\t\t\t\t  void *datum,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t  cl_bool internal_format)\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn pg_varlena_datum_ref(kcxt,datum,internal_format);\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_INLINE(pg_##NAME##_t)\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_vref(kern_data_store *kds,\t\t\t\t\t\\\n"
  "\t\t\t\t\t kern_context *kcxt,\t\t\t\t\t\\\n"
  "\t\t\t\t\t cl_uint colidx,\t\t\t\t\t\t\\\n"
  "\t\t\t\t\t cl_uint rowidx)\t\t\t\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\tvoid  *datum = kern_get_datum(kds,colidx,rowidx);\t\\\n"
  "\t\treturn pg_varlena_datum_ref(kcxt,datum,false);\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_VARLENA_VARSTORE_TEMPLATE(NAME)\t\t\t\t\\\n"
  "\tSTROMCL_SIMPLE_VARSTORE_TEMPLATE(NAME,varlena *)\n"
  "\n"
  "#define STROMCL_VARLENA_PARAMREF_TEMPLATE(NAME)\t\t\t\t\t\t\\\n"
  "\tSTATIC_INLINE(pg_##NAME##_t)\t\t\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_param(kern_context *kcxt, cl_uint param_id)\t\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn pg_varlena_param(kcxt,param_id);\t\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_VARLENA_NULLTEST_TEMPLATE(NAME)\t\t\t\t\t\t\\\n"
  "\tSTATIC_INLINE(pg_bool_t)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tpgfn_##NAME##_isnull(kern_context *kcxt, pg_##NAME##_t arg)\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn pgfn_varlena_isnull(kcxt, arg);\t\t\t\t\t\\\n"
  "\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tSTATIC_INLINE(pg_bool_t)\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tpgfn_##NAME##_isnotnull(kern_context *kcxt, pg_##NAME##_t arg)\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn pgfn_varlena_isnotnull(kcxt, arg);\t\t\t\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_VARLENA_COMP_CRC32_TEMPLATE(NAME)\t\t\t\t\t\\\n"
  "\tSTATIC_INLINE(cl_uint)\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\tpg_##NAME##_comp_crc32(const cl_uint *crc32_table,\t\t\t\t\\\n"
  "\t\t\t\t\t\t   cl_uint hash, pg_##NAME##_t datum)\t\t\\\n"
  "\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n"
  "\t\treturn pg_varlena_comp_crc32(crc32_table, hash, datum);\t\t\\\n"
  "\t}\n"
  "\n"
  "#define STROMCL_VARLENA_TYPE_TEMPLATE(NAME)\t\t\t\\\n"
  "\tSTROMCL_VARLENA_DATATYPE_TEMPLATE(NAME)\t\t\t\\\n"
  "\tSTROMCL_VARLENA_VARREF_TEMPLATE(NAME)\t\t\t\\\n"
  "\tSTROMCL_VARLENA_VARSTORE_TEMPLATE(NAME)\t\t\t\\\n"
  "\tSTROMCL_VARLENA_PARAMREF_TEMPLATE(NAME)\t\t\t\\\n"
  "\tSTROMCL_VARLENA_NULLTEST_TEMPLATE(NAME)\t\t\t\\\n"
  "\tSTROMCL_VARLENA_COMP_CRC32_TEMPLATE(NAME)\n"
  "\n"
  "/* pg_bytea_t */\n"
  "#ifndef PG_BYTEA_TYPE_DEFINED\n"
  "#define PG_BYTEA_TYPE_DEFINED\n"
  "STROMCL_VARLENA_TYPE_TEMPLATE(bytea)\n"
  "#endif\n"
  "\n"
  "/* ------------------------------------------------------------------\n"
  " *\n"
  " * Declaration of utility functions\n"
  " *\n"
  " * ------------------------------------------------------------------ */\n"
  "\n"
  "/*\n"
  " * pgstromStairlikeSum\n"
  " *\n"
  " * A utility routine to calculate sum of values when we have N items and \n"
  " * want to know sum of items[i=0...k] (k < N) for each k, using reduction\n"
  " * algorithm on local memory (so, it takes log2(N) + 1 steps)\n"
  " *\n"
  " * The 'my_value' argument is a value to be set on the items[get_local_id(0)].\n"
  " * Then, these are calculate as follows:\n"
  " *\n"
  " *           init   1st      2nd         3rd         4th\n"
  " *           state  step     step        step        step\n"
  " * items[0] = X0 -> X0    -> X0       -> X0       -> X0\n"
  " * items[1] = X1 -> X0+X1 -> X0+X1    -> X0+X1    -> X0+X1\n"
  " * items[2] = X2 -> X2    -> X0+...X2 -> X0+...X2 -> X0+...X2\n"
  " * items[3] = X3 -> X2+X3 -> X0+...X3 -> X0+...X3 -> X0+...X3\n"
  " * items[4] = X4 -> X4    -> X4       -> X0+...X4 -> X0+...X4\n"
  " * items[5] = X5 -> X4+X5 -> X4+X5    -> X0+...X5 -> X0+...X5\n"
  " * items[6] = X6 -> X6    -> X4+...X6 -> X0+...X6 -> X0+...X6\n"
  " * items[7] = X7 -> X6+X7 -> X4+...X7 -> X0+...X7 -> X0+...X7\n"
  " * items[8] = X8 -> X8    -> X8       -> X8       -> X0+...X8\n"
  " * items[9] = X9 -> X8+X9 -> X8+9     -> X8+9     -> X0+...X9\n"
  " *\n"
  " * In Nth step, we split the array into 2^N blocks. In 1st step, a unit\n"
  " * containt odd and even indexed items, and this logic adds the last value\n"
  " * of the earlier half onto each item of later half. In 2nd step, you can\n"
  " * also see the last item of the earlier half (item[1] or item[5]) shall\n"
  " * be added to each item of later half (item[2] and item[3], or item[6]\n"
  " * and item[7]). Then, iterate this step until 2^(# of steps) less than N.\n"
  " *\n"
  " * Note that supplied items[] must have at least sizeof(cl_uint) *\n"
  " * get_local_size(0), and its contents shall be destroyed.\n"
  " * Also note that this function internally use barrier(), so unable to\n"
  " * use within if-blocks.\n"
  " */\n"
  "STATIC_FUNCTION(cl_uint)\n"
  "pgstromStairlikeSum(cl_uint my_value, cl_uint *total_sum)\n"
  "{\n"
  "\tcl_uint\t   *items = SHARED_WORKMEM(cl_uint);\n"
  "\tcl_uint\t\tlocal_sz;\n"
  "\tcl_uint\t\tlocal_id;\n"
  "\tcl_uint\t\tunit_sz;\n"
  "\tcl_uint\t\tstair_sum;\n"
  "\tcl_int\t\ti, j;\n"
  "\n"
  "\t/* setup local size (pay attention, if 2D invocation) */\n"
  "\tlocal_sz = get_local_size();\n"
  "\tlocal_id = get_local_id();\n"
  "\tassert(local_id < local_sz);\n"
  "\n"
  "\t/* set initial value */\n"
  "\titems[local_id] = my_value;\n"
  "\t__syncthreads();\n"
  "\n"
  "\tfor (i=1, unit_sz = local_sz; unit_sz > 0; i++, unit_sz >>= 1)\n"
  "\t{\n"
  "\t\t/* index of last item in the earlier half of each 2^i unit */\n"
  "\t\tj = (local_id & ~((1 << i) - 1)) | ((1 << (i-1)) - 1);\n"
  "\n"
  "\t\t/* add item[j] if it is later half in the 2^i unit */\n"
  "\t\tif ((local_id & (1 << (i - 1))) != 0)\n"
  "\t\t\titems[local_id] += items[j];\n"
  "\t\t__syncthreads();\n"
  "\t}\n"
  "\tif (total_sum)\n"
  "\t\t*total_sum = items[local_sz - 1];\n"
  "\tstair_sum = local_id == 0 ? 0 : items[local_id - 1];\n"
  "\t__syncthreads();\n"
  "\treturn stair_sum;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Utility functions to reference system columns\n"
  " */\n"
  "STATIC_INLINE(Datum)\n"
  "kern_getsysatt_ctid(kern_data_store *kds, HeapTupleHeaderData *htup)\n"
  "{\n"
  "\t/*\n"
  "\t * NOTE: Both of kern_tupitem and kern_hashitem put t_self just\n"
  "\t * before the htup, with consideration of alignment.\n"
  "\t */\n"
  "\tItemPointerData\t   *p_self = (ItemPointerData *)\n"
  "\t\t((char *)htup - (offsetof(kern_tupitem, htup) -\n"
  "\t\t\t\t\t\t offsetof(kern_tupitem, t_self)));\n"
  "\treturn (Datum) devptr_to_host(kds, p_self);\n"
  "}\n"
  "\n"
  "STATIC_INLINE(Datum)\n"
  "kern_getsysatt_oid(kern_data_store *kds, HeapTupleHeaderData *htup)\n"
  "{\n"
  "\tif ((htup->t_infomask & HEAP_HASOID) != 0)\n"
  "\t\treturn *((cl_uint *)((char *) htup\n"
  "\t\t\t\t\t\t\t + htup->t_hoff\n"
  "\t\t\t\t\t\t\t - sizeof(cl_uint)));\n"
  "\treturn 0;\t/* InvalidOid */\n"
  "}\n"
  "\n"
  "STATIC_INLINE(Datum)\n"
  "kern_getsysatt_xmin(kern_data_store *kds, HeapTupleHeaderData *htup)\n"
  "{\n"
  "\treturn (Datum) htup->t_choice.t_heap.t_xmin;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(Datum)\n"
  "kern_getsysatt_xmax(kern_data_store *kds, HeapTupleHeaderData *htup)\n"
  "{\n"
  "\treturn (Datum) htup->t_choice.t_heap.t_xmax;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(Datum)\n"
  "kern_getsysatt_cmin(kern_data_store *kds, HeapTupleHeaderData *htup)\n"
  "{\n"
  "\treturn (Datum) htup->t_choice.t_heap.t_field3.t_cid;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(Datum)\n"
  "kern_getsysatt_cmax(kern_data_store *kds, HeapTupleHeaderData *htup)\n"
  "{\n"
  "\treturn (Datum) htup->t_choice.t_heap.t_field3.t_cid;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(Datum)\n"
  "kern_getsysatt_tableoid(kern_data_store *kds, HeapTupleHeaderData *htup)\n"
  "{\n"
  "\treturn kds->table_oid;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Forward function declarations) \n"
  " * - kern_form_heaptuple needs type transform function on the data type; that\n"
  " *   has special internal format. Right now, only NUMERIC data type has own\n"
  " *   internal data format.\n"
  " */\n"
  "STATIC_FUNCTION(cl_uint)\n"
  "pg_numeric_to_varlena(kern_context *kcxt, char *vl_buffer,\n"
  "\t\t\t\t\t  Datum value, cl_bool isnull);\n"
  "\n"
  "/*\n"
  " * compute_heaptuple_size\n"
  " */\n"
  "STATIC_FUNCTION(cl_uint)\n"
  "compute_heaptuple_size(kern_context *kcxt,\n"
  "\t\t\t\t\t   kern_data_store *kds,\n"
  "\t\t\t\t\t   Datum *tup_values,\n"
  "\t\t\t\t\t   cl_bool *tup_isnull,\n"
  "\t\t\t\t\t   cl_bool *tup_internal)\n"
  "{\n"
  "\tcl_uint\t\tt_hoff;\n"
  "\tcl_uint\t\tdatalen = 0;\n"
  "\tcl_uint\t\ti, ncols = kds->ncols;\n"
  "\tcl_bool\t\theap_hasnull = false;\n"
  "\n"
  "\t/* compute data length */\n"
  "\tfor (i=0; i < ncols; i++)\n"
  "\t{\n"
  "\t\tkern_colmeta\tcmeta = kds->colmeta[i];\n"
  "\n"
  "\t\tif (tup_isnull[i])\n"
  "\t\t\theap_hasnull = true;\n"
  "\t\telse\n"
  "\t\t{\n"
  "\t\t\tif (tup_internal && tup_internal[i])\n"
  "\t\t\t{\n"
  "\t\t\t\t/*\n"
  "\t\t\t\t * NOTE: Right now, only numeric data type has internal\n"
  "\t\t\t\t * data representation. It has to be transformed to the\n"
  "\t\t\t\t * regular format prior to CPU write back.\n"
  "\t\t\t\t */\n"
  "\t\t\t\tdatalen = TYPEALIGN(sizeof(cl_uint), datalen);\n"
  "\t\t\t\tdatalen += pg_numeric_to_varlena(kcxt, NULL,\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t tup_values[i],\n"
  "\t\t\t\t\t\t\t\t\t\t\t\t tup_isnull[i]);\n"
  "\t\t\t}\n"
  "\t\t\telse if (cmeta.attlen > 0)\n"
  "\t\t\t{\n"
  "\t\t\t\tdatalen = TYPEALIGN(cmeta.attalign, datalen);\n"
  "\t\t\t    datalen += cmeta.attlen;\n"
  "\t\t\t}\n"
  "\t\t\telse\n"
  "\t\t\t{\n"
  "\t\t\t\tDatum\t\tdatum = tup_values[i];\n"
  "\t\t\t\tcl_uint\t\tvl_len = VARSIZE_ANY(datum);\n"
  "\n"
  "\t\t\t\tif (!VARATT_IS_1B(datum))\n"
  "\t\t\t\t\tdatalen = TYPEALIGN(cmeta.attalign, datalen);\n"
  "\t\t\t\tdatalen += vl_len;\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t/* compute header offset */\n"
  "\tt_hoff = offsetof(HeapTupleHeaderData, t_bits);\n"
  "\tif (heap_hasnull)\n"
  "\t\tt_hoff += bitmaplen(ncols);\n"
  "\tif (kds->tdhasoid)\n"
  "\t\tt_hoff += sizeof(cl_uint);\n"
  "\tt_hoff = MAXALIGN(t_hoff);\n"
  "\n"
  "\treturn t_hoff + datalen;\n"
  "}\n"
  "\n"
  "/*\n"
  " * deform_kern_heaptuple\n"
  " *\n"
  " * Like deform_heap_tuple in host side, it extracts the supplied tuple-item\n"
  " * into tup_values / tup_isnull array. Note that pointer datum shall be\n"
  " * adjusted to the host-side address space.\n"
  " */\n"
  "STATIC_FUNCTION(size_t)\n"
  "deform_kern_heaptuple(kern_context *kcxt,\n"
  "\t\t\t\t\t  kern_data_store *kds,\t\t/* in */\n"
  "\t\t\t\t\t  kern_tupitem *tupitem,\t/* in */\n"
  "\t\t\t\t\t  cl_uint\tnfields,\t\t/* in */\n"
  "\t\t\t\t\t  cl_bool\tas_host_addr,\t/* in */\n"
  "\t\t\t\t\t  Datum\t   *tup_values,\t\t/* out */\n"
  "\t\t\t\t\t  cl_bool  *tup_isnull)\t\t/* out */\n"
  "{\n"
  "\tHeapTupleHeaderData *htup = &tupitem->htup;\n"
  "\tcl_uint\t\toffset = htup->t_hoff;\n"
  "\tcl_uint\t\ti, ncols = (htup->t_infomask2 & HEAP_NATTS_MASK);\n"
  "\tcl_bool\t\ttup_hasnull = ((htup->t_infomask & HEAP_HASNULL) != 0);\n"
  "\tsize_t\t\textra_len = 0;\n"
  "\n"
  "\t/* sanity check */\n"
  "\tassert(kds->format == KDS_FORMAT_ROW);\n"
  "\n"
  "\t/*\n"
  "\t * In case of 'nfields' is less than length of array, we extract\n"
  "\t * the first N columns only. On the other hands, t_informask2\n"
  "\t * should not contain attributes than definition.\n"
  "\t */\n"
  "\tassert(ncols <= kds->ncols);\n"
  "\tncols = min(ncols, nfields);\n"
  "\n"
  "\tfor (i=0; i < ncols; i++)\n"
  "\t{\n"
  "\t\tif (tup_hasnull && att_isnull(i, htup->t_bits))\n"
  "\t\t{\n"
  "\t\t\ttup_isnull[i] = true;\n"
  "\t\t\ttup_values[i] = 0;\n"
  "\t\t}\n"
  "\t\telse\n"
  "\t\t{\n"
  "\t\t\tkern_colmeta\tcmeta = kds->colmeta[i];\n"
  "\t\t\tchar\t\t   *addr;\n"
  "\n"
  "\t\t\tif (cmeta.attlen > 0)\n"
  "\t\t\t\toffset = TYPEALIGN(cmeta.attalign, offset);\n"
  "\t\t\telse if (!VARATT_NOT_PAD_BYTE((char *)htup + offset))\n"
  "\t\t\t\toffset = TYPEALIGN(cmeta.attalign, offset);\n"
  "\n"
  "\t\t\t/*\n"
  "\t\t\t * Store the value\n"
  "\t\t\t */\n"
  "\t\t\taddr = ((char *) htup + offset);\n"
  "\t\t\tif (cmeta.attbyval)\n"
  "\t\t\t{\n"
  "\t\t\t\tif (cmeta.attlen == sizeof(cl_long))\n"
  "\t\t\t\t\ttup_values[i] = *((cl_long *) addr);\n"
  "\t\t\t\telse if (cmeta.attlen == sizeof(cl_int))\n"
  "\t\t\t\t\ttup_values[i] = *((cl_int *) addr);\n"
  "\t\t\t\telse if (cmeta.attlen == sizeof(cl_short))\n"
  "\t\t\t\t\ttup_values[i] = *((cl_short *) addr);\n"
  "\t\t\t\telse\n"
  "\t\t\t\t{\n"
  "\t\t\t\t\tassert(cmeta.attlen == sizeof(cl_char));\n"
  "\t\t\t\t\ttup_values[i] = *((cl_char *) addr);\n"
  "\t\t\t\t}\n"
  "\t\t\t\toffset += cmeta.attlen;\n"
  "\t\t\t}\n"
  "\t\t\telse\n"
  "\t\t\t{\n"
  "\t\t\t\tcl_uint\t\tattlen = (cmeta.attlen > 0\n"
  "\t\t\t\t\t\t\t\t\t  ? cmeta.attlen\n"
  "\t\t\t\t\t\t\t\t\t  : VARSIZE_ANY(addr));\n"
  "\t\t\t\t/* store the device or host pointer according to the flag */\n"
  "\t\t\t\ttup_values[i] = (as_host_addr\n"
  "\t\t\t\t\t\t\t\t ? devptr_to_host(kds, addr)\n"
  "\t\t\t\t\t\t\t\t : PointerGetDatum(addr));\n"
  "\t\t\t\toffset += attlen;\n"
  "\t\t\t\t/* caller may need extra area */\n"
  "\t\t\t\textra_len = TYPEALIGN(cmeta.attalign, extra_len);\n"
  "\t\t\t\textra_len += attlen;\n"
  "\t\t\t}\n"
  "\t\t\ttup_isnull[i] = false;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t/*\n"
  "\t * Fill up remaining columns if source tuple has less columns than\n"
  "\t * length of the array; that is definition of the destination\n"
  "\t */\n"
  "\twhile (i < nfields)\n"
  "\t\ttup_isnull[i++] = true;\n"
  "\n"
  "\treturn MAXALIGN(extra_len);\n"
  "}\n"
  "\n"
  "/*\n"
  " * form_kern_heaptuple\n"
  " *\n"
  " * A utility routine to build a kern_tupitem on the destination buffer\n"
  " * already allocated.\n"
  " *\n"
  " * kds          ... destination data-store\n"
  " * tupitem      ... kern_tupitem allocated on the kds\n"
  " * tuple_len    ... length of the tuple; shall be MAXALIGN(t_hoff) + data_len\n"
  " * heap_hasnull ... true, if tup_values/tup_isnull contains NULL\n"
  " * tup_values   ... array of result datum\n"
  " * tup_isnull   ... array of null flags\n"
  " * tup_internal ... array of internal flags\n"
  " */\n"
  "STATIC_FUNCTION(cl_uint)\n"
  "form_kern_heaptuple(kern_context *kcxt,\n"
  "\t\t\t\t\tkern_data_store *kds,\n"
  "\t\t\t\t\tkern_tupitem *tupitem,\n"
  "\t\t\t\t\tDatum *tup_values,\n"
  "\t\t\t\t\tcl_bool *tup_isnull,\n"
  "\t\t\t\t\tcl_bool *tup_internal)\n"
  "{\n"
  "\tHeapTupleHeaderData *htup;\n"
  "\tcl_uint\t\ti, ncols = kds->ncols;\n"
  "\tcl_bool\t\theap_hasnull;\n"
  "\tcl_ushort\tt_infomask;\n"
  "\tcl_uint\t\tt_hoff;\n"
  "\tcl_uint\t\tcurr;\n"
  "\n"
  "\t/* sanity checks */\n"
  "\tassert(kds->format == KDS_FORMAT_ROW);\n"
  "\n"
  "\t/* Does it have any NULL field? */\n"
  "\theap_hasnull = false;\n"
  "\tfor (i=0; i < ncols; i++)\n"
  "\t{\n"
  "\t\tif (tup_isnull[i])\n"
  "\t\t{\n"
  "\t\t\theap_hasnull = true;\n"
  "\t\t\tbreak;\n"
  "\t\t}\n"
  "\t}\n"
  "\tt_infomask = (heap_hasnull ? HEAP_HASNULL : 0);\n"
  "\n"
  "\t/* Compute header offset */\n"
  "\tt_hoff = offsetof(HeapTupleHeaderData, t_bits);\n"
  "\tif (heap_hasnull)\n"
  "\t\tt_hoff += bitmaplen(ncols);\n"
  "\tif (kds->tdhasoid)\n"
  "\t{\n"
  "\t\tt_infomask |= HEAP_HASOID;\n"
  "\t\tt_hoff += sizeof(cl_uint);\n"
  "\t}\n"
  "\tt_hoff = MAXALIGN(t_hoff);\n"
  "\n"
  "\t/* setup header of kern_tupitem */\n"
  "\t// titem->t_len shall be set up later\n"
  "\ttupitem->t_self.ip_blkid.bi_hi = 0xffff;\t/* InvalidBlockNumber */\n"
  "\ttupitem->t_self.ip_blkid.bi_lo = 0xffff;\n"
  "\ttupitem->t_self.ip_posid = 0;\t\t\t\t/* InvalidOffsetNumber */\n"
  "\thtup = &tupitem->htup;\n"
  "\n"
  "\t/* setup HeapTupleHeader */\n"
  "\t// datum_len_ shall be set later\n"
  "\thtup->t_choice.t_datum.datum_typmod = kds->tdtypmod;\n"
  "\thtup->t_choice.t_datum.datum_typeid = kds->tdtypeid;\n"
  "\thtup->t_ctid.ip_blkid.bi_hi = 0xffff;\n"
  "\thtup->t_ctid.ip_blkid.bi_lo = 0xffff;\n"
  "\thtup->t_ctid.ip_posid = 0;\n"
  "\thtup->t_infomask2 = (ncols & HEAP_NATTS_MASK);\n"
  "\t// htup->t_infomask shall be set up later\n"
  "\thtup->t_hoff = t_hoff;\n"
  "\tcurr = t_hoff;\n"
  "\n"
  "\t/* setup tuple body */\n"
  "\tfor (i=0; i < ncols; i++)\n"
  "\t{\n"
  "\t\tkern_colmeta\tcmeta = kds->colmeta[i];\n"
  "\t\tDatum\t\t\tdatum = tup_values[i];\n"
  "\t\tcl_bool\t\t\tisnull = tup_isnull[i];\n"
  "\n"
  "\t\tif (isnull)\n"
  "\t\t\thtup->t_bits[i >> 3] &= ~(1 << (i & 0x07));\n"
  "\t\telse\n"
  "\t\t{\n"
  "\t\t\tif (heap_hasnull)\n"
  "\t\t\t\thtup->t_bits[i >> 3] |= (1 << (i & 0x07));\n"
  "\n"
  "\t\t\tif (tup_internal && tup_internal[i])\n"
  "\t\t\t{\n"
  "\t\t\t\t/*\n"
  "\t\t\t\t * NOTE: Right now, only NUMERIC has internal data format.\n"
  "\t\t\t\t * It has to be transformed again prior to CPU write back.\n"
  "\t\t\t\t */\n"
  "\t\t\t\tcurr = TYPEALIGN(sizeof(cl_uint), curr);\n"
  "\t\t\t\tcurr += pg_numeric_to_varlena(kcxt, ((char *)htup + curr),\n"
  "\t\t\t\t\t\t\t\t\t\t\t  tup_values[i],\n"
  "\t\t\t\t\t\t\t\t\t\t\t  tup_isnull[i]);\n"
  "\t\t\t}\n"
  "\t\t\telse if (cmeta.attbyval)\n"
  "\t\t\t{\n"
  "\t\t\t\tchar   *dest;\n"
  "\n"
  "\t\t\t\twhile (TYPEALIGN(cmeta.attalign, curr) != curr)\n"
  "\t\t\t\t\t((char *)htup)[curr++] = '\\0';\n"
  "\t\t\t\tdest = (char *)htup + curr;\n"
  "\n"
  "\t\t\t\tif (cmeta.attlen == sizeof(cl_long))\n"
  "\t\t\t\t\t*((cl_long *) dest) = (cl_long) datum;\n"
  "\t\t\t\telse if (cmeta.attlen == sizeof(cl_int))\n"
  "\t\t\t\t\t*((cl_int *) dest) = (cl_int) (datum & 0xffffffff);\n"
  "\t\t\t\telse if (cmeta.attlen == sizeof(cl_short))\n"
  "\t\t\t\t\t*((cl_short *) dest) = (cl_short) (datum & 0x0000ffff);\n"
  "\t\t\t\telse\n"
  "\t\t\t\t{\n"
  "\t\t\t\t\tassert(cmeta.attlen == sizeof(cl_char));\n"
  "\t\t\t\t\t*((cl_char *) dest) = (cl_char) (datum & 0x000000ff);\n"
  "\t\t\t\t}\n"
  "\t\t\t\tcurr += cmeta.attlen;\n"
  "\t\t\t}\n"
  "\t\t\telse if (cmeta.attlen > 0)\n"
  "\t\t\t{\n"
  "\t\t\t\twhile (TYPEALIGN(cmeta.attalign, curr) != curr)\n"
  "\t\t\t\t\t((char *)htup)[curr++] = '\\0';\n"
  "\n"
  "\t\t\t\tmemcpy((char *)htup + curr, (char *)datum, cmeta.attlen);\n"
  "\n"
  "\t\t\t\tcurr += cmeta.attlen;\n"
  "\t\t\t}\n"
  "\t\t\telse\n"
  "\t\t\t{\n"
  "\t\t\t\tcl_uint\t\tvl_len = VARSIZE_ANY(datum);\n"
  "\n"
  "\t\t\t\tt_infomask |= HEAP_HASVARWIDTH;\n"
  "\t\t\t\t/* put 0 and align here, if not a short varlena */\n"
  "\t\t\t\tif (!VARATT_IS_1B(datum))\n"
  "\t\t\t\t{\n"
  "\t\t\t\t\twhile (TYPEALIGN(cmeta.attalign, curr) != curr)\n"
  "\t\t\t\t\t\t((char *)htup)[curr++] = '\\0';\n"
  "\t\t\t\t}\n"
  "\t\t\t\tmemcpy((char *)htup + curr, (char *)datum, vl_len);\n"
  "\t\t\t\tcurr += vl_len;\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\t}\n"
  "\tcurr += t_hoff;\t\t/* add header length */\n"
  "\ttupitem->t_len = curr;\n"
  "\tSET_VARSIZE(&htup->t_choice.t_datum, MAXALIGN(curr));\n"
  "\thtup->t_infomask = t_infomask;\n"
  "\n"
  "\treturn curr;\n"
  "}\n"
  "\n"
  "/* ------------------------------------------------------------\n"
  " *\n"
  " * Declarations of common built-in functions\n"
  " *\n"
  " * ------------------------------------------------------------\n"
  " */\n"
  "\n"
  "/* A utility function to evaluate pg_bool_t value as if built-in\n"
  " * bool variable.\n"
  " */\n"
  "STATIC_INLINE(cl_bool)\n"
  "EVAL(pg_bool_t arg)\n"
  "{\n"
  "\tif (!arg.isnull && arg.value != 0)\n"
  "\t\treturn true;\n"
  "\treturn false;\n"
  "}\n"
  "\n"
  "/*\n"
  " * Support routine for BoolExpr\n"
  " */\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "operator ! (pg_bool_t arg)\n"
  "{\n"
  "\targ.value = !arg.value;\n"
  "\treturn arg;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "operator && (pg_bool_t arg1, pg_bool_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\t/* If either of expression is FALSE, entire BoolExpr is also FALSE */\n"
  "\tif ((!arg1.isnull && !arg1.value) ||\n"
  "\t\t(!arg2.isnull && !arg2.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = false;\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = arg1.isnull | arg2.isnull;\n"
  "\t\tresult.value  = (arg1.value && arg2.value ? true : false);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "operator || (pg_bool_t arg1, pg_bool_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\t/* If either of expression is TRUE, entire BoolExpr is also TRUE */\n"
  "\tif ((!arg1.isnull && arg1.value) ||\n"
  "\t\t(!arg2.isnull && arg2.value))\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = true;\n"
  "\t}\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = arg1.isnull | arg2.isnull;\n"
  "\t\tresult.value  = (arg1.value || arg2.value ? true : false);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * macros for general binary compare functions\n"
  " */\n"
  "#define devfunc_int_comp(x,y)\t\t\t\t\t\\\n"
  "\t((x) < (y) ? -1 : ((x) > (y) ? 1 : 0))\n"
  "\n"
  "#define devfunc_float_comp(x,y)\t\t\t\t\t\\\n"
  "\t(isnan(x)\t\t\t\t\t\t\t\t\t\\\n"
  "\t ? (isnan(y)\t\t\t\t\t\t\t\t\\\n"
  "\t\t? 0\t\t/* NAN = NAM */\t\t\t\t\t\\\n"
  "\t\t: 1)\t/* NAN > non-NAN */\t\t\t\t\\\n"
  "\t : (isnan(y)\t\t\t\t\t\t\t\t\\\n"
  "\t\t? -1\t/* non-NAN < NAN */\t\t\t\t\\\n"
  "\t\t: devfunc_int_comp((x),(y))))\n"
  "\n"
  "/*\n"
  " * Functions for BooleanTest\n"
  " */\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "pgfn_bool_is_true(kern_context *kcxt, pg_bool_t result)\n"
  "{\n"
  "\tresult.value = (!result.isnull && result.value);\n"
  "\tresult.isnull = false;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "pgfn_bool_is_not_true(kern_context *kcxt, pg_bool_t result)\n"
  "{\n"
  "\tresult.value = (result.isnull || !result.value);\n"
  "\tresult.isnull = false;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "pgfn_bool_is_false(kern_context *kcxt, pg_bool_t result)\n"
  "{\n"
  "\tresult.value = (!result.isnull && !result.value);\n"
  "\tresult.isnull = false;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "pgfn_bool_is_not_false(kern_context *kcxt, pg_bool_t result)\n"
  "{\n"
  "\tresult.value = (result.isnull || result.value);\n"
  "\tresult.isnull = false;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "pgfn_bool_is_unknown(kern_context *kcxt, pg_bool_t result)\n"
  "{\n"
  "\tresult.value = result.isnull;\n"
  "\tresult.isnull = false;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "STATIC_INLINE(pg_bool_t)\n"
  "pgfn_bool_is_not_unknown(kern_context *kcxt, pg_bool_t result)\n"
  "{\n"
  "\tresult.value = !result.isnull;\n"
  "\tresult.isnull = false;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "#endif\t/* __CUDACC__ */\n"
  "#endif\t/* CUDA_COMMON_H */\n"
;
