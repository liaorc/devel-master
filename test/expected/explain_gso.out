--#
--#       Gpu Scan Explain TestCases. 
--#  [TODO] Do not test commented-out queries until GPUSort supports TOAST data process. 
--#         If will support it, please remake expected outs and test_init.sql
--#
set pg_strom.debug_force_gpusort to on;
set enable_hashagg to off;      --# force off HashAggregate
set random_page_cost=1000000;   --# force off index_scan.
set pg_strom.enable_gpuhashjoin to off;
set pg_strom.enable_gpusort to off;
set client_min_messages to warning;
set pg_strom.enabled=off;
-- normal case
explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

--grouping
explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between     1 and 10000 group by smlint_x;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Sort
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: smlint_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between 10001 and 20000 group by smlint_x;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Sort
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: smlint_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between 20001 and 30000 group by smlint_x;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Sort
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: smlint_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between 30001 and 40000 group by smlint_x;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Sort
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               ->  Seq Scan on public.strom_test
                     Output: smlint_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between     1 and 10000 group by integer_x ) as t where t.rowid%100=0;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.integer_x
         ->  Group
               Output: strom_test.integer_x
               Group Key: strom_test.integer_x
               ->  Sort
                     Output: strom_test.integer_x
                     Sort Key: strom_test.integer_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.integer_x
                           Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between 10001 and 20000 group by integer_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.integer_x
         ->  Group
               Output: strom_test.integer_x
               Group Key: strom_test.integer_x
               ->  Sort
                     Output: strom_test.integer_x
                     Sort Key: strom_test.integer_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.integer_x
                           Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between 20001 and 30000 group by integer_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.integer_x
         ->  Group
               Output: strom_test.integer_x
               Group Key: strom_test.integer_x
               ->  Sort
                     Output: strom_test.integer_x
                     Sort Key: strom_test.integer_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.integer_x
                           Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between 30001 and 40000 group by integer_x ) as t;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.integer_x
   ->  Group
         Output: strom_test.integer_x
         Group Key: strom_test.integer_x
         ->  Sort
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.integer_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between     1 and 10000 group by bigint_x ) as t where t.rowid%100=0;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.bigint_x
         ->  Group
               Output: strom_test.bigint_x
               Group Key: strom_test.bigint_x
               ->  Sort
                     Output: strom_test.bigint_x
                     Sort Key: strom_test.bigint_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.bigint_x
                           Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between 10001 and 20000 group by bigint_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.bigint_x
         ->  Group
               Output: strom_test.bigint_x
               Group Key: strom_test.bigint_x
               ->  Sort
                     Output: strom_test.bigint_x
                     Sort Key: strom_test.bigint_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.bigint_x
                           Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between 20001 and 30000 group by bigint_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.bigint_x
         ->  Group
               Output: strom_test.bigint_x
               Group Key: strom_test.bigint_x
               ->  Sort
                     Output: strom_test.bigint_x
                     Sort Key: strom_test.bigint_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.bigint_x
                           Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between 30001 and 40000 group by bigint_x ) as t;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.bigint_x
   ->  Group
         Output: strom_test.bigint_x
         Group Key: strom_test.bigint_x
         ->  Sort
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.bigint_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between     1 and 10000 group by real_x ) as t where t.rowid%100=0;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.real_x
         ->  Group
               Output: strom_test.real_x
               Group Key: strom_test.real_x
               ->  Sort
                     Output: strom_test.real_x
                     Sort Key: strom_test.real_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.real_x
                           Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between 10001 and 20000 group by real_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.real_x
         ->  Group
               Output: strom_test.real_x
               Group Key: strom_test.real_x
               ->  Sort
                     Output: strom_test.real_x
                     Sort Key: strom_test.real_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.real_x
                           Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between 20001 and 30000 group by real_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.real_x
         ->  Group
               Output: strom_test.real_x
               Group Key: strom_test.real_x
               ->  Sort
                     Output: strom_test.real_x
                     Sort Key: strom_test.real_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.real_x
                           Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between 30001 and 40000 group by real_x ) as t;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.real_x
   ->  Group
         Output: strom_test.real_x
         Group Key: strom_test.real_x
         ->  Sort
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.real_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between     1 and 10000 group by float_x ) as t where t.rowid%100=0;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.float_x
         ->  Group
               Output: strom_test.float_x
               Group Key: strom_test.float_x
               ->  Sort
                     Output: strom_test.float_x
                     Sort Key: strom_test.float_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.float_x
                           Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between 10001 and 20000 group by float_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.float_x
         ->  Group
               Output: strom_test.float_x
               Group Key: strom_test.float_x
               ->  Sort
                     Output: strom_test.float_x
                     Sort Key: strom_test.float_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.float_x
                           Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between 20001 and 30000 group by float_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.float_x
         ->  Group
               Output: strom_test.float_x
               Group Key: strom_test.float_x
               ->  Sort
                     Output: strom_test.float_x
                     Sort Key: strom_test.float_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.float_x
                           Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between 30001 and 40000 group by float_x ) as t;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.float_x
   ->  Group
         Output: strom_test.float_x
         Group Key: strom_test.float_x
         ->  Sort
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.float_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between     1 and 10000 group by nume_x ) as t where t.rowid%100=0;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.nume_x
         ->  Group
               Output: strom_test.nume_x
               Group Key: strom_test.nume_x
               ->  Sort
                     Output: strom_test.nume_x
                     Sort Key: strom_test.nume_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.nume_x
                           Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between 10001 and 20000 group by nume_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.nume_x
         ->  Group
               Output: strom_test.nume_x
               Group Key: strom_test.nume_x
               ->  Sort
                     Output: strom_test.nume_x
                     Sort Key: strom_test.nume_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.nume_x
                           Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between 20001 and 30000 group by nume_x ) as t where t.rowid%100=0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.nume_x
         ->  Group
               Output: strom_test.nume_x
               Group Key: strom_test.nume_x
               ->  Sort
                     Output: strom_test.nume_x
                     Sort Key: strom_test.nume_x
                     ->  Seq Scan on public.strom_test
                           Output: strom_test.nume_x
                           Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(14 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between 30001 and 40000 group by nume_x ) as t;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.nume_x
   ->  Group
         Output: strom_test.nume_x
         Group Key: strom_test.nume_x
         ->  Sort
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.nume_x
                     Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
(11 rows)

--merge
set enable_hashjoin to off;
explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.smlint_x desc) as rowid,t1.smlint_x,t2.smlint_x from strom_test t1, strom_test t2 where t1.smlint_x=t2.smlint_x and t1.id%100=0) as t where t.rowid%1000=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x, t.smlint_x_1
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.smlint_x, t2.smlint_x
         ->  Merge Join
               Output: t1.smlint_x, t2.smlint_x
               Merge Cond: (t1.smlint_x = t2.smlint_x)
               ->  Sort
                     Output: t1.smlint_x
                     Sort Key: t1.smlint_x DESC
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.smlint_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.smlint_x
                     Sort Key: t2.smlint_x DESC
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.smlint_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.smlint_x asc) as rowid,t1.smlint_x,t2.smlint_x from strom_test t1, strom_test t2 where t1.smlint_x=t2.smlint_x and t1.id%100=0) as t where t.rowid%1000=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x, t.smlint_x_1
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.smlint_x, t2.smlint_x
         ->  Merge Join
               Output: t1.smlint_x, t2.smlint_x
               Merge Cond: (t1.smlint_x = t2.smlint_x)
               ->  Sort
                     Output: t1.smlint_x
                     Sort Key: t1.smlint_x
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.smlint_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.smlint_x
                     Sort Key: t2.smlint_x
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.smlint_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.integer_x desc) as rowid,t1.integer_x,t2.integer_x from strom_test t1, strom_test t2 where t1.integer_x=t2.integer_x and t1.id%100=0) as t where t.rowid%10=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x, t.integer_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.integer_x, t2.integer_x
         ->  Merge Join
               Output: t1.integer_x, t2.integer_x
               Merge Cond: (t1.integer_x = t2.integer_x)
               ->  Sort
                     Output: t1.integer_x
                     Sort Key: t1.integer_x DESC
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.integer_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.integer_x
                     Sort Key: t2.integer_x DESC
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.integer_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.integer_x asc) as rowid,t1.integer_x,t2.integer_x from strom_test t1, strom_test t2 where t1.integer_x=t2.integer_x and t1.id%100=0) as t where t.rowid%10=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x, t.integer_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.integer_x, t2.integer_x
         ->  Merge Join
               Output: t1.integer_x, t2.integer_x
               Merge Cond: (t1.integer_x = t2.integer_x)
               ->  Sort
                     Output: t1.integer_x
                     Sort Key: t1.integer_x
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.integer_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.integer_x
                     Sort Key: t2.integer_x
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.integer_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.bigint_x desc) as rowid,t1.bigint_x,t2.bigint_x from strom_test t1, strom_test t2 where t1.bigint_x=t2.bigint_x and t1.id%100=0) as t where t.rowid%10=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x, t.bigint_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.bigint_x, t2.bigint_x
         ->  Merge Join
               Output: t1.bigint_x, t2.bigint_x
               Merge Cond: (t1.bigint_x = t2.bigint_x)
               ->  Sort
                     Output: t1.bigint_x
                     Sort Key: t1.bigint_x DESC
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.bigint_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.bigint_x
                     Sort Key: t2.bigint_x DESC
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.bigint_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.bigint_x asc) as rowid,t1.bigint_x,t2.bigint_x from strom_test t1, strom_test t2 where t1.bigint_x=t2.bigint_x and t1.id%100=0) as t where t.rowid%10=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x, t.bigint_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.bigint_x, t2.bigint_x
         ->  Merge Join
               Output: t1.bigint_x, t2.bigint_x
               Merge Cond: (t1.bigint_x = t2.bigint_x)
               ->  Sort
                     Output: t1.bigint_x
                     Sort Key: t1.bigint_x
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.bigint_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.bigint_x
                     Sort Key: t2.bigint_x
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.bigint_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.real_x desc) as rowid,t1.real_x,t2.real_x from strom_test t1, strom_test t2 where t1.real_x=t2.real_x and t1.id%100=0) as t where t.rowid%10=0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x, t.real_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.real_x, t2.real_x
         ->  Merge Join
               Output: t1.real_x, t2.real_x
               Merge Cond: (t1.real_x = t2.real_x)
               ->  Sort
                     Output: t1.real_x
                     Sort Key: t1.real_x DESC
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.real_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.real_x
                     Sort Key: t2.real_x DESC
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.real_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.real_x asc) as rowid,t1.real_x,t2.real_x from strom_test t1, strom_test t2 where t1.real_x=t2.real_x and t1.id%100=0) as t where t.rowid%10=0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x, t.real_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.real_x, t2.real_x
         ->  Merge Join
               Output: t1.real_x, t2.real_x
               Merge Cond: (t1.real_x = t2.real_x)
               ->  Sort
                     Output: t1.real_x
                     Sort Key: t1.real_x
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.real_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.real_x
                     Sort Key: t2.real_x
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.real_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.float_x desc) as rowid,t1.float_x,t2.float_x from strom_test t1, strom_test t2 where t1.float_x=t2.float_x and t1.id%100=0) as t where t.rowid%10=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x, t.float_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.float_x, t2.float_x
         ->  Merge Join
               Output: t1.float_x, t2.float_x
               Merge Cond: (t1.float_x = t2.float_x)
               ->  Sort
                     Output: t1.float_x
                     Sort Key: t1.float_x DESC
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.float_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.float_x
                     Sort Key: t2.float_x DESC
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.float_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.float_x asc) as rowid,t1.float_x,t2.float_x from strom_test t1, strom_test t2 where t1.float_x=t2.float_x and t1.id%100=0) as t where t.rowid%10=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x, t.float_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.float_x, t2.float_x
         ->  Merge Join
               Output: t1.float_x, t2.float_x
               Merge Cond: (t1.float_x = t2.float_x)
               ->  Sort
                     Output: t1.float_x
                     Sort Key: t1.float_x
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.float_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.float_x
                     Sort Key: t2.float_x
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.float_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.nume_x desc) as rowid,t1.nume_x,t2.nume_x from strom_test t1, strom_test t2 where t1.nume_x=t2.nume_x and t1.id%100=0) as t where t.rowid%10=0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x, t.nume_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.nume_x, t2.nume_x
         ->  Merge Join
               Output: t1.nume_x, t2.nume_x
               Merge Cond: (t1.nume_x = t2.nume_x)
               ->  Sort
                     Output: t1.nume_x
                     Sort Key: t1.nume_x DESC
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.nume_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.nume_x
                     Sort Key: t2.nume_x DESC
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.nume_x
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.nume_x asc) as rowid,t1.nume_x,t2.nume_x from strom_test t1, strom_test t2 where t1.nume_x=t2.nume_x and t1.id%100=0) as t where t.rowid%10=0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x, t.nume_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.nume_x, t2.nume_x
         ->  Merge Join
               Output: t1.nume_x, t2.nume_x
               Merge Cond: (t1.nume_x = t2.nume_x)
               ->  Sort
                     Output: t1.nume_x
                     Sort Key: t1.nume_x
                     ->  Seq Scan on public.strom_test t1
                           Output: t1.nume_x
                           Filter: ((t1.id % 100) = 0)
               ->  Sort
                     Output: t2.nume_x
                     Sort Key: t2.nume_x
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.nume_x
(19 rows)

--multikey
explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x desc,bigint_x desc,real_x desc,float_x desc,nume_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x DESC, strom_test.integer_x DESC, strom_test.bigint_x DESC, strom_test.real_x DESC, strom_test.float_x DESC, strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc,float_x  asc,nume_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc,float_x  asc,nume_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x DESC, strom_test.bigint_x, strom_test.real_x DESC, strom_test.float_x, strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc,float_x desc,nume_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x DESC, strom_test.integer_x, strom_test.bigint_x DESC, strom_test.real_x, strom_test.float_x DESC, strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x desc,smlint_x desc,integer_x desc,bigint_x desc,real_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x DESC, strom_test.nume_x DESC, strom_test.smlint_x DESC, strom_test.integer_x DESC, strom_test.bigint_x DESC, strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x  asc,smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x desc,smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x DESC, strom_test.smlint_x, strom_test.integer_x DESC, strom_test.bigint_x, strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x  asc,smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x DESC, strom_test.nume_x, strom_test.smlint_x DESC, strom_test.integer_x, strom_test.bigint_x DESC, strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x desc,bigint_x desc,real_x desc,float_x desc,nume_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x DESC, strom_test.integer_x DESC, strom_test.bigint_x DESC, strom_test.real_x DESC, strom_test.float_x DESC, strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc,float_x  asc,nume_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc,float_x  asc,nume_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x DESC, strom_test.bigint_x, strom_test.real_x DESC, strom_test.float_x, strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc,float_x desc,nume_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x DESC, strom_test.integer_x, strom_test.bigint_x DESC, strom_test.real_x, strom_test.float_x DESC, strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x desc,smlint_x desc,integer_x desc,bigint_x desc,real_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x DESC, strom_test.nume_x DESC, strom_test.smlint_x DESC, strom_test.integer_x DESC, strom_test.bigint_x DESC, strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x  asc,smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x desc,smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x DESC, strom_test.smlint_x, strom_test.integer_x DESC, strom_test.bigint_x, strom_test.real_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x  asc,smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x DESC, strom_test.nume_x, strom_test.smlint_x DESC, strom_test.integer_x, strom_test.bigint_x DESC, strom_test.real_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x desc,bigint_x desc,real_x desc,float_x desc,nume_x desc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x DESC, strom_test.integer_x DESC, strom_test.bigint_x DESC, strom_test.real_x DESC, strom_test.float_x DESC, strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc,float_x  asc,nume_x  asc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc,float_x  asc,nume_x desc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x DESC, strom_test.bigint_x, strom_test.real_x DESC, strom_test.float_x, strom_test.nume_x DESC
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc,float_x desc,nume_x  asc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Sort
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x DESC, strom_test.integer_x, strom_test.bigint_x DESC, strom_test.real_x, strom_test.float_x DESC, strom_test.nume_x
               ->  Seq Scan on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
(11 rows)

--gpusort on zero table
explain (verbose, costs off, timing off) select * from strom_zero_test order by smlint_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.smlint_x
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(5 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by integer_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.integer_x
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(5 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by bigint_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.bigint_x
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(5 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by real_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.real_x
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(5 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by float_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.float_x
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(5 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by nume_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.nume_x
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(5 rows)

--gpusort by text-key
explain (verbose, costs off, timing off) select * from (select row_number() over (order by char_x desc) as rowid,char_x from strom_string_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.char_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.char_x
         ->  Sort
               Output: strom_string_test.char_x
               Sort Key: strom_string_test.char_x COLLATE "C" DESC
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.char_x
(10 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by char_x asc) as rowid,char_x from strom_string_test) as t where t.rowid%100=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.char_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.char_x
         ->  Sort
               Output: strom_string_test.char_x
               Sort Key: strom_string_test.char_x COLLATE "C"
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.char_x
(10 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by nchar_x desc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.id, strom_string_test.nchar_x
         ->  Sort
               Output: strom_string_test.nchar_x, strom_string_test.id
               Sort Key: strom_string_test.nchar_x COLLATE "C" DESC
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.nchar_x, strom_string_test.id
(10 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by nchar_x asc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.id, strom_string_test.nchar_x
         ->  Sort
               Output: strom_string_test.nchar_x, strom_string_test.id
               Sort Key: strom_string_test.nchar_x COLLATE "C"
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.nchar_x, strom_string_test.id
(10 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by vchar_x desc) as rowid,vchar_x from strom_string_test) as t where t.rowid%100=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.vchar_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.vchar_x
         ->  Sort
               Output: strom_string_test.vchar_x
               Sort Key: strom_string_test.vchar_x COLLATE "C" DESC
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.vchar_x
(10 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by vchar_x asc) as rowid,vchar_x from strom_string_test) as t where t.rowid%100=0;
                            QUERY PLAN                            
------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.vchar_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.vchar_x
         ->  Sort
               Output: strom_string_test.vchar_x
               Sort Key: strom_string_test.vchar_x COLLATE "C"
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.vchar_x
(10 rows)

-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by nvchar_x desc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by nvchar_x asc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by text_x desc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by text_x asc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
--gpusort order by date/time types.
explain (verbose, costs off, timing off) select rowid,timestamp_x from (select timestamp_x, row_number() over (order by timestamp_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamp_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timestamp_x
               Sort Key: strom_time_test.timestamp_x
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamp_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,timestamp_x from (select timestamp_x, row_number() over (order by timestamp_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamp_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timestamp_x
               Sort Key: strom_time_test.timestamp_x NULLS FIRST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamp_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,timestamp_x from (select timestamp_x, row_number() over (order by timestamp_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamp_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timestamp_x
               Sort Key: strom_time_test.timestamp_x DESC NULLS LAST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamp_x
(10 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, timestamp_x from strom_time_test group by timestamp_x ) as t where t.rowid%50=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.timestamp_x
         ->  Group
               Output: strom_time_test.timestamp_x
               Group Key: strom_time_test.timestamp_x
               ->  Sort
                     Output: strom_time_test.timestamp_x
                     Sort Key: strom_time_test.timestamp_x
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.timestamp_x
(13 rows)

explain (verbose, costs off, timing off) select rowid,timestamptz_x from (select timestamptz_x, row_number() over (order by timestamptz_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamptz_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timestamptz_x
               Sort Key: strom_time_test.timestamptz_x
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamptz_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,timestamptz_x from (select timestamptz_x, row_number() over (order by timestamptz_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamptz_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timestamptz_x
               Sort Key: strom_time_test.timestamptz_x NULLS FIRST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamptz_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,timestamptz_x from (select timestamptz_x, row_number() over (order by timestamptz_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamptz_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timestamptz_x
               Sort Key: strom_time_test.timestamptz_x DESC NULLS LAST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamptz_x
(10 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, timestamptz_x from strom_time_test group by timestamptz_x ) as t where t.rowid%50=0;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.timestamptz_x
         ->  Group
               Output: strom_time_test.timestamptz_x
               Group Key: strom_time_test.timestamptz_x
               ->  Sort
                     Output: strom_time_test.timestamptz_x
                     Sort Key: strom_time_test.timestamptz_x
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.timestamptz_x
(13 rows)

explain (verbose, costs off, timing off) select rowid,date_x from (select date_x, row_number() over (order by date_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.date_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.date_x
               Sort Key: strom_time_test.date_x
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.date_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,date_x from (select date_x, row_number() over (order by date_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.date_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.date_x
               Sort Key: strom_time_test.date_x NULLS FIRST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.date_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,date_x from (select date_x, row_number() over (order by date_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                           QUERY PLAN                           
----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.date_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.date_x
               Sort Key: strom_time_test.date_x DESC NULLS LAST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.date_x
(10 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, date_x from strom_time_test group by date_x ) as t where t.rowid%50=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.date_x
         ->  Group
               Output: strom_time_test.date_x
               Group Key: strom_time_test.date_x
               ->  Sort
                     Output: strom_time_test.date_x
                     Sort Key: strom_time_test.date_x
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.date_x
(13 rows)

explain (verbose, costs off, timing off) select rowid,time_x from (select time_x, row_number() over (order by time_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.time_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.time_x
               Sort Key: strom_time_test.time_x
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.time_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,time_x from (select time_x, row_number() over (order by time_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.time_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.time_x
               Sort Key: strom_time_test.time_x NULLS FIRST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.time_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,time_x from (select time_x, row_number() over (order by time_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                           QUERY PLAN                           
----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.time_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.time_x
               Sort Key: strom_time_test.time_x DESC NULLS LAST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.time_x
(10 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, time_x from strom_time_test group by time_x ) as t where t.rowid%50=0;
                          QUERY PLAN                           
---------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.time_x
         ->  Group
               Output: strom_time_test.time_x
               Group Key: strom_time_test.time_x
               ->  Sort
                     Output: strom_time_test.time_x
                     Sort Key: strom_time_test.time_x
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.time_x
(13 rows)

explain (verbose, costs off, timing off) select rowid,timetz_x from (select timetz_x, row_number() over (order by timetz_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timetz_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timetz_x
               Sort Key: strom_time_test.timetz_x
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timetz_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,timetz_x from (select timetz_x, row_number() over (order by timetz_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timetz_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timetz_x
               Sort Key: strom_time_test.timetz_x NULLS FIRST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timetz_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,timetz_x from (select timetz_x, row_number() over (order by timetz_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                            
------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timetz_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.timetz_x
               Sort Key: strom_time_test.timetz_x DESC NULLS LAST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timetz_x
(10 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, timetz_x from strom_time_test group by timetz_x ) as t where t.rowid%50=0;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.timetz_x
         ->  Group
               Output: strom_time_test.timetz_x
               Group Key: strom_time_test.timetz_x
               ->  Sort
                     Output: strom_time_test.timetz_x
                     Sort Key: strom_time_test.timetz_x
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.timetz_x
(13 rows)

explain (verbose, costs off, timing off) select rowid,interval_x from (select interval_x, row_number() over (order by interval_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.interval_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.interval_x
               Sort Key: strom_time_test.interval_x
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.interval_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,interval_x from (select interval_x, row_number() over (order by interval_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.interval_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.interval_x
               Sort Key: strom_time_test.interval_x NULLS FIRST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.interval_x
(10 rows)

explain (verbose, costs off, timing off) select rowid,interval_x from (select interval_x, row_number() over (order by interval_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.interval_x, row_number() OVER (?)
         ->  Sort
               Output: strom_time_test.interval_x
               Sort Key: strom_time_test.interval_x DESC NULLS LAST
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.interval_x
(10 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, interval_x from strom_time_test group by interval_x ) as t where t.rowid%50=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.interval_x
         ->  Group
               Output: strom_time_test.interval_x
               Group Key: strom_time_test.interval_x
               ->  Sort
                     Output: strom_time_test.interval_x
                     Sort Key: strom_time_test.interval_x
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.interval_x
(13 rows)

set pg_strom.enabled=on;
set pg_strom.gpu_setup_cost=0;
set enable_hashagg to off;      --# force off HashAggregate
set random_page_cost=1000000;   --# force off index_scan.   
set pg_strom.enable_gpusort to on;
set pg_strom.enable_gpuhashjoin to off;                                                                                                                                       
set client_min_messages to warning;
-- normal case
explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,smlint_x from (select smlint_x, row_number() over (order by smlint_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.smlint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,integer_x from (select integer_x, row_number() over (order by integer_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.integer_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,bigint_x from (select bigint_x, row_number() over (order by bigint_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.bigint_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,real_x from (select real_x, row_number() over (order by real_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.real_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,float_x from (select float_x, row_number() over (order by float_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.float_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x desc) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select rowid,nume_x from (select nume_x, row_number() over (order by nume_x asc ) as rowid from strom_test where id between 30001 and 40000) as t where t.rowid%1000=0;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: strom_test.nume_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

--grouping
explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between     1 and 10000 group by smlint_x;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Custom Scan (GpuSort)
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: smlint_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between 10001 and 20000 group by smlint_x;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Custom Scan (GpuSort)
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: smlint_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between 20001 and 30000 group by smlint_x;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Custom Scan (GpuSort)
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: smlint_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select row_number() over () as rowid, smlint_x from strom_test where id between 30001 and 40000 group by smlint_x;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), smlint_x
   ->  Group
         Output: smlint_x
         Group Key: strom_test.smlint_x
         ->  Custom Scan (GpuSort)
               Output: smlint_x
               Sort Key: strom_test.smlint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: smlint_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between     1 and 10000 group by integer_x ) as t where t.rowid%100=0;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.integer_x
         ->  Group
               Output: strom_test.integer_x
               Group Key: strom_test.integer_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.integer_x
                     Sort Key: strom_test.integer_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.integer_x
                           Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between 10001 and 20000 group by integer_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.integer_x
         ->  Group
               Output: strom_test.integer_x
               Group Key: strom_test.integer_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.integer_x
                     Sort Key: strom_test.integer_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.integer_x
                           Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between 20001 and 30000 group by integer_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.integer_x
         ->  Group
               Output: strom_test.integer_x
               Group Key: strom_test.integer_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.integer_x
                     Sort Key: strom_test.integer_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.integer_x
                           Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, integer_x from strom_test where id between 30001 and 40000 group by integer_x ) as t;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.integer_x
   ->  Group
         Output: strom_test.integer_x
         Group Key: strom_test.integer_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.integer_x
               Sort Key: strom_test.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.integer_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between     1 and 10000 group by bigint_x ) as t where t.rowid%100=0;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.bigint_x
         ->  Group
               Output: strom_test.bigint_x
               Group Key: strom_test.bigint_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.bigint_x
                     Sort Key: strom_test.bigint_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.bigint_x
                           Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between 10001 and 20000 group by bigint_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.bigint_x
         ->  Group
               Output: strom_test.bigint_x
               Group Key: strom_test.bigint_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.bigint_x
                     Sort Key: strom_test.bigint_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.bigint_x
                           Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between 20001 and 30000 group by bigint_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.bigint_x
         ->  Group
               Output: strom_test.bigint_x
               Group Key: strom_test.bigint_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.bigint_x
                     Sort Key: strom_test.bigint_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.bigint_x
                           Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, bigint_x from strom_test where id between 30001 and 40000 group by bigint_x ) as t;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.bigint_x
   ->  Group
         Output: strom_test.bigint_x
         Group Key: strom_test.bigint_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.bigint_x
               Sort Key: strom_test.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.bigint_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between     1 and 10000 group by real_x ) as t where t.rowid%100=0;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.real_x
         ->  Group
               Output: strom_test.real_x
               Group Key: strom_test.real_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.real_x
                     Sort Key: strom_test.real_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.real_x
                           Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between 10001 and 20000 group by real_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.real_x
         ->  Group
               Output: strom_test.real_x
               Group Key: strom_test.real_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.real_x
                     Sort Key: strom_test.real_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.real_x
                           Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between 20001 and 30000 group by real_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.real_x
         ->  Group
               Output: strom_test.real_x
               Group Key: strom_test.real_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.real_x
                     Sort Key: strom_test.real_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.real_x
                           Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, real_x from strom_test where id between 30001 and 40000 group by real_x ) as t;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.real_x
   ->  Group
         Output: strom_test.real_x
         Group Key: strom_test.real_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.real_x
               Sort Key: strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.real_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between     1 and 10000 group by float_x ) as t where t.rowid%100=0;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.float_x
         ->  Group
               Output: strom_test.float_x
               Group Key: strom_test.float_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.float_x
                     Sort Key: strom_test.float_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.float_x
                           Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between 10001 and 20000 group by float_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.float_x
         ->  Group
               Output: strom_test.float_x
               Group Key: strom_test.float_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.float_x
                     Sort Key: strom_test.float_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.float_x
                           Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between 20001 and 30000 group by float_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.float_x
         ->  Group
               Output: strom_test.float_x
               Group Key: strom_test.float_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.float_x
                     Sort Key: strom_test.float_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.float_x
                           Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, float_x from strom_test where id between 30001 and 40000 group by float_x ) as t;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.float_x
   ->  Group
         Output: strom_test.float_x
         Group Key: strom_test.float_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.float_x
               Sort Key: strom_test.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.float_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between     1 and 10000 group by nume_x ) as t where t.rowid%100=0;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.nume_x
         ->  Group
               Output: strom_test.nume_x
               Group Key: strom_test.nume_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.nume_x
                     Sort Key: strom_test.nume_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.nume_x
                           Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between 10001 and 20000 group by nume_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.nume_x
         ->  Group
               Output: strom_test.nume_x
               Group Key: strom_test.nume_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.nume_x
                     Sort Key: strom_test.nume_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.nume_x
                           Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between 20001 and 30000 group by nume_x ) as t where t.rowid%100=0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.nume_x
         ->  Group
               Output: strom_test.nume_x
               Group Key: strom_test.nume_x
               ->  Custom Scan (GpuSort)
                     Output: strom_test.nume_x
                     Sort Key: strom_test.nume_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test
                           Output: strom_test.nume_x
                           Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                           Features: format: heap-tuple, bulkload: supported
(16 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, nume_x from strom_test where id between 30001 and 40000 group by nume_x ) as t;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?), strom_test.nume_x
   ->  Group
         Output: strom_test.nume_x
         Group Key: strom_test.nume_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.nume_x
               Sort Key: strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.nume_x
                     Device Filter: ((strom_test.id >= 30001) AND (strom_test.id <= 40000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

--merge
set enable_hashjoin to off;
set pg_strom.enable_gpuhashjoin to off;
explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.smlint_x desc) as rowid,t1.smlint_x,t2.smlint_x from strom_test t1, strom_test t2 where t1.smlint_x=t2.smlint_x and t1.id%100=0) as t where t.rowid%1000=0;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x, t.smlint_x_1
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.smlint_x, t2.smlint_x
         ->  Merge Join
               Output: t1.smlint_x, t2.smlint_x
               Merge Cond: (t1.smlint_x = t2.smlint_x)
               ->  Custom Scan (GpuSort)
                     Output: t1.smlint_x
                     Sort Key: t1.smlint_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.smlint_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: heap-tuple, bulkload: supported
               ->  Custom Scan (GpuSort)
                     Output: t2.smlint_x
                     Sort Key: t2.smlint_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.smlint_x
(22 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.smlint_x asc) as rowid,t1.smlint_x,t2.smlint_x from strom_test t1, strom_test t2 where t1.smlint_x=t2.smlint_x and t1.id%100=0) as t where t.rowid%1000=0;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.smlint_x, t.smlint_x_1
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.smlint_x, t2.smlint_x
         ->  Merge Join
               Output: t1.smlint_x, t2.smlint_x
               Merge Cond: (t1.smlint_x = t2.smlint_x)
               ->  Custom Scan (GpuSort)
                     Output: t1.smlint_x
                     Sort Key: t1.smlint_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.smlint_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: heap-tuple, bulkload: supported
               ->  Custom Scan (GpuSort)
                     Output: t2.smlint_x
                     Sort Key: t2.smlint_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_test t2
                           Output: t2.smlint_x
(22 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.integer_x desc) as rowid,t1.integer_x,t2.integer_x from strom_test t1, strom_test t2 where t1.integer_x=t2.integer_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x, t.integer_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.integer_x, t2.integer_x
         ->  Custom Scan (GpuSort)
               Output: t1.integer_x, t2.integer_x
               Sort Key: t1.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.integer_x, t2.integer_x
                     Pseudo Scan: t1.integer_x::integer, t2.integer_x::integer
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.integer_x = t2.integer_x)
                              Nrows (in/out: 0.39%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.integer_x asc) as rowid,t1.integer_x,t2.integer_x from strom_test t1, strom_test t2 where t1.integer_x=t2.integer_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.integer_x, t.integer_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.integer_x, t2.integer_x
         ->  Custom Scan (GpuSort)
               Output: t1.integer_x, t2.integer_x
               Sort Key: t1.integer_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.integer_x, t2.integer_x
                     Pseudo Scan: t1.integer_x::integer, t2.integer_x::integer
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.integer_x = t2.integer_x)
                              Nrows (in/out: 0.39%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.bigint_x desc) as rowid,t1.bigint_x,t2.bigint_x from strom_test t1, strom_test t2 where t1.bigint_x=t2.bigint_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x, t.bigint_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.bigint_x, t2.bigint_x
         ->  Custom Scan (GpuSort)
               Output: t1.bigint_x, t2.bigint_x
               Sort Key: t1.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.bigint_x, t2.bigint_x
                     Pseudo Scan: t1.bigint_x::bigint, t2.bigint_x::bigint
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.bigint_x = t2.bigint_x)
                              Nrows (in/out: 0.26%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.bigint_x asc) as rowid,t1.bigint_x,t2.bigint_x from strom_test t1, strom_test t2 where t1.bigint_x=t2.bigint_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.bigint_x, t.bigint_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.bigint_x, t2.bigint_x
         ->  Custom Scan (GpuSort)
               Output: t1.bigint_x, t2.bigint_x
               Sort Key: t1.bigint_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.bigint_x, t2.bigint_x
                     Pseudo Scan: t1.bigint_x::bigint, t2.bigint_x::bigint
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.bigint_x = t2.bigint_x)
                              Nrows (in/out: 0.26%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.real_x desc) as rowid,t1.real_x,t2.real_x from strom_test t1, strom_test t2 where t1.real_x=t2.real_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x, t.real_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.real_x, t2.real_x
         ->  Custom Scan (GpuSort)
               Output: t1.real_x, t2.real_x
               Sort Key: t1.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.real_x, t2.real_x
                     Pseudo Scan: t1.real_x::real, t2.real_x::real
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.real_x = t2.real_x)
                              Nrows (in/out: 0.76%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.real_x asc) as rowid,t1.real_x,t2.real_x from strom_test t1, strom_test t2 where t1.real_x=t2.real_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.real_x, t.real_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.real_x, t2.real_x
         ->  Custom Scan (GpuSort)
               Output: t1.real_x, t2.real_x
               Sort Key: t1.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.real_x, t2.real_x
                     Pseudo Scan: t1.real_x::real, t2.real_x::real
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.real_x = t2.real_x)
                              Nrows (in/out: 0.76%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.float_x desc) as rowid,t1.float_x,t2.float_x from strom_test t1, strom_test t2 where t1.float_x=t2.float_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x, t.float_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.float_x, t2.float_x
         ->  Custom Scan (GpuSort)
               Output: t1.float_x, t2.float_x
               Sort Key: t1.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.float_x, t2.float_x
                     Pseudo Scan: t1.float_x::double precision, t2.float_x::double precision
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.float_x = t2.float_x)
                              Nrows (in/out: 0.26%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.float_x asc) as rowid,t1.float_x,t2.float_x from strom_test t1, strom_test t2 where t1.float_x=t2.float_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.float_x, t.float_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.float_x, t2.float_x
         ->  Custom Scan (GpuSort)
               Output: t1.float_x, t2.float_x
               Sort Key: t1.float_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.float_x, t2.float_x
                     Pseudo Scan: t1.float_x::double precision, t2.float_x::double precision
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.float_x = t2.float_x)
                              Nrows (in/out: 0.26%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.nume_x desc) as rowid,t1.nume_x,t2.nume_x from strom_test t1, strom_test t2 where t1.nume_x=t2.nume_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x, t.nume_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.nume_x, t2.nume_x
         ->  Custom Scan (GpuSort)
               Output: t1.nume_x, t2.nume_x
               Sort Key: t1.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.nume_x, t2.nume_x
                     Pseudo Scan: t1.nume_x::numeric, t2.nume_x::numeric
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.nume_x = t2.nume_x)
                              Nrows (in/out: 0.26%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by t1.nume_x asc) as rowid,t1.nume_x,t2.nume_x from strom_test t1, strom_test t2 where t1.nume_x=t2.nume_x and t1.id%100=0) as t where t.rowid%10=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.nume_x, t.nume_x_1
   Filter: ((t.rowid % '10'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), t1.nume_x, t2.nume_x
         ->  Custom Scan (GpuSort)
               Output: t1.nume_x, t2.nume_x
               Sort Key: t1.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuJoin)
                     Output: t1.nume_x, t2.nume_x
                     Pseudo Scan: t1.nume_x::numeric, t2.nume_x::numeric
                     Bulkload: On (density: 100.00%)
                     Depth 1: GpuNestLoop, JoinQual: (t1.nume_x = t2.nume_x)
                              Nrows (in/out: 0.26%), KDS-Heap (size: 24.48KB, nbatches: 1)
                     Features: format: heap-tuple, bulkload: supported
                     ->  Custom Scan (BulkScan) on public.strom_test t2
                           Output: t2.id, t2.key, t2.smlint_x, t2.integer_x, t2.bigint_x, t2.real_x, t2.float_x, t2.nume_x, t2.smlsrl_x, t2.serial_x, t2.bigsrl_x
                           Features: format: tuple-slot, bulkload: supported
                     ->  Custom Scan (GpuScan) on public.strom_test t1
                           Output: t1.id, t1.key, t1.smlint_x, t1.integer_x, t1.bigint_x, t1.real_x, t1.float_x, t1.nume_x, t1.smlsrl_x, t1.serial_x, t1.bigsrl_x
                           Device Filter: ((t1.id % 100) = 0)
                           Features: format: tuple-slot, bulkload: supported
(23 rows)

--multikey
explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x desc,bigint_x desc,real_x desc,float_x desc,nume_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc,float_x  asc,nume_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc,float_x  asc,nume_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc,float_x desc,nume_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x desc,smlint_x desc,integer_x desc,bigint_x desc,real_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x  asc,smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x desc,smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x  asc,smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc) as rowid,* from strom_test where id between     1 and 10000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 1) AND (strom_test.id <= 10000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x desc,bigint_x desc,real_x desc,float_x desc,nume_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc,float_x  asc,nume_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc,float_x  asc,nume_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc,float_x desc,nume_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x desc,smlint_x desc,integer_x desc,bigint_x desc,real_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x  asc,smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x  asc,nume_x desc,smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by float_x desc,nume_x  asc,smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc) as rowid,* from strom_test where id between 10001 and 20000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.float_x, strom_test.nume_x, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 10001) AND (strom_test.id <= 20000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x desc,bigint_x desc,real_x desc,float_x desc,nume_x desc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x  asc,bigint_x  asc,real_x  asc,float_x  asc,nume_x  asc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x  asc,integer_x desc,bigint_x  asc,real_x desc,float_x  asc,nume_x desc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by smlint_x desc,integer_x  asc,bigint_x desc,real_x  asc,float_x desc,nume_x  asc) as rowid,* from strom_test where id between 20001 and 30000) as t where t.rowid%1000=0;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.key, t.smlint_x, t.integer_x, t.bigint_x, t.real_x, t.float_x, t.nume_x, t.smlsrl_x, t.serial_x, t.bigsrl_x
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
         ->  Custom Scan (GpuSort)
               Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Sort Key: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Custom Scan (GpuScan) on public.strom_test
                     Output: strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.id, strom_test.key, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
                     Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000))
                     Features: format: heap-tuple, bulkload: supported
(13 rows)

--gpusort on zero table
explain (verbose, costs off, timing off) select * from strom_zero_test order by smlint_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.smlint_x
   Features: format: tuple-slot, bulkload: unsupported
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(6 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by integer_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.integer_x
   Features: format: tuple-slot, bulkload: unsupported
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(6 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by bigint_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.bigint_x
   Features: format: tuple-slot, bulkload: unsupported
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(6 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by real_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.real_x
   Features: format: tuple-slot, bulkload: unsupported
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(6 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by float_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.float_x
   Features: format: tuple-slot, bulkload: unsupported
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(6 rows)

explain (verbose, costs off, timing off) select * from strom_zero_test order by nume_x;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
   Sort Key: strom_zero_test.nume_x
   Features: format: tuple-slot, bulkload: unsupported
   ->  Seq Scan on public.strom_zero_test
         Output: id, key, smlint_x, integer_x, bigint_x, real_x, float_x, nume_x, smlsrl_x, serial_x, bigsrl_x
(6 rows)

--gpusort by text-key
explain (verbose, costs off, timing off) select * from (select row_number() over (order by char_x desc) as rowid,char_x from strom_string_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.char_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.char_x
         ->  Custom Scan (GpuSort)
               Output: strom_string_test.char_x
               Sort Key: strom_string_test.char_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.char_x
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by char_x asc) as rowid,char_x from strom_string_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.char_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.char_x
         ->  Custom Scan (GpuSort)
               Output: strom_string_test.char_x
               Sort Key: strom_string_test.char_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.char_x
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by nchar_x desc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.id, strom_string_test.nchar_x
         ->  Custom Scan (GpuSort)
               Output: strom_string_test.nchar_x, strom_string_test.id
               Sort Key: strom_string_test.nchar_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.nchar_x, strom_string_test.id
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by nchar_x asc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.id, strom_string_test.nchar_x
         ->  Custom Scan (GpuSort)
               Output: strom_string_test.nchar_x, strom_string_test.id
               Sort Key: strom_string_test.nchar_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.nchar_x, strom_string_test.id
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by vchar_x desc) as rowid,vchar_x from strom_string_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.vchar_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.vchar_x
         ->  Custom Scan (GpuSort)
               Output: strom_string_test.vchar_x
               Sort Key: strom_string_test.vchar_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.vchar_x
(11 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over (order by vchar_x asc) as rowid,vchar_x from strom_string_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.vchar_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_string_test.vchar_x
         ->  Custom Scan (GpuSort)
               Output: strom_string_test.vchar_x
               Sort Key: strom_string_test.vchar_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_string_test
                     Output: strom_string_test.vchar_x
(11 rows)

-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by nvchar_x desc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by nvchar_x asc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by text_x desc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
-- explain (verbose, costs off, timing off) select * from (select row_number() over (order by text_x asc) as rowid,id from strom_string_test) as t where t.rowid%100=0;
--gpusort order by date/time types.
explain (verbose, costs off, timing off) select rowid,timestamp_x from (select timestamp_x, row_number() over (order by timestamp_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamp_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timestamp_x
               Sort Key: strom_time_test.timestamp_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamp_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,timestamp_x from (select timestamp_x, row_number() over (order by timestamp_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamp_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timestamp_x
               Sort Key: strom_time_test.timestamp_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamp_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,timestamp_x from (select timestamp_x, row_number() over (order by timestamp_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamp_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timestamp_x
               Sort Key: strom_time_test.timestamp_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamp_x
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, timestamp_x from strom_time_test group by timestamp_x ) as t where t.rowid%50=0;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamp_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.timestamp_x
         ->  Group
               Output: strom_time_test.timestamp_x
               Group Key: strom_time_test.timestamp_x
               ->  Custom Scan (GpuSort)
                     Output: strom_time_test.timestamp_x
                     Sort Key: strom_time_test.timestamp_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.timestamp_x
(14 rows)

explain (verbose, costs off, timing off) select rowid,timestamptz_x from (select timestamptz_x, row_number() over (order by timestamptz_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamptz_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timestamptz_x
               Sort Key: strom_time_test.timestamptz_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamptz_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,timestamptz_x from (select timestamptz_x, row_number() over (order by timestamptz_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamptz_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timestamptz_x
               Sort Key: strom_time_test.timestamptz_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamptz_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,timestamptz_x from (select timestamptz_x, row_number() over (order by timestamptz_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timestamptz_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timestamptz_x
               Sort Key: strom_time_test.timestamptz_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timestamptz_x
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, timestamptz_x from strom_time_test group by timestamptz_x ) as t where t.rowid%50=0;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timestamptz_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.timestamptz_x
         ->  Group
               Output: strom_time_test.timestamptz_x
               Group Key: strom_time_test.timestamptz_x
               ->  Custom Scan (GpuSort)
                     Output: strom_time_test.timestamptz_x
                     Sort Key: strom_time_test.timestamptz_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.timestamptz_x
(14 rows)

explain (verbose, costs off, timing off) select rowid,date_x from (select date_x, row_number() over (order by date_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.date_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.date_x
               Sort Key: strom_time_test.date_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.date_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,date_x from (select date_x, row_number() over (order by date_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.date_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.date_x
               Sort Key: strom_time_test.date_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.date_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,date_x from (select date_x, row_number() over (order by date_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.date_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.date_x
               Sort Key: strom_time_test.date_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.date_x
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, date_x from strom_time_test group by date_x ) as t where t.rowid%50=0;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.date_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.date_x
         ->  Group
               Output: strom_time_test.date_x
               Group Key: strom_time_test.date_x
               ->  Custom Scan (GpuSort)
                     Output: strom_time_test.date_x
                     Sort Key: strom_time_test.date_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.date_x
(14 rows)

explain (verbose, costs off, timing off) select rowid,time_x from (select time_x, row_number() over (order by time_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.time_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.time_x
               Sort Key: strom_time_test.time_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.time_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,time_x from (select time_x, row_number() over (order by time_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.time_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.time_x
               Sort Key: strom_time_test.time_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.time_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,time_x from (select time_x, row_number() over (order by time_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.time_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.time_x
               Sort Key: strom_time_test.time_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.time_x
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, time_x from strom_time_test group by time_x ) as t where t.rowid%50=0;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.time_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.time_x
         ->  Group
               Output: strom_time_test.time_x
               Group Key: strom_time_test.time_x
               ->  Custom Scan (GpuSort)
                     Output: strom_time_test.time_x
                     Sort Key: strom_time_test.time_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.time_x
(14 rows)

explain (verbose, costs off, timing off) select rowid,timetz_x from (select timetz_x, row_number() over (order by timetz_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timetz_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timetz_x
               Sort Key: strom_time_test.timetz_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timetz_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,timetz_x from (select timetz_x, row_number() over (order by timetz_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timetz_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timetz_x
               Sort Key: strom_time_test.timetz_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timetz_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,timetz_x from (select timetz_x, row_number() over (order by timetz_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.timetz_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.timetz_x
               Sort Key: strom_time_test.timetz_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.timetz_x
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, timetz_x from strom_time_test group by timetz_x ) as t where t.rowid%50=0;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.timetz_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.timetz_x
         ->  Group
               Output: strom_time_test.timetz_x
               Group Key: strom_time_test.timetz_x
               ->  Custom Scan (GpuSort)
                     Output: strom_time_test.timetz_x
                     Sort Key: strom_time_test.timetz_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.timetz_x
(14 rows)

explain (verbose, costs off, timing off) select rowid,interval_x from (select interval_x, row_number() over (order by interval_x asc ) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.interval_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.interval_x
               Sort Key: strom_time_test.interval_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.interval_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,interval_x from (select interval_x, row_number() over (order by interval_x asc NULLS FIRST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.interval_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.interval_x
               Sort Key: strom_time_test.interval_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.interval_x
(11 rows)

explain (verbose, costs off, timing off) select rowid,interval_x from (select interval_x, row_number() over (order by interval_x desc NULLS LAST) as rowid from strom_time_test) as t where t.rowid%100=0;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '100'::bigint) = 0)
   ->  WindowAgg
         Output: strom_time_test.interval_x, row_number() OVER (?)
         ->  Custom Scan (GpuSort)
               Output: strom_time_test.interval_x
               Sort Key: strom_time_test.interval_x
               Features: format: tuple-slot, bulkload: unsupported
               ->  Seq Scan on public.strom_time_test
                     Output: strom_time_test.interval_x
(11 rows)

explain (verbose, costs off, timing off) select * from ( select row_number() over () as rowid, interval_x from strom_time_test group by interval_x ) as t where t.rowid%50=0;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.interval_x
   Filter: ((t.rowid % '50'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), strom_time_test.interval_x
         ->  Group
               Output: strom_time_test.interval_x
               Group Key: strom_time_test.interval_x
               ->  Custom Scan (GpuSort)
                     Output: strom_time_test.interval_x
                     Sort Key: strom_time_test.interval_x
                     Features: format: tuple-slot, bulkload: unsupported
                     ->  Seq Scan on public.strom_time_test
                           Output: strom_time_test.interval_x
(14 rows)

