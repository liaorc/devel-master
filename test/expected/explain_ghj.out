--#
--#       Gpu HashJoin Explain TestCases. 
--#
set enable_nestloop to off;
set pg_strom.gpu_setup_cost=0;
set pg_strom.enable_gpupreagg to off;
set pg_strom.enable_gpusort to off;
set random_page_cost=1000000;   --# force off index_scan.
set client_min_messages to warning;
set pg_strom.enabled=off;
---
--- BULKLOAD ON
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
         Hash Cond: ((strom_test.smlint_x = strom_test_1.smlint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.smlint_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.smlint_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
         Hash Cond: ((strom_test.integer_x = strom_test_1.integer_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.integer_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.integer_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE '0'::bigint END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE '0'::bigint END
         Hash Cond: ((strom_test.bigint_x = strom_test_1.bigint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.bigint_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.bigint_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE '0'::real END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE '0'::real END
         Hash Cond: ((strom_test.real_x = strom_test_1.real_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.real_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.real_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE '0'::double precision END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE '0'::double precision END
         Hash Cond: ((strom_test.float_x = strom_test_1.float_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.float_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.float_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE '0'::numeric END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE '0'::numeric END
         Hash Cond: ((strom_test.nume_x = strom_test_1.nume_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.nume_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.nume_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
         Hash Cond: ((strom_test.smlsrl_x = strom_test_1.smlsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.smlsrl_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.smlsrl_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
         Hash Cond: ((strom_test.serial_x = strom_test_1.serial_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.serial_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.serial_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE '0'::bigint END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE '0'::bigint END
         Hash Cond: ((strom_test.bigsrl_x = strom_test_1.bigsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Hash
               Output: strom_test_1.bigsrl_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.bigsrl_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(14 rows)

---
--- BULKLOAD OFF
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
         Hash Cond: ((strom_test.smlint_x = strom_test_1.smlint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.smlint_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.smlint_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
         Hash Cond: ((strom_test.integer_x = strom_test_1.integer_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.integer_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.integer_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE '0'::bigint END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE '0'::bigint END
         Hash Cond: ((strom_test.bigint_x = strom_test_1.bigint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.bigint_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.bigint_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE '0'::real END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE '0'::real END
         Hash Cond: ((strom_test.real_x = strom_test_1.real_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.real_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.real_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE '0'::double precision END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE '0'::double precision END
         Hash Cond: ((strom_test.float_x = strom_test_1.float_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.float_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.float_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE '0'::numeric END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE '0'::numeric END
         Hash Cond: ((strom_test.nume_x = strom_test_1.nume_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.nume_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.nume_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
         Hash Cond: ((strom_test.smlsrl_x = strom_test_1.smlsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.smlsrl_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.smlsrl_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
         Hash Cond: ((strom_test.serial_x = strom_test_1.serial_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.serial_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.serial_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE '0'::bigint END)
   Sort Key: strom_test.id
   ->  Hash Join
         Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE '0'::bigint END
         Hash Cond: ((strom_test.bigsrl_x = strom_test_1.bigsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Hash
               Output: strom_test_1.bigsrl_x, strom_test_1.id
               ->  Seq Scan on public.strom_test strom_test_1
                     Output: strom_test_1.bigsrl_x, strom_test_1.id
                     Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(14 rows)

set enable_nestloop=on;
set pg_strom.enabled=on;
---
--- BULKLOAD ON
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.smlint_x = strom_test_1.smlint_x))
   ->  Sort
         Output: strom_test.id, strom_test.smlint_x
         Sort Key: strom_test.id, strom_test.smlint_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.smlint_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.smlint_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.smlint_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.smlint_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.integer_x = strom_test_1.integer_x))
   ->  Sort
         Output: strom_test.id, strom_test.integer_x
         Sort Key: strom_test.id, strom_test.integer_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.integer_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.integer_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.integer_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.integer_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE '0'::bigint END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.bigint_x = strom_test_1.bigint_x))
   ->  Sort
         Output: strom_test.id, strom_test.bigint_x
         Sort Key: strom_test.id, strom_test.bigint_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.bigint_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.bigint_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.bigint_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.bigint_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE '0'::real END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.real_x = strom_test_1.real_x))
   ->  Sort
         Output: strom_test.id, strom_test.real_x
         Sort Key: strom_test.id, strom_test.real_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.real_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.real_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.real_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.real_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE '0'::double precision END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.float_x = strom_test_1.float_x))
   ->  Sort
         Output: strom_test.id, strom_test.float_x
         Sort Key: strom_test.id, strom_test.float_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.float_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.float_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.float_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.float_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE '0'::numeric END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.nume_x = strom_test_1.nume_x))
   ->  Sort
         Output: strom_test.id, strom_test.nume_x
         Sort Key: strom_test.id, strom_test.nume_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.nume_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.nume_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.nume_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.nume_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.smlsrl_x = strom_test_1.smlsrl_x))
   ->  Sort
         Output: strom_test.id, strom_test.smlsrl_x
         Sort Key: strom_test.id, strom_test.smlsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.smlsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.smlsrl_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.smlsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.smlsrl_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.serial_x = strom_test_1.serial_x))
   ->  Sort
         Output: strom_test.id, strom_test.serial_x
         Sort Key: strom_test.id, strom_test.serial_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.serial_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.serial_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.serial_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.serial_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE '0'::bigint END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.bigsrl_x = strom_test_1.bigsrl_x))
   ->  Sort
         Output: strom_test.id, strom_test.bigsrl_x
         Sort Key: strom_test.id, strom_test.bigsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
   ->  Sort
         Output: strom_test_1.bigsrl_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.bigsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.bigsrl_x, strom_test_1.id
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: supported
(17 rows)

---
--- BULKLOAD OFF
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.smlint_x = strom_test_1.smlint_x))
   ->  Sort
         Output: strom_test.id, strom_test.smlint_x
         Sort Key: strom_test.id, strom_test.smlint_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.smlint_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.smlint_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.smlint_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.smlint_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.integer_x = strom_test_1.integer_x))
   ->  Sort
         Output: strom_test.id, strom_test.integer_x
         Sort Key: strom_test.id, strom_test.integer_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.integer_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.integer_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.integer_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.integer_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE '0'::bigint END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.bigint_x = strom_test_1.bigint_x))
   ->  Sort
         Output: strom_test.id, strom_test.bigint_x
         Sort Key: strom_test.id, strom_test.bigint_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.bigint_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.bigint_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.bigint_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.bigint_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE '0'::real END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.real_x = strom_test_1.real_x))
   ->  Sort
         Output: strom_test.id, strom_test.real_x
         Sort Key: strom_test.id, strom_test.real_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.real_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.real_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.real_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.real_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE '0'::double precision END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.float_x = strom_test_1.float_x))
   ->  Sort
         Output: strom_test.id, strom_test.float_x
         Sort Key: strom_test.id, strom_test.float_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.float_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.float_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.float_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.float_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE '0'::numeric END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.nume_x = strom_test_1.nume_x))
   ->  Sort
         Output: strom_test.id, strom_test.nume_x
         Sort Key: strom_test.id, strom_test.nume_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.nume_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.nume_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.nume_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.nume_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.smlsrl_x = strom_test_1.smlsrl_x))
   ->  Sort
         Output: strom_test.id, strom_test.smlsrl_x
         Sort Key: strom_test.id, strom_test.smlsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.smlsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.smlsrl_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.smlsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.smlsrl_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.serial_x = strom_test_1.serial_x))
   ->  Sort
         Output: strom_test.id, strom_test.serial_x
         Sort Key: strom_test.id, strom_test.serial_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.serial_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.serial_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.serial_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.serial_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE '0'::bigint END
   Merge Cond: ((strom_test.id = strom_test_1.id) AND (strom_test.bigsrl_x = strom_test_1.bigsrl_x))
   ->  Sort
         Output: strom_test.id, strom_test.bigsrl_x
         Sort Key: strom_test.id, strom_test.bigsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
   ->  Sort
         Output: strom_test_1.bigsrl_x, strom_test_1.id
         Sort Key: strom_test_1.id, strom_test_1.bigsrl_x
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.bigsrl_x, strom_test_1.id
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: format: tuple-slot, bulkload: unsupported
(19 rows)

